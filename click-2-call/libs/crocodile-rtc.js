/*! Crocodile WebRTC SDK: JavaScript Library - v1.0 - 2013-11-18
* https://www.crocodilertc.net
* Copyright (c) 2013 Crocodile RCS Ltd; Licensed MIT
*
* Incorporates the following third-party open source software:
*
* JsSIP (http://www.jssip.net/)
*  Copyright (c) 2012-2013 José Luis Millán - Versatica
*  License: MIT
*
* JSJaC (https://github.com/sstrigler/JSJaC)
*  Copyright (c) 2004-2008 Stefan Strigler
*  License: MPL-1.1/GPL-2.0+/LGPL-2.1+
*/
/*global console: false*/

/**
 * @name JsSIP
 * @namespace
 */
(function(window) {

var JsSIP = (function() {
  "use strict";

  var JsSIP = {};

  Object.defineProperties(JsSIP, {
    version: {
      get: function(){ return '0.3.0-crocodile-1-devel'; }
    },
    name: {
      get: function(){ return 'JsSIP'; }
    }
  });

  return JsSIP;
}());



/**
 * @fileoverview EventEmitter
 */

/**
 * @augments JsSIP
 * @class Class creating an event emitter.
 */
(function(JsSIP) {
var
  EventEmitter,
  Event,
  LOG_PREFIX = JsSIP.name +' | '+ 'EVENT EMITTER' +' | ';

EventEmitter = function(){};
EventEmitter.prototype = {
  /**
   * Initialize events dictionary.
   * @param {Array} events
   */
  initEvents: function(events) {
    var i = events.length;

    this.events = {};
    this.onceNotFired = []; // Array containing events with _once_ defined tat didn't fire yet.
    this.maxListeners = 10;
    this.events.newListener = function(event) { // Default newListener callback
      console.log(LOG_PREFIX +'new listener added to event '+ event);
    };

    while (i--) {
      console.log(LOG_PREFIX +'adding event '+ events[i]);
      this.events[events[i]] = [];
    }
  },

  /**
  * Check whether an event exists or not.
  * @param {String} event
  * @returns {Boolean}
  */
  checkEvent: function(event) {
    if (!this.events[event]) {
      console.error(LOG_PREFIX +'no event named '+ event);
      return false;
    } else {
      return true;
    }
  },

  /**
  * Add a listener to the end of the listeners array for the specified event.
  * @param {String} event
  * @param {Function} listener
  */
  addListener: function(event, listener) {
    if (!this.checkEvent(event)) {
      return;
    }

    if (this.events[event].length >= this.maxListeners) {
      console.warn(LOG_PREFIX +'max listeners exceeded for event '+ event);
    }

    this.events[event].push(listener);
    this.events.newListener.call(null, event);
  },

  on: function(event, listener) {
    this.addListener(event, listener);
  },

  /**
  * Add a one time listener for the event.
  * The listener is invoked only the first time the event is fired, after which it is removed.
  * @param {String} event
  * @param {Function} listener
  */
  once: function(event, listener) {
    this.events[event].unshift(listener);
    this.onceNotFired.push(event);
  },

  /**
  * Remove a listener from the listener array for the specified event.
  * Caution: changes array indices in the listener array behind the listener.
  * @param {String} event
  * @param {Function} listener
  */
  removeListener: function(event, listener) {
    if (!this.checkEvent(event)) {
      return;
    }

    var array = this.events[event], i = 0, length = array.length;

    while ( i < length ) {
      if (array[i] && array[i].toString() === listener.toString()) {
        array.splice(i, 1);
      } else {
        i++;
      }
    }
  },

  /**
  * Remove all listeners from the listener array for the specified event.
  * @param {String} event
  */
  removeAllListener: function(event) {
    if (!this.checkEvent(event)) {
      return;
    }

    this.events[event] = [];
  },

  /**
  * By default EventEmitter will print a warning
  * if more than 10 listeners are added for a particular event.
  * This function allows that limit to be modified.
  * @param {Number} listeners
  */
  setMaxListeners: function(listeners) {
    if (Number(listeners)) {
      this.maxListeners = listeners;
    }
  },

  /**
  * Get the listeners for a specific event.
  * @param {String} event
  * @returns {Array}  Array of listeners for the specified event.
  */
  listeners: function(event) {
    return this.events[event];
  },

  /**
  * Execute each of the listeners in order with the supplied arguments.
  * @param {String} events
  * @param {Array} args
  */
  emit: function(event, sender, data) {
    var listeners, length,
      idx=0;

    if (!this.checkEvent(event)) {
      return;
    }

    console.log(LOG_PREFIX +'emitting event '+event);

    listeners = this.events[event];
    length = listeners.length;

    var e = new JsSIP.Event(event, sender, data);

    if (e) {
      for (idx; idx<length; idx++) {
        try {
          listeners[idx].apply(null, [e]);
        } catch (ex) {
          console.warn(LOG_PREFIX + 'event handler threw exception:\n', ex.stack);
        }
      }
    } else {
      for (idx; idx<length; idx++) {
        try {
          listeners[idx].call();
        } catch (ex) {
          console.warn(LOG_PREFIX + 'event handler threw exception:\n', ex.stack);
        }
      }
    }

    // Check whether _once_ was defined for the event
    idx = this.onceNotFired.indexOf(event);

    if (idx !== -1) {
      this.onceNotFired.splice(idx,1);
      this.events[event].shift();
    }
  },

  /**
  * This function is executed anytime a new listener is added to EventEmitter instance.
  * @param {Function} listener
  */
  newListener: function(listener) {
    this.events.newListener = listener;
  }
};

Event = function(type, sender, data) {
  this.type = type;
  this.sender= sender;
  this.data = data;
};

JsSIP.EventEmitter = EventEmitter;
JsSIP.Event = Event;
}(JsSIP));



/**
 * @fileoverview JsSIP Constants
 */

/**
 * JsSIP Constants.
 * @augments JsSIP
 */

JsSIP.C= {
  USER_AGENT: JsSIP.name +' '+ JsSIP.version,

  // SIP scheme
  SIP: 'sip',

  // Invalid target
  INVALID_TARGET_URI: 'sip:invalid@invalid',

  // End and Failure causes
  causes: {
    // Generic error causes
    CONNECTION_ERROR:         'Connection Error',
    REQUEST_TIMEOUT:          'Request Timeout',
    SIP_FAILURE_CODE:         'SIP Failure Code',
    INVALID_TARGET:           'Invalid Target',
    INVALID_REFER_TO_TARGET:  'Invalid Refer-To Target',
    INTERNAL_ERROR:           'Internal Error',

    // SIP error causes
    BUSY:                     'Busy',
    REJECTED:                 'Rejected',
    REDIRECTED:               'Redirected',
    UNAVAILABLE:              'Unavailable',
    NOT_FOUND:                'Not Found',
    ADDRESS_INCOMPLETE:       'Address Incomplete',
    INCOMPATIBLE_SDP:         'Incompatible SDP',
    AUTHENTICATION_ERROR:     'Authentication Error',
    DIALOG_ERROR:             'Dialog Error',

    // Session error causes
    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',
    WEBRTC_ERROR:             'WebRTC Error',
    CANCELED:                 'Canceled',
    NO_ANSWER:                'No Answer',
    EXPIRES:                  'Expires',
    NO_ACK:                   'No ACK',
    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',
    RTP_TIMEOUT:              'RTP Timeout',
    SESSION_TIMER:            'Session Timer Expired'
  },

  SIP_ERROR_CAUSES: {
    REDIRECTED: [300,301,302,305,380],
    BUSY: [486,600],
    REJECTED: [403,603],
    NOT_FOUND: [404,604],
    UNAVAILABLE: [480,410,408,430],
    ADDRESS_INCOMPLETE: [484],
    INCOMPATIBLE_SDP: [488,606],
    AUTHENTICATION_ERROR:[401,407]
  },

  // SIP Methods
  ACK:        'ACK',
  BYE:        'BYE',
  CANCEL:     'CANCEL',
  INFO:       'INFO',
  INVITE:     'INVITE',
  MESSAGE:    'MESSAGE',
  NOTIFY:     'NOTIFY',
  OPTIONS:    'OPTIONS',
  REGISTER:   'REGISTER',
  UPDATE:     'UPDATE',
  SUBSCRIBE:  'SUBSCRIBE',
  REFER:      'REFER',

  // SIP Extensions
  SIP_EXTENSIONS: {
    TIMER: 'timer',             // RFC 4028
    TARGET_DIALOG: 'tdialog',   // RFC 4538
    GRUU: 'gruu'
  },

  /* SIP Response Reasons
   * DOC: http://www.iana.org/assignments/sip-parameters
   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
   */
  REASON_PHRASE: {
    100: 'Trying',
    180: 'Ringing',
    181: 'Call Is Being Forwarded',
    182: 'Queued',
    183: 'Session Progress',
    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199
    200: 'OK',
    202: 'Accepted',  // RFC 3265
    204: 'No Notification',  //RFC 5839
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Moved Temporarily',
    305: 'Use Proxy',
    380: 'Alternative Service',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Timeout',
    410: 'Gone',
    412: 'Conditional Request Failed',  // RFC 3903
    413: 'Request Entity Too Large',
    414: 'Request-URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Unsupported URI Scheme',
    417: 'Unknown Resource-Priority',  // RFC 4412
    420: 'Bad Extension',
    421: 'Extension Required',
    422: 'Session Interval Too Small',  // RFC 4028
    423: 'Interval Too Brief',
    428: 'Use Identity Header',  // RFC 4474
    429: 'Provide Referrer Identity',  // RFC 3892
    430: 'Flow Failed',  // RFC 5626
    433: 'Anonymity Disallowed',  // RFC 5079
    436: 'Bad Identity-Info',  // RFC 4474
    437: 'Unsupported Certificate',  // RFC 4744
    438: 'Invalid Identity Header',  // RFC 4744
    439: 'First Hop Lacks Outbound Support',  // RFC 5626
    440: 'Max-Breadth Exceeded',  // RFC 5393
    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events
    470: 'Consent Needed',  // RFC 5360
    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.
    480: 'Temporarily Unavailable',
    481: 'Call/Transaction Does Not Exist',
    482: 'Loop Detected',
    483: 'Too Many Hops',
    484: 'Address Incomplete',
    485: 'Ambiguous',
    486: 'Busy Here',
    487: 'Request Terminated',
    488: 'Not Acceptable Here',
    489: 'Bad Event',  // RFC 3265
    491: 'Request Pending',
    493: 'Undecipherable',
    494: 'Security Agreement Required',  // RFC 3329
    500: 'Server Internal Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Server Time-out',
    505: 'Version Not Supported',
    513: 'Message Too Large',
    580: 'Precondition Failure',  // RFC 3312
    600: 'Busy Everywhere',
    603: 'Decline',
    604: 'Does Not Exist Anywhere',
    606: 'Not Acceptable'
  }
};



/**
 * @fileoverview Exceptions
 */

/**
 * JsSIP Exceptions.
 * @augments JsSIP
 */
(function(JsSIP) {
var Exceptions;

Exceptions= {
  ConfigurationError: (function(){
    var exception = function(parameter, value) {
      this.code = 1;
      this.name = 'CONFIGURATION_ERROR';
      this.parameter = parameter;
      this.value = value;
      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ window.JSON.stringify(this.value) +' for parameter "'+ this.parameter +'"';
    };
    exception.prototype = new Error();
    return exception;
  }()),

  InvalidTargetError: (function(){
    var exception = function(target) {
      this.code = 2;
      this.name = 'INVALID_TARGET_ERROR';
      this.target = target;
      this.message = 'Invalid target: ' + this.target;
    };
    exception.prototype = new Error();
    return exception;
  }()),

  InvalidStateError: (function(){
    var exception = function(status) {
      this.code = 3;
      this.name = 'INVALID_STATE_ERROR';
      this.status = status;
    };
    exception.prototype = new Error();
    return exception;
  }()),

  RemoteSupportError: (function(){
    var exception = function(option) {
      this.code = 4;
      this.name = 'REMOTE_SUPPORT_ERROR';
      this.option = option;
      this.message = 'Remote UA does not support method/extension: ' + option;
    };
    exception.prototype = new Error();
    return exception;
  }())
};

JsSIP.Exceptions = Exceptions;
}(JsSIP));


/**
 * @fileoverview SIP TIMERS
 */

/**
 * @augments JsSIP
 */
(function(JsSIP) {
var Timers,
  T1 = 500,
  T2 = 4000,
  T4 = 5000;

Timers = {
  T1: T1,
  T2: T2,
  T4: T4,
  TIMER_B: 64 * T1,
  TIMER_D: 0  * T1,
  TIMER_F: 64 * T1,
  TIMER_H: 64 * T1,
  TIMER_I: 0  * T1,
  TIMER_J: 0  * T1,
  TIMER_K: 0  * T4,
  TIMER_L: 64 * T1,
  TIMER_M: 64 * T1
};

JsSIP.Timers = Timers;
}(JsSIP));



/**
 * @fileoverview Transport
 */

/**
 * @augments JsSIP
 * @class Transport
 * @param {JsSIP.UA} ua
 * @param {Object} server ws_server Object
 */
(function(JsSIP) {
var Transport,
  LOG_PREFIX = JsSIP.name +' | '+ 'TRANSPORT' +' | ',
  C = {
    // Transport status codes
    STATUS_READY:        0,
    STATUS_DISCONNECTED: 1,
    STATUS_ERROR:        2
  };

Transport = function(ua, server) {
  this.ua = ua;
  this.ws = null;
  this.server = server;
  this.reconnection_attempts = 0;
  this.closed = false;
  this.connected = false;
  this.reconnectTimer = null;
  this.lastTransportError = {};

  this.ua.transport = this;

  // Connect
  this.connect();
};

Transport.prototype = {
  /**
   * Send a message.
   * @param {JsSIP.OutgoingRequest|String} msg
   * @returns {Boolean}
   */
  send: function(msg) {
    var message = msg.toString();

    if(this.ws && this.ws.readyState === WebSocket.OPEN) {
      if (this.ua.configuration.trace_sip === true) {
        console.log(LOG_PREFIX +'sending WebSocket message:\n\n' + message + '\n');
      }
      this.ws.send(message);
      return true;
    } else {
      console.warn(LOG_PREFIX +'unable to send message, WebSocket is not open');
      return false;
    }
  },

  /**
  * Disconnect socket.
  */
  disconnect: function() {
    if(this.ws) {
      this.closed = true;
      console.log(LOG_PREFIX +'closing WebSocket ' + this.server.ws_uri);
      this.ws.close();
    }

    if (this.reconnectTimer !== null) {
      window.clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
      this.ua.emit('disconnected', this.ua, {
        transport: this,
        code: this.lastTransportError.code,
        reason: this.lastTransportError.reason
      });
    }
  },

  /**
  * Connect socket.
  */
  connect: function() {
    var transport = this;

    if(this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
      console.log(LOG_PREFIX +'WebSocket ' + this.server.ws_uri + ' is already connected');
      return false;
    }

    if(this.ws) {
      this.ws.close();
    }

    console.log(LOG_PREFIX +'connecting to WebSocket ' + this.server.ws_uri);

    try {
      this.ws = new WebSocket(this.server.ws_uri, 'sip');
    } catch(e) {
      console.warn(LOG_PREFIX +'error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);
    }

    this.ws.binaryType = 'arraybuffer';

    this.ws.onopen = function() {
      transport.onOpen();
    };

    this.ws.onclose = function(e) {
      transport.onClose(e);
    };

    this.ws.onmessage = function(e) {
      transport.onMessage(e);
    };

    this.ws.onerror = function(e) {
      transport.onError(e);
    };
  },

  // Transport Event Handlers

  /**
  * @event
  * @param {event} e
  */
  onOpen: function() {
    this.connected = true;

    console.log(LOG_PREFIX +'WebSocket ' + this.server.ws_uri + ' connected');
    // Clear reconnectTimer since we are not disconnected
    if (this.reconnectTimer !== null) {
      window.clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    // Reset reconnection_attempts
    this.reconnection_attempts = 0;
    // Disable closed
    this.closed = false;
    // Trigger onTransportConnected callback
    this.ua.onTransportConnected(this);
  },

  /**
  * @event
  * @param {event} e
  */
  onClose: function(e) {
    var connected_before = this.connected;

    this.connected = false;
    this.lastTransportError.code = e.code;
    this.lastTransportError.reason = e.reason;
    console.log(LOG_PREFIX +'WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');

    if(e.wasClean === false) {
      console.warn(LOG_PREFIX +'WebSocket abrupt disconnection');
    }
    // Transport was connected
    if(connected_before === true) {
      this.ua.onTransportClosed(this);
      // Check whether the user requested to close.
      if(!this.closed) {
        this.reConnect();
      } else {
        this.ua.emit('disconnected', this.ua, {
          transport: this,
          code: this.lastTransportError.code,
          reason: this.lastTransportError.reason
        });
      }
    } else {
      // This is the first connection attempt
      //Network error
      this.ua.onTransportError(this);
    }
  },

  /**
  * @event
  * @param {event} e
  */
  onMessage: function(e) {
    var message, transaction,
      data = e.data;

    // CRLF Keep Alive response from server. Ignore it.
    if(data === '\r\n') {
      if (this.ua.configuration.trace_sip === true) {
        console.log(LOG_PREFIX +'received WebSocket message with CRLF Keep Alive response');
      }
      return;
    }

    // WebSocket binary message.
    else if (typeof data !== 'string') {
      try {
        data = String.fromCharCode.apply(null, new Uint8Array(data));
      } catch(evt) {
        console.warn(LOG_PREFIX +'received WebSocket binary message failed to be converted into string, message discarded');
        return;
      }

      if (this.ua.configuration.trace_sip === true) {
        console.log(LOG_PREFIX +'received WebSocket binary message:\n\n' + data + '\n');
      }
    }

    // WebSocket text message.
    else {
      if (this.ua.configuration.trace_sip === true) {
        console.log(LOG_PREFIX +'received WebSocket text message:\n\n' + data + '\n');
      }
    }

    message = JsSIP.Parser.parseMessage(data);

    if(this.ua.status === JsSIP.UA.C.STATUS_USER_CLOSED && message instanceof JsSIP.IncomingRequest) {
      return;
    }

    // Do some sanity check
    if(message && JsSIP.sanityCheck(message, this.ua, this)) {
      if(message instanceof JsSIP.IncomingRequest) {
        message.transport = this;
        this.ua.receiveRequest(message);
      } else if(message instanceof JsSIP.IncomingResponse) {
        /* Unike stated in 18.1.2, if a response does not match
        * any transaction, it is discarded here and no passed to the core
        * in order to be discarded there.
        */
        switch(message.method) {
          case JsSIP.C.INVITE:
            transaction = this.ua.transactions.ict[message.via_branch];
            if(transaction) {
              transaction.receiveResponse(message);
            }
            break;
          case JsSIP.C.ACK:
            // Just in case ;-)
            break;
          default:
            transaction = this.ua.transactions.nict[message.via_branch];
            if(transaction) {
              transaction.receiveResponse(message);
            }
            break;
        }
      }
    }
  },

  /**
  * @event
  * @param {event} e
  */
  onError: function(e) {
    console.warn(LOG_PREFIX +'WebSocket connection error: ' + e);
  },

  /**
  * Reconnection attempt logic.
  * @private
  */
  reConnect: function() {
    var transport = this;

    this.reconnection_attempts += 1;

    if(this.reconnection_attempts > this.ua.configuration.ws_server_max_reconnection) {
      console.warn(LOG_PREFIX +'maximum reconnection attempts for WebSocket ' + this.server.ws_uri);
      this.ua.onTransportError(this);
    } else {
      console.log(LOG_PREFIX +'trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')');

      this.reconnectTimer = window.setTimeout(function() {
        transport.connect();
        transport.reconnectTimer = null;
      }, this.ua.configuration.ws_server_reconnection_timeout * 1000);
    }
  }
};

Transport.C = C;
JsSIP.Transport = Transport;
}(JsSIP));



/**
 * @fileoverview SIP Message Parser
 */

/**
 * Extract and parse every header of a SIP message.
 * @augments JsSIP
 * @namespace
 */
(function(JsSIP) {
var Parser,
  LOG_PREFIX = JsSIP.name +' | '+ 'PARSER' +' | ';

function getHeader(data, headerStart) {
  var
    // 'start' position of the header.
    start = headerStart,
    // 'end' position of the header.
    end = 0,
    // 'partial end' position of the header.
    partialEnd = 0;

  //End of message.
  if (data.substring(start, start + 2).match(/(^\r\n)/)) {
    return -2;
  }

  while(end === 0) {
    // Partial End of Header.
    partialEnd = data.indexOf('\r\n', start);

    // 'indexOf' returns -1 if the value to be found never occurs.
    if (partialEnd === -1) {
      return partialEnd;
    }

    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
      // Not the end of the message. Continue from the next position.
      start = partialEnd + 2;
    } else {
      end = partialEnd;
    }
  }

  return end;
}

function parseHeader(message, data, headerStart, headerEnd) {
  var header, idx, parsed,
    hcolonIndex = data.indexOf(':', headerStart),
    headerName = data.substring(headerStart, hcolonIndex).trim(),
    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();

  // If header-field is well-known, parse it.
  switch(headerName.toLowerCase()) {
    case 'via':
    case 'v':
      message.addHeader('via', headerValue);
      if(message.countHeader('via') === 1) {
        parsed = message.parseHeader('Via');
        if(parsed) {
          message.via = parsed;
          message.via_branch = parsed.branch;
        }
      } else {
        parsed = 0;
      }
      break;
    case 'from':
    case 'f':
      message.setHeader('from', headerValue);
      parsed = message.parseHeader('from');
      if(parsed) {
        message.from = parsed;
        message.from_tag = parsed.getParam('tag');
      }
      break;
    case 'to':
    case 't':
      message.setHeader('to', headerValue);
      parsed = message.parseHeader('to');
      if(parsed) {
        message.to = parsed;
        message.to_tag = parsed.getParam('tag');
      }
      break;
    case 'record-route':
      parsed = JsSIP.Grammar.parse(headerValue, 'Record_Route');

      if (parsed === -1) {
        parsed = undefined;
      }

      for(idx in parsed) {
        header = parsed[idx];
        message.addHeader('record-route', headerValue.substring(header.possition, header.offset));
        message.headers['Record-Route'][message.countHeader('record-route')-1].parsed = header.parsed;
      }
      break;
    case 'call-id':
    case 'i':
      message.setHeader('call-id', headerValue);
      parsed = message.parseHeader('call-id');
      if(parsed) {
        message.call_id = headerValue;
      }
      break;
    case 'contact':
    case 'm':
      parsed = JsSIP.Grammar.parse(headerValue, 'Contact');

      if (parsed === -1) {
        parsed = undefined;
      }

      for(idx in parsed) {
        header = parsed[idx];
        message.addHeader('contact', headerValue.substring(header.possition, header.offset));
        message.headers['Contact'][message.countHeader('contact')-1].parsed = header.parsed;
      }
      break;
    case 'content-length':
    case 'l':
      message.setHeader('content-length', headerValue);
      parsed = message.parseHeader('content-length');
      break;
    case 'content-type':
    case 'c':
      message.setHeader('content-type', headerValue);
      parsed = message.parseHeader('content-type');
      break;
    case 'cseq':
      message.setHeader('cseq', headerValue);
      parsed = message.parseHeader('cseq');
      if(parsed) {
        message.cseq = parsed.value;
      }
      if(message instanceof JsSIP.IncomingResponse) {
        message.method = parsed.method;
      }
      break;
    case 'max-forwards':
      message.setHeader('max-forwards', headerValue);
      parsed = message.parseHeader('max-forwards');
      break;
    case 'www-authenticate':
      message.setHeader('www-authenticate', headerValue);
      parsed = message.parseHeader('www-authenticate');
      break;
    case 'proxy-authenticate':
      message.setHeader('proxy-authenticate', headerValue);
      parsed = message.parseHeader('proxy-authenticate');
      break;
    case 'session-expires':
    case 'x':
      message.setHeader('session-expires', headerValue);
      parsed = message.parseHeader('session-expires');
      break;
    case 'min-se':
      message.setHeader('min-se', headerValue);
      parsed = message.parseHeader('min-se');
      break;
    case 'supported':
    case 'k':
      message.setHeader('supported', headerValue);
      parsed = message.parseHeader('supported');
      break;
    case 'require':
      message.setHeader('require', headerValue);
      parsed = message.parseHeader('require');
      break;
    case 'allow':
      message.setHeader('allow', headerValue);
      parsed = message.parseHeader('allow');
      break;
    case 'refer-to':
    case 'r':
      message.setHeader('refer-to', headerValue);
      parsed = message.parseHeader('refer-to');
      break;
    case 'target-dialog':
      message.setHeader('target-dialog', headerValue);
      parsed = message.parseHeader('target-dialog');
      break;
    case 'event':
    case 'o':
      message.setHeader('event', headerValue);
      parsed = message.parseHeader('event');
      break;
    case 'subscription-state':
      message.setHeader('subscription-state', headerValue);
      parsed = message.parseHeader('subscription-state');
      break;
    default:
      // Do not parse this header.
      message.setHeader(headerName, headerValue);
      parsed = 0;
  }

  if (parsed === undefined) {
    return false;
  } else {
    return true;
  }
}

/** Parse SIP Message
 * @function
 * @param {String} message SIP message.
 * @param {Boolean} Indicates a SIP fragment message (RFC 3420).
 * @returns {JsSIP.IncomingRequest|JsSIP.IncomingResponse|undefined}
 */
Parser = {};
Parser.parseMessage = function(data, sipfrag) {
  var message, firstLine, contentLength, bodyStart, parsed,
    headerStart = 0,
    headerEnd = data.indexOf('\r\n');

  if(headerEnd === -1) {
    console.warn(LOG_PREFIX +'no CRLF found, not a SIP message, discarded');
    return;
  }

  // Parse first line. Check if it is a Request or a Reply.
  firstLine = data.substring(0, headerEnd);
  parsed = JsSIP.Grammar.parse(firstLine, 'Request_Response');

  if(parsed === -1) {
    console.warn(LOG_PREFIX +'error parsing first line of SIP message: "' + firstLine + '"');
    return;
  } else if(!parsed.status_code) {
    message = new JsSIP.IncomingRequest();
    message.method = parsed.method;
    message.ruri = parsed.uri;
  } else {
    message = new JsSIP.IncomingResponse();
    message.status_code = parsed.status_code;
    message.reason_phrase = parsed.reason_phrase;
  }

  message.data = data;
  headerStart = headerEnd + 2;

  /* Loop over every line in data. Detect the end of each header and parse
  * it or simply add to the headers collection.
  */
  while(headerStart < data.length) {
    headerEnd = getHeader(data, headerStart);

    // The SIP message has normally finished.
    if(headerEnd === -2) {
      bodyStart = headerStart + 2;
      break;
    }
    // data.indexOf returned -1 due to a malformed message.
    else if(headerEnd === -1) {
      if (sipfrag) {
        // Allowed to not end headers with an empty line, if there is no body
        break;
      } else {
        // Malformed message
        console.warn(LOG_PREFIX +'error parsing message: no empty line terminating headers');
        return;
      }
    }

    parsed = parseHeader(message, data, headerStart, headerEnd);

    if(!parsed) {
      console.warn(LOG_PREFIX +'error parsing header: "' + data.substring(headerStart, headerEnd) + '"');
      return;
    }

    headerStart = headerEnd + 2;
  }

  if (bodyStart) {
    /* RFC3261 18.3.
     * If there are additional bytes in the transport packet
     * beyond the end of the body, they MUST be discarded.
     */
    if(message.hasHeader('content-length')) {
      contentLength = message.getHeader('content-length');
      message.body = data.substr(bodyStart, contentLength);
    } else {
      message.body = data.substring(bodyStart);
    }
  }

  return message;
};

JsSIP.Parser = Parser;
}(JsSIP));



/**
 * @fileoverview SIP Message
 */

(function(JsSIP) {
var
  OutgoingRequest,
  IncomingMessage,
  IncomingRequest,
  IncomingResponse,
  LOG_PREFIX = JsSIP.name +' | '+ 'SIP MESSAGE' +' | ';

/**
 * @augments JsSIP
 * @class Class for outgoing SIP request.
 * @param {String} method request method
 * @param {String} ruri request uri
 * @param {JsSIP.UA} ua
 * @param {Object} params parameters that will have priority over ua.configuration parameters:
 * <br>
 *  - cseq, call_id, from_tag, from_uri, from_display_name, to_uri, to_tag, route_set
 * @param {Object} [headers] extra headers
 * @param {String} [body]
 */
OutgoingRequest = function(method, ruri, ua, params, extraHeaders, body) {
  var
    to,
    from,
    call_id,
    cseq,
    supported;

  params = params || {};

  // Mandatory parameters check
  if(!method || !ruri || !ua) {
    return null;
  }

  this.headers = {};
  this.method = method;
  this.ruri = ruri;
  this.body = body;
  this.extraHeaders = extraHeaders || [];

  // Fill the Common SIP Request Headers

  // Route
  if (params.route_set) {
    this.setHeader('route', params.route_set);
  } else if (ua.configuration.use_preloaded_route){
    this.setHeader('route', ua.transport.server.sip_uri);
  }

  // Via
  // Empty Via header. Will be filled by the client transaction.
  this.setHeader('via', '');

  // Max-Forwards
  this.setHeader('max-forwards', JsSIP.UA.C.MAX_FORWARDS);

  // To
  to = (params.to_display_name || params.to_display_name === 0) ? '"' + params.to_display_name + '" ' : '';
  to += '<' + (params.to_uri || ruri) + '>';
  to += params.to_tag ? ';tag=' + params.to_tag : '';
  this.to = new JsSIP.NameAddrHeader.parse(to);
  this.setHeader('to', to);

  // From
  if (params.from_display_name || params.from_display_name === 0) {
    from = '"' + params.from_display_name + '" ';
  } else if (ua.configuration.display_name) {
    from = '"' + ua.configuration.display_name + '" ';
  } else {
    from = '';
  }
  from += '<' + (params.from_uri || ua.configuration.uri) + '>;tag=';
  from += params.from_tag || JsSIP.Utils.newTag();
  this.from = new JsSIP.NameAddrHeader.parse(from);
  this.setHeader('from', from);

  // Call-ID
  call_id = params.call_id || (ua.configuration.jssip_id + JsSIP.Utils.createRandomToken(15));
  this.call_id = call_id;
  this.setHeader('call-id', call_id);

  // CSeq
  cseq = params.cseq || Math.floor(Math.random() * 10000);
  this.cseq = cseq;
  this.setHeader('cseq', cseq + ' ' + method);

  // Allow
  if (method !== JsSIP.C.CANCEL && method !== JsSIP.C.ACK) {
    this.setHeader('allow', JsSIP.Utils.getAllowedMethods(ua));
  }

  // Supported
  if (method !== JsSIP.C.ACK) {
    supported = JsSIP.Utils.getSupportedExtensions(ua, params.extra_supported);
    this.setHeader('supported', supported.join(','));
  }
};

OutgoingRequest.prototype = {
  /**
   * Replace the the given header by the given value.
   * @param {String} name header name
   * @param {String | Array} value header value
   */
  setHeader: function(name, value) {
    this.headers[JsSIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
  },
  toString: function() {
    var msg = '', header, length, idx;

    msg += this.method + ' ' + this.ruri + ' SIP/2.0\r\n';

    for(header in this.headers) {
      for(idx in this.headers[header]) {
        msg += header + ': ' + this.headers[header][idx] + '\r\n';
      }
    }

    length = this.extraHeaders.length;
    for(idx=0; idx < length; idx++) {
      msg += this.extraHeaders[idx] +'\r\n';
    }

    msg += 'User-Agent: ' + JsSIP.C.USER_AGENT +'\r\n';

    if(this.body) {
      length = JsSIP.Utils.str_utf8_length(this.body);
      msg += 'Content-Length: ' + length + '\r\n\r\n';
      msg += this.body;
    } else {
      msg += 'Content-Length: 0\r\n\r\n';
    }

    return msg;
  }
};

/**
 * @augments JsSIP
 * @class Class for incoming SIP message.
 */
IncomingMessage = function(){
  this.data = null;
  this.headers = null;
  this.method =  null;
  this.via = null;
  this.via_branch = null;
  this.call_id = null;
  this.cseq = null;
  this.from = null;
  this.from_tag = null;
  this.to = null;
  this.to_tag = null;
  this.body = null;
};

IncomingMessage.prototype = {
  /**
  * Insert a header of the given name and value into the last position of the
  * header array.
  * @param {String} name header name
  * @param {String} value header value
  */
  addHeader: function(name, value) {
    var header = { raw: value };

    name = JsSIP.Utils.headerize(name);

    if(this.headers[name]) {
      this.headers[name].push(header);
    } else {
      this.headers[name] = [header];
    }
  },

  /**
   * Count the number of headers of the given header name.
   * @param {String} name header name
   * @returns {Number} Number of headers with the given name
   */
  countHeader: function(name) {
    var header = this.headers[JsSIP.Utils.headerize(name)];

    if(header) {
      return header.length;
    } else {
      return 0;
    }
  },

  /**
   * Get the value of the given header name at the given position.
   * @param {String} name header name
   * @param {Number} [idx=0] header index
   * @returns {String|undefined} Returns the specified header, null if header doesn't exist.
   */
  getHeader: function(name, idx) {
    var header = this.headers[JsSIP.Utils.headerize(name)];

    idx = idx || 0;

    if(header) {
      if(header[idx]) {
        return header[idx].raw;
      }
    } else {
      return;
    }
  },

  /**
   * Get the header/s of the given name.
   * @param {String} name header name
   * @returns {Array} Array with all the headers of the specified name.
   */
  getHeaderAll: function(name) {
    var idx,
      header = this.headers[JsSIP.Utils.headerize(name)],
      result = [];

    if(!header) {
      return [];
    }

    for(idx in header) {
      result.push(header[idx].raw);
    }

    return result;
  },

  /**
   * Verify the existence of the given header.
   * @param {String} name header name
   * @returns {boolean} true if header with given name exists, false otherwise
   */
  hasHeader: function(name) {
    return(this.headers[JsSIP.Utils.headerize(name)]) ? true : false;
  },

  /**
  * Parse the given header on the given index.
  * @param {String} name header name
  * @param {Number} [idx=0] header index
  * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
  */
  parseHeader: function(name, idx) {
    var header, value, parsed;

    name = JsSIP.Utils.headerize(name);

    idx = idx || 0;

    if(!this.headers[name]) {
      console.log(LOG_PREFIX +'header "' + name + '" not present');
      return;
    } else if(idx >= this.headers[name].length) {
      console.log(LOG_PREFIX +'not so many "' + name + '" headers present');
      return;
    }

    header = this.headers[name][idx];
    value = header.raw;

    if(header.parsed) {
      return header.parsed;
    }

    //substitute '-' by '_' for grammar rule matching.
    parsed = JsSIP.Grammar.parse(value, name.replace(/-/g, '_'));

    if(parsed === -1) {
      this.headers[name].splice(idx, 1); //delete from headers
      console.warn(LOG_PREFIX +'error parsing "' + name + '" header field with value "' + value + '"');
      return;
    } else {
      header.parsed = parsed;
      return parsed;
    }
  },

  /**
   * Message Header attribute selector. Alias of parseHeader.
   * @param {String} name header name
   * @param {Number} [idx=0] header index
   * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
   *
   * @example
   * message.s('via',3).port
   */
  s: function(name, idx) {
    return this.parseHeader(name, idx);
  },

  /**
  * Replace the value of the given header by the value.
  * @param {String} name header name
  * @param {String} value header value
  */
  setHeader: function(name, value) {
    var header = { raw: value };
    this.headers[JsSIP.Utils.headerize(name)] = [header];
  },

  toString: function() {
    return this.data;
  }
};

/**
 * @augments IncomingMessage
 * @class Class for incoming SIP request.
 */
IncomingRequest = function() {
  this.headers = {};
  this.ruri = null;
  this.transport = null;
  this.server_transaction = null;
};
IncomingRequest.prototype = new IncomingMessage();

/**
* Stateful reply.
* @param {Number} code status code
* @param {String} reason reason phrase
* @param {Object} headers extra headers
* @param {String} body body
* @param {Function} [onSuccess] onSuccess callback
* @param {Function} [onFailure] onFailure callback
*/
IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {
  var rr, vias, length, idx, response,
    to = this.getHeader('To'),
    r = 0,
    v = 0;

  code = code || null;
  reason = reason || null;

  // Validate code and reason values
  if (!code || (code < 100 || code > 699)) {
    throw new TypeError('Invalid status_code: '+ code);
  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
    throw new TypeError('Invalid reason_phrase: '+ reason);
  }

  reason = reason || JsSIP.C.REASON_PHRASE[code] || '';
  extraHeaders = extraHeaders || [];

  response = 'SIP/2.0 ' + code + ' ' + reason + '\r\n';

  switch (this.method) {
  case JsSIP.C.INVITE:
  case JsSIP.C.REFER:
  case JsSIP.C.SUBSCRIBE:
  case JsSIP.C.NOTIFY:
    if(code > 100 && code <= 200) {
      rr = this.countHeader('record-route');

      for(r; r < rr; r++) {
        response += 'Record-Route: ' + this.getHeader('record-route', r) + '\r\n';
      }
    }
    break;
  }

  vias = this.countHeader('via');

  for(v; v < vias; v++) {
    response += 'Via: ' + this.getHeader('via', v) + '\r\n';
  }

  if(this.to_tag && !this.s('to').hasParam('tag')) {
    to += ';tag=' + this.to_tag;
  }

  response += 'To: ' + to + '\r\n';
  response += 'From: ' + this.getHeader('From') + '\r\n';
  response += 'Call-ID: ' + this.call_id + '\r\n';
  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';

  length = extraHeaders.length;
  for(idx=0; idx < length; idx++) {
    response += extraHeaders[idx] +'\r\n';
  }

  response += 'User-Agent: ' + JsSIP.C.USER_AGENT +'\r\n';

  if(body) {
    length = JsSIP.Utils.str_utf8_length(body);
    response += 'Content-Type: application/sdp\r\n';
    response += 'Content-Length: ' + length + '\r\n\r\n';
    response += body;
  } else {
    response += 'Content-Length: ' + 0 + '\r\n\r\n';
  }

  this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);
};

/**
* Stateless reply.
* @param {Number} code status code
* @param {String} reason reason phrase
*/
IncomingRequest.prototype.reply_sl = function(code, reason) {
  var to, response,
    vias = this.countHeader('via');

  code = code || null;
  reason = reason || null;

  // Validate code and reason values
  if (!code || (code < 100 || code > 699)) {
    throw new TypeError('Invalid status_code: '+ code);
  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
    throw new TypeError('Invalid reason_phrase: '+ reason);
  }

  reason = reason || JsSIP.C.REASON_PHRASE[code] || '';

  response = 'SIP/2.0 ' + code + ' ' + reason + '\r\n';

  for(var v = 0; v < vias; v++) {
    response += 'Via: ' + this.getHeader('via', v) + '\r\n';
  }

  to = this.getHeader('To');

  if(this.to_tag && !this.s('to').hasParam('tag')) {
    to += ';tag=' + this.to_tag;
  }

  response += 'To: ' + to + '\r\n';
  response += 'From: ' + this.getHeader('From') + '\r\n';
  response += 'Call-ID: ' + this.call_id + '\r\n';
  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
  response += 'User-Agent: ' + JsSIP.C.USER_AGENT +'\r\n';
  response += 'Content-Length: ' + 0 + '\r\n\r\n';

  this.transport.send(response);
};


/**
 * @augments IncomingMessage
 * @class Class for incoming SIP response.
 */
IncomingResponse = function() {
  this.headers = {};
  this.status_code = null;
  this.reason_phrase = null;
};
IncomingResponse.prototype = new IncomingMessage();

JsSIP.OutgoingRequest = OutgoingRequest;
JsSIP.IncomingRequest = IncomingRequest;
JsSIP.IncomingResponse = IncomingResponse;
}(JsSIP));



/**
 * @fileoverview SIP URI
 */

/**
 * @augments JsSIP
 * @class Class creating a SIP URI.
 *
 * @param {String} [scheme]
 * @param {String} [user]
 * @param {String} host
 * @param {String} [port]
 * @param {Object} [parameters]
 * @param {Object} [headers]
 *
 */
(function(JsSIP) {
var URI;

URI = function(scheme, user, host, port, parameters, headers) {
  var param, header;

  // Checks
  if(!host) {
    throw new TypeError('missing or invalid "host" parameter');
  }

  // Initialize parameters
  scheme = scheme || JsSIP.C.SIP;
  this.parameters = {};
  this.headers = {};

  for (param in parameters) {
    this.setParam(param, parameters[param]);
  }

  for (header in headers) {
    this.setHeader(header, headers[header]);
  }

  Object.defineProperties(this, {
    scheme: {
      get: function(){ return scheme; },
      set: function(value){
        scheme = value.toLowerCase();
      }
    },

    user: {
      get: function(){ return user; },
      set: function(value){
        user = value;
      }
    },

    host: {
      get: function(){ return host; },
      set: function(value){
        host = value.toLowerCase();
      }
    },

    port: {
      get: function(){ return port; },
      set: function(value){
        port = value === 0 ? value : (parseInt(value,10) || null);
      }
    }
  });
};
URI.prototype = {
  setParam: function(key, value) {
    if(key) {
      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();
    }
  },

  getParam: function(key) {
    if(key) {
      return this.parameters[key.toLowerCase()];
    }
  },

  hasParam: function(key) {
    if(key) {
      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
    }
  },

  deleteParam: function(parameter) {
    var value;
    parameter = parameter.toLowerCase();
    if (this.parameters.hasOwnProperty(parameter)) {
      value = this.parameters[parameter];
      delete this.parameters[parameter];
      return value;
    }
  },

  clearParams: function() {
    this.parameters = {};
  },

  setHeader: function(name, value) {
    this.headers[JsSIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];
  },

  getHeader: function(name) {
    if(name) {
      return this.headers[JsSIP.Utils.headerize(name)];
    }
  },

  hasHeader: function(name) {
    if(name) {
      return (this.headers.hasOwnProperty(JsSIP.Utils.headerize(name)) && true) || false;
    }
  },

  deleteHeader: function(header) {
    var value;
    header = JsSIP.Utils.headerize(header);
    if(this.headers.hasOwnProperty(header)) {
      value = this.headers[header];
      delete this.headers[header];
      return value;
    }
  },

  clearHeaders: function() {
    this.headers = {};
  },

  clone: function() {
    return new URI(
      this.scheme,
      this.user,
      this.host,
      this.port,
      window.JSON.parse(window.JSON.stringify(this.parameters)),
      window.JSON.parse(window.JSON.stringify(this.headers)));
  },

  toString: function(){
    var header, parameter, idx, uri,
      headers = [];

    uri  = this.scheme + ':';
    if (this.user) {
      uri += JsSIP.Utils.escapeUser(this.user) + '@';
    }
    uri += this.host;
    if (this.port || this.port === 0) {
      uri += ':' + this.port;
    }

    for (parameter in this.parameters) {
      uri += ';' + parameter;

      if (this.parameters[parameter] !== null) {
        uri += '='+ this.parameters[parameter];
      }
    }

    for(header in this.headers) {
      for(idx in this.headers[header]) {
        headers.push(header + '=' + this.headers[header][idx]);
      }
    }

    if (headers.length > 0) {
      uri += '?' + headers.join('&');
    }

    return uri;
  },

  toAor: function(show_port){
      var aor;

      aor  = this.scheme + ':';
      if (this.user) {
        aor += JsSIP.Utils.escapeUser(this.user) + '@';
      }
      aor += this.host;
      if (show_port && (this.port || this.port === 0)) {
        aor += ':' + this.port;
      }

      return aor;
  }
};


/**
  * Parse the given string and returns a JsSIP.URI instance or undefined if
  * it is an invalid URI.
  * @public
  * @param {String} uri
  */
URI.parse = function(uri) {
  uri = JsSIP.Grammar.parse(uri,'SIP_URI');

  if (uri !== -1) {
    return uri;
  } else {
    return undefined;
  }
};

JsSIP.URI = URI;
}(JsSIP));



/**
 * @fileoverview JsSIP NameAddrHeader
 */

/**
 * @augments JsSIP
 * @class Class creating a Name Address SIP header.
 *
 * @param {JsSIP.URI} uri
 * @param {String} [display_name]
 * @param {Object} [parameters]
 *
 */
(function(JsSIP) {
var NameAddrHeader;

NameAddrHeader = function(uri, display_name, parameters) {
  var param;

  // Checks
  if(!uri || !(uri instanceof JsSIP.URI)) {
    throw new TypeError('missing or invalid "uri" parameter');
  }

  // Initialize parameters
  this.uri = uri;
  this.parameters = {};

  for (param in parameters) {
    this.setParam(param, parameters[param]);
  }

  Object.defineProperties(this, {
    display_name: {
      get: function() { return display_name; },
      set: function(value) {
        display_name = (value === 0) ? '0' : value;
      }
    }
  });
};
NameAddrHeader.prototype = {
  setParam: function(key, value) {
    if (key) {
      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();
    }
  },

  getParam: function(key) {
    if(key) {
      return this.parameters[key.toLowerCase()];
    }
  },

  hasParam: function(key) {
    if(key) {
      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
    }
  },

  deleteParam: function(parameter) {
    var value;
    parameter = parameter.toLowerCase();
    if (this.parameters.hasOwnProperty(parameter)) {
      value = this.parameters[parameter];
      delete this.parameters[parameter];
      return value;
    }
  },

  clearParams: function() {
    this.parameters = {};
  },

  clone: function() {
    return new NameAddrHeader(
      this.uri.clone(),
      this.display_name,
      window.JSON.parse(window.JSON.stringify(this.parameters)));
  },

  toString: function() {
    var body, parameter;

    body  = (this.display_name || this.display_name === 0) ? '"' + this.display_name + '" ' : '';
    body += '<' + this.uri.toString() + '>';

    for (parameter in this.parameters) {
      body += ';' + parameter;

      if (this.parameters[parameter] !== null) {
        body += '='+ this.parameters[parameter];
      }
    }

    return body;
  }
};


/**
  * Parse the given string and returns a JsSIP.NameAddrHeader instance or undefined if
  * it is an invalid NameAddrHeader.
  * @public
  * @param {String} name_addr_header
  */
NameAddrHeader.parse = function(name_addr_header) {
  name_addr_header = JsSIP.Grammar.parse(name_addr_header,'Name_Addr_Header');

  if (name_addr_header !== -1) {
    return name_addr_header;
  } else {
    return undefined;
  }
};

JsSIP.NameAddrHeader = NameAddrHeader;
}(JsSIP));



/**
 * @fileoverview SIP Transactions
 */

/**
 * SIP Transactions module.
 * @augments JsSIP
 */
(function(JsSIP) {
var Transactions,
  LOG_PREFIX =  JsSIP.name +' | '+ 'TRANSACTION' +' | ',
  C = {
    // Transaction states
    STATUS_TRYING:     1,
    STATUS_PROCEEDING: 2,
    STATUS_CALLING:    3,
    STATUS_ACCEPTED:   4,
    STATUS_COMPLETED:  5,
    STATUS_TERMINATED: 6,
    STATUS_CONFIRMED:  7
  };

Transactions = {};

/**
* @class Client Transaction
* @private
*/
var ClientTransaction = function() {
  this.init = function(request_sender, request, transport) {
    var via;

    this.transport = transport;
    this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
    this.request_sender = request_sender;
    this.request = request;

    via = 'SIP/2.0/' + (request_sender.ua.configuration.hack_via_tcp ? 'TCP' : transport.server.scheme);
    via += ' ' + request_sender.ua.configuration.via_host + ';branch=' + this.id;

    this.request.setHeader('via', via);
  };
};

/**
* @class Non Invite Client Transaction Prototype
* @private
*/
var NonInviteClientTransactionPrototype = function() {
  this.send = function() {
    var tr = this;

    this.state = C.STATUS_TRYING;
    this.F = window.setTimeout(function() {tr.timer_F();}, JsSIP.Timers.TIMER_F);

    if(!this.transport.send(this.request)) {
      this.onTransportError();
    }
  };

  this.onTransportError = function() {
    console.log(LOG_PREFIX +'transport error occurred, deleting non-INVITE client transaction ' + this.id);
    window.clearTimeout(this.F);
    window.clearTimeout(this.K);
    delete this.request_sender.ua.transactions.nict[this.id];

    switch (this.state) {
    case C.STATUS_COMPLETED:
    case C.STATUS_TERMINATED:
      // We already processed a response, so don't need to notify the sender
      return;
    }

    // Notify the sender of the bad news
    this.request_sender.onTransportError();
  };

  this.timer_F = function() {
    console.log(LOG_PREFIX +'Timer F expired for non-INVITE client transaction ' + this.id);
    this.state = C.STATUS_TERMINATED;
    this.request_sender.onRequestTimeout();
    delete this.request_sender.ua.transactions.nict[this.id];
  };

  this.timer_K = function() {
    this.state = C.STATUS_TERMINATED;
    delete this.request_sender.ua.transactions.nict[this.id];
  };

  this.receiveResponse = function(response) {
    var
      tr = this,
      status_code = response.status_code;

    if(status_code < 200) {
      switch(this.state) {
        case C.STATUS_TRYING:
        case C.STATUS_PROCEEDING:
          this.state = C.STATUS_PROCEEDING;
          this.request_sender.receiveResponse(response);
          break;
      }
    } else {
      switch(this.state) {
        case C.STATUS_TRYING:
        case C.STATUS_PROCEEDING:
          this.state = C.STATUS_COMPLETED;
          window.clearTimeout(this.F);

          if(status_code === 408) {
            this.request_sender.onRequestTimeout();
          } else {
            this.request_sender.receiveResponse(response);
          }

          this.K = window.setTimeout(function() {tr.timer_K();}, JsSIP.Timers.TIMER_K);
          break;
        case C.STATUS_COMPLETED:
          break;
      }
    }
  };
};
NonInviteClientTransactionPrototype.prototype = new ClientTransaction();


/**
 * @class Invite Client Transaction Prototype
 * @private
 */
var InviteClientTransactionPrototype = function() {

  this.send = function() {
    var tr = this;
    this.state = C.STATUS_CALLING;
    this.B = window.setTimeout(function() {
      tr.timer_B();
    }, JsSIP.Timers.TIMER_B);

    if(!this.transport.send(this.request)) {
      this.onTransportError();
    }
  };

  this.onTransportError = function() {
    console.log(LOG_PREFIX +'transport error occurred, deleting INVITE client transaction ' + this.id);
    window.clearTimeout(this.B);
    window.clearTimeout(this.D);
    window.clearTimeout(this.M);
    delete this.request_sender.ua.transactions.ict[this.id];

    switch (this.state) {
    case C.STATUS_ACCEPTED:
    case C.STATUS_COMPLETED:
    case C.STATUS_TERMINATED:
      // We already processed a response, so don't need to notify the sender
      return;
    }

    // Notify the sender of the bad news
    this.request_sender.onTransportError();
  };

  // RFC 6026 7.2
  this.timer_M = function() {
  console.log(LOG_PREFIX +'Timer M expired for INVITE client transaction ' + this.id);

  if(this.state === C.STATUS_ACCEPTED) {
    this.state = C.STATUS_TERMINATED;
    window.clearTimeout(this.B);
    delete this.request_sender.ua.transactions.ict[this.id];
  }
  };

  // RFC 3261 17.1.1
  this.timer_B = function() {
  console.log(LOG_PREFIX +'Timer B expired for INVITE client transaction ' + this.id);
  if(this.state === C.STATUS_CALLING) {
    this.state = C.STATUS_TERMINATED;
    this.request_sender.onRequestTimeout();
    delete this.request_sender.ua.transactions.ict[this.id];
  }
  };

  this.timer_D = function() {
    console.log(LOG_PREFIX +'Timer D expired for INVITE client transaction ' + this.id);
    this.state = C.STATUS_TERMINATED;
    window.clearTimeout(this.B);
    delete this.request_sender.ua.transactions.ict[this.id];
  };

  this.sendACK = function(response) {
    var tr = this;

    this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\r\n';
    this.ack += 'Via: ' + this.request.headers['Via'].toString() + '\r\n';

    if(this.request.headers['Route']) {
      this.ack += 'Route: ' + this.request.headers['Route'].toString() + '\r\n';
    }

    this.ack += 'To: ' + response.getHeader('to') + '\r\n';
    this.ack += 'From: ' + this.request.headers['From'].toString() + '\r\n';
    this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\r\n';
    this.ack += 'CSeq: ' + this.request.headers['CSeq'].toString().split(' ')[0];
    this.ack += ' ACK\r\n\r\n';

    this.D = window.setTimeout(function() {tr.timer_D();}, JsSIP.Timers.TIMER_D);

    this.transport.send(this.ack);
  };

  this.cancel_request = function(tr, reason) {
    var request = tr.request;

    this.cancel = JsSIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\r\n';
    this.cancel += 'Via: ' + request.headers['Via'].toString() + '\r\n';

    if(this.request.headers['Route']) {
      this.cancel += 'Route: ' + request.headers['Route'].toString() + '\r\n';
    }

    this.cancel += 'To: ' + request.headers['To'].toString() + '\r\n';
    this.cancel += 'From: ' + request.headers['From'].toString() + '\r\n';
    this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\r\n';
    this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +
    ' CANCEL\r\n';

    if(reason) {
      this.cancel += 'Reason: ' + reason + '\r\n';
    }

    this.cancel += 'Content-Length: 0\r\n\r\n';

    // Send only if a provisional response (>100) has been received.
    if(this.state === C.STATUS_PROCEEDING) {
      this.transport.send(this.cancel);
    }
  };

  this.receiveResponse = function(response) {
    var
      tr = this,
      status_code = response.status_code;

    if(status_code >= 100 && status_code <= 199) {
      switch(this.state) {
        case C.STATUS_CALLING:
          this.state = C.STATUS_PROCEEDING;
          this.request_sender.receiveResponse(response);
          if(this.cancel) {
            this.transport.send(this.cancel);
          }
          break;
        case C.STATUS_PROCEEDING:
          this.request_sender.receiveResponse(response);
          break;
      }
    } else if(status_code >= 200 && status_code <= 299) {
      switch(this.state) {
        case C.STATUS_CALLING:
        case C.STATUS_PROCEEDING:
          this.state = C.STATUS_ACCEPTED;
          this.M = window.setTimeout(function() {
            tr.timer_M();
          }, JsSIP.Timers.TIMER_M);
          this.request_sender.receiveResponse(response);
          break;
        case C.STATUS_ACCEPTED:
          this.request_sender.receiveResponse(response);
          break;
      }
    } else if(status_code >= 300 && status_code <= 699) {
      switch(this.state) {
        case C.STATUS_CALLING:
        case C.STATUS_PROCEEDING:
          this.state = C.STATUS_COMPLETED;
          this.sendACK(response);
          this.request_sender.receiveResponse(response);
          break;
        case C.STATUS_COMPLETED:
          this.sendACK(response);
          break;
      }
    }
  };
};
InviteClientTransactionPrototype.prototype = new ClientTransaction();

/**
 * @class Server Transaction
 * @private
 */
var ServerTransaction = function() {
  this.init = function(request, ua) {
    this.id = request.via_branch;
    this.request = request;
    this.transport = request.transport;
    this.ua = ua;
    this.last_response = '';
    request.server_transaction = this;
  };
};

/**
 * @class Non Invite Server Transaction Prototype
 * @private
 */
var NonInviteServerTransactionPrototype = function() {
  this.timer_J = function() {
    console.log(LOG_PREFIX +'Timer J expired for non-INVITE server transaction ' + this.id);
    this.state = C.STATUS_TERMINATED;
    delete this.ua.transactions.nist[this.id];
  };

  this.onTransportError = function() {
    if (!this.transportError) {
      this.transportError = true;

      console.log(LOG_PREFIX +'transport error occurred, deleting non-INVITE server transaction ' + this.id);

      window.clearTimeout(this.J);
      delete this.ua.transactions.nist[this.id];
    }
  };

  this.receiveResponse = function(status_code, response, onSuccess, onFailure) {
    var tr = this;

    if(status_code === 100) {
      /* RFC 4320 4.1
       * 'A SIP element MUST NOT
       * send any provisional response with a
       * Status-Code other than 100 to a non-INVITE request.'
       */
      switch(this.state) {
        case C.STATUS_TRYING:
          this.state = C.STATUS_PROCEEDING;
          if(!this.transport.send(response))  {
            this.onTransportError();
          }
          break;
        case C.STATUS_PROCEEDING:
          this.last_response = response;
          if(!this.transport.send(response)) {
            this.onTransportError();
            if (onFailure) {
              onFailure();
            }
          } else if (onSuccess) {
            onSuccess();
          }
          break;
      }
    } else if(status_code >= 200 && status_code <= 699) {
      switch(this.state) {
        case C.STATUS_TRYING:
        case C.STATUS_PROCEEDING:
          this.state = C.STATUS_COMPLETED;
          this.last_response = response;
          this.J = window.setTimeout(function() {
            tr.timer_J();
          }, JsSIP.Timers.TIMER_J);
          if(!this.transport.send(response)) {
            this.onTransportError();
            if (onFailure) {
              onFailure();
            }
          } else if (onSuccess) {
            onSuccess();
          }
          break;
        case C.STATUS_COMPLETED:
          break;
      }
    }
  };
};
NonInviteServerTransactionPrototype.prototype = new ServerTransaction();

/**
 * @class Invite Server Transaction Prototype
 * @private
 */
var InviteServerTransactionPrototype = function() {
  this.timer_H = function() {
    console.log(LOG_PREFIX +'Timer H expired for INVITE server transaction ' + this.id);

    if(this.state === C.STATUS_COMPLETED) {
      console.warn(LOG_PREFIX +'transactions', 'ACK for INVITE server transaction was never received, call will be terminated');
      this.state = C.STATUS_TERMINATED;
    }

    delete this.ua.transactions.ist[this.id];
  };

  this.timer_I = function() {
    this.state = C.STATUS_TERMINATED;
    delete this.ua.transactions.ist[this.id];
  };

  // RFC 6026 7.1
  this.timer_L = function() {
  console.log(LOG_PREFIX +'Timer L expired for INVITE server transaction ' + this.id);

  if(this.state === C.STATUS_ACCEPTED) {
    this.state = C.STATUS_TERMINATED;
    delete this.ua.transactions.ist[this.id];
  }
  };

  this.onTransportError = function() {
    if (!this.transportError) {
      this.transportError = true;

      console.log(LOG_PREFIX +'transport error occurred, deleting INVITE server transaction ' + this.id);

      window.clearInterval(this.resendProvisionalTimer);
      window.clearTimeout(this.L);
      window.clearTimeout(this.H);
      window.clearTimeout(this.I);
      delete this.ua.transactions.ist[this.id];
    }
  };

  this.resend_provisional = function() {
    if(!this.transport.send(this.last_response)) {
      this.onTransportError();
    }
  };

  // INVITE Server Transaction RFC 3261 17.2.1
  this.receiveResponse = function(status_code, response, onSuccess, onFailure) {
    var tr = this;

    if(status_code >= 100 && status_code <= 199) {
      switch(this.state) {
        case C.STATUS_PROCEEDING:
          if(!this.transport.send(response)) {
            this.onTransportError();
          }
          this.last_response = response;
          break;
      }
    }

    if(status_code > 100 && status_code <= 199) {
      // Trigger the reliableProvisionalTimer only for the first non 100 provisional response.
      if(!this.resendProvisionalTimer) {
        this.resendProvisionalTimer = window.setInterval(function() {
          tr.resend_provisional();}, JsSIP.Timers.T1 * 60);
      }
    } else if(status_code >= 200 && status_code <= 299) {
      switch(this.state) {
        case C.STATUS_PROCEEDING:
          this.state = C.STATUS_ACCEPTED;
          this.last_response = response;
          this.L = window.setTimeout(function() {
            tr.timer_L();
          }, JsSIP.Timers.TIMER_L);
          window.clearInterval(this.resendProvisionalTimer);
          /* falls through */
        case C.STATUS_ACCEPTED:
          // Note that this point will be reached for proceeding tr.state also.
          if(!this.transport.send(response)) {
            this.onTransportError();
            if (onFailure) {
              onFailure();
            }
          } else if (onSuccess) {
            onSuccess();
          }
          break;
      }
    } else if(status_code >= 300 && status_code <= 699) {
      switch(this.state) {
        case C.STATUS_PROCEEDING:
          window.clearInterval(this.resendProvisionalTimer);
          if(!this.transport.send(response)) {
            this.onTransportError();
            if (onFailure) {
              onFailure();
            }
          } else {
            this.state = C.STATUS_COMPLETED;
            this.H = window.setTimeout(function() {
              tr.timer_H();
            }, JsSIP.Timers.TIMER_H);
            if (onSuccess) {
              onSuccess();
            }
          }
          break;
      }
    }
  };
};
InviteServerTransactionPrototype.prototype = new ServerTransaction();

/**
* @augments JsSIP.Transactions
* @class Non Invite Client Transaction
* @param {JsSIP.RequestSender} request_sender
* @param {JsSIP.OutgoingRequest} request
* @param {JsSIP.Transport} transport
*/
Transactions.NonInviteClientTransaction = function(request_sender, request, transport) {
  this.init(request_sender, request, transport);
  this.request_sender.ua.transactions.nict[this.id] = this;
};
Transactions.NonInviteClientTransaction.prototype = new NonInviteClientTransactionPrototype();

/**
* @augments JsSIP.Transactions
* @class Invite Client Transaction
* @param {JsSIP.RequestSender} request_sender
* @param {JsSIP.OutgoingRequest} request
* @param {JsSIP.Transport} transport
*/
Transactions.InviteClientTransaction = function(request_sender, request, transport) {
  var tr = this;

  this.init(request_sender, request, transport);
  this.request_sender.ua.transactions.ict[this.id] = this;

  // Add the cancel property to the request.
  //Will be called from the request instance, not the transaction itself.
  this.request.cancel = function(reason) {
    tr.cancel_request(tr, reason);
  };
};
Transactions.InviteClientTransaction.prototype = new InviteClientTransactionPrototype();

Transactions.AckClientTransaction = function(request_sender, request, transport) {
  this.init(request_sender, request, transport);
  this.send = function() {
    this.transport.send(request);
  };
};
Transactions.AckClientTransaction.prototype = new NonInviteClientTransactionPrototype();


/**
* @augments JsSIP.Transactions
* @class Non Invite Server Transaction
* @param {JsSIP.IncomingRequest} request
* @param {JsSIP.UA} ua
*/
Transactions.NonInviteServerTransaction = function(request, ua) {
  this.init(request, ua);
  this.state = C.STATUS_TRYING;

  ua.transactions.nist[this.id] = this;
};
Transactions.NonInviteServerTransaction.prototype = new NonInviteServerTransactionPrototype();



/**
* @augments JsSIP.Transactions
* @class Invite Server Transaction
* @param {JsSIP.IncomingRequest} request
* @param {JsSIP.UA} ua
*/
Transactions.InviteServerTransaction = function(request, ua) {
  this.init(request, ua);
  this.state = C.STATUS_PROCEEDING;

  ua.transactions.ist[this.id] = this;

  this.resendProvisionalTimer = null;

  request.reply(100);
};
Transactions.InviteServerTransaction.prototype = new InviteServerTransactionPrototype();

/**
 * @function
 * @param {JsSIP.UA} ua
 * @param {JsSIP.IncomingRequest} request
 *
 * @return {boolean}
 * INVITE:
 *  _true_ if retransmission
 *  _false_ new request
 *
 * ACK:
 *  _true_  ACK to non2xx response
 *  _false_ ACK must be passed to TU (accepted state)
 *          ACK to 2xx response
 *
 * CANCEL:
 *  _true_  no matching invite transaction
 *  _false_ matching invite transaction and no final response sent
 *
 * OTHER:
 *  _true_  retransmission
 *  _false_ new request
 */
Transactions.checkTransaction = function(ua, request) {
  var tr;

  switch(request.method) {
    case JsSIP.C.INVITE:
      tr = ua.transactions.ist[request.via_branch];
      if(tr) {
        switch(tr.state) {
          case C.STATUS_PROCEEDING:
            tr.transport.send(tr.last_response);
            break;

            // RFC 6026 7.1 Invite retransmission
            //received while in C.STATUS_ACCEPTED state. Absorb it.
          case C.STATUS_ACCEPTED:
            break;
        }
        return true;
      }
      break;
    case JsSIP.C.ACK:
      tr = ua.transactions.ist[request.via_branch];

      // RFC 6026 7.1
      if(tr) {
        if(tr.state === C.STATUS_ACCEPTED) {
          return false;
        } else if(tr.state === C.STATUS_COMPLETED) {
          tr.state = C.STATUS_CONFIRMED;
          tr.I = window.setTimeout(function() {tr.timer_I();}, JsSIP.Timers.TIMER_I);
          return true;
        }
      }

      // ACK to 2XX Response.
      else {
        return false;
      }
      break;
    case JsSIP.C.CANCEL:
      tr = ua.transactions.ist[request.via_branch];
      if(tr) {
        if(tr.state === C.STATUS_PROCEEDING) {
          return false;
        } else {
          request.reply_sl(481);
          return true;
        }
      } else {
        request.reply_sl(481);
        return true;
      }
      break;
    default:

      // Non-INVITE Server Transaction RFC 3261 17.2.2
      tr = ua.transactions.nist[request.via_branch];
      if(tr) {
        switch(tr.state) {
          case C.STATUS_TRYING:
            break;
          case C.STATUS_PROCEEDING:
          case C.STATUS_COMPLETED:
            tr.transport.send(tr.last_response);
            break;
        }
        return true;
      }
      break;
  }
};

Transactions.C = C;
JsSIP.Transactions = Transactions;
}(JsSIP));



/**
 * @fileoverview SIP Dialog
 */

/**
 * @augments JsSIP
 * @class Class creating a SIP dialog.
 * @param {JsSIP.Session} session
 * @param {JsSIP.IncomingRequest|JsSIP.IncomingResponse} message
 * @param {Enum} type UAC / UAS
 * @param {Enum} state JsSIP.Dialog.C.STATUS_EARLY / JsSIP.Dialog.C.STATUS_CONFIRMED
 */
(function(JsSIP) {
var DialogId, Dialog,
  LOG_PREFIX = JsSIP.name +' | '+ 'DIALOG' +' | ',
  C = {
    // Dialog states
    STATUS_EARLY:       1,
    STATUS_CONFIRMED:   2,

    DEFAULT_MIN_SE: 90
  };

DialogId = function (call_id, local_tag, remote_tag) {
  this.call_id = call_id;
  this.local_tag = local_tag;
  this.remote_tag = remote_tag;
};
DialogId.prototype.toString = function () {
  return this.call_id + this.local_tag + this.remote_tag;
};
DialogId.prototype.toTargetDialogHeader = function () {
  // See RFC 4538
  // Note: the remote/local labels are from the perspective of the recipient
  return this.call_id +
      ';remote-tag=' + this.local_tag +
      ';local-tag=' + this.remote_tag;
};

// RFC 3261 12.1
Dialog = function(owner, message, type, state) {
  var contact;

  if(!message.hasHeader('contact')) {
    console.error(LOG_PREFIX +'unable to create a Dialog without Contact header field');
    return false;
  }

  if(message instanceof JsSIP.IncomingResponse) {
    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;
  } else {
    // Create confirmed dialog if state is not defined
    state = state || C.STATUS_CONFIRMED;
    if (message.method === JsSIP.C.INVITE) {
      this.last_invite_tx = message.server_transaction;
    }
  }

  contact = message.parseHeader('contact');

  // RFC 3261 12.1.1
  if(type === 'UAS') {
    this.id = new DialogId(message.call_id, message.to_tag, message.from_tag);
    this.state = state;
    this.remote_seqnum = message.cseq;
    this.local_uri = message.parseHeader('to').uri;
    this.remote_uri = message.parseHeader('from').uri;
    this.remote_target = contact.uri;
    this.route_set = message.getHeaderAll('record-route');
  }
  // RFC 3261 12.1.2
  else if(type === 'UAC') {
    this.id = new DialogId(message.call_id, message.from_tag, message.to_tag);
    this.state = state;
    this.local_seqnum = message.cseq;
    this.local_uri = message.parseHeader('from').uri;
    this.remote_uri = message.parseHeader('to').uri;
    this.remote_target = contact.uri;
    this.route_set = message.getHeaderAll('record-route').reverse();
  }

  // Session timer state (RFC 4028)
  this.session_timer = {
      localRefresher: true,
      interval: null,
      min_interval: C.DEFAULT_MIN_SE,
      timer_id: null
  };

  this.owner = owner;
  owner.ua.dialogs[this.id.toString()] = this;
  console.log(LOG_PREFIX +'new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));
};

Dialog.prototype = {
  /**
   * @param {JsSIP.IncomingMessage} message
   * @param {Enum} UAC/UAS
   */
  update: function(message, type) {
    this.state = C.STATUS_CONFIRMED;

    console.log(LOG_PREFIX +'dialog '+ this.id.toString() +'  changed to CONFIRMED state');

    if(type === 'UAC') {
      // RFC 3261 13.2.2.4
      this.route_set = message.getHeaderAll('record-route').reverse();
    }
  },

  isConfirmed: function() {
    return this.state === C.STATUS_CONFIRMED;
  },

  terminate: function() {
    console.log(LOG_PREFIX +'dialog ' + this.id.toString() + ' deleted');
    this.clearSessionRefreshTimer();
    delete this.owner.ua.dialogs[this.id.toString()];
  },

  /**
  * @param {String} method request method
  * @param {Object} extraHeaders extra headers
  * @returns {JsSIP.OutgoingRequest}
  */

  // RFC 3261 12.2.1.1
  createRequest: function(method, extraHeaders) {
    var cseq, request,
      extra_supported = null;
    extraHeaders = extraHeaders || [];

    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }

    cseq = (method === JsSIP.C.CANCEL || method === JsSIP.C.ACK) ? this.local_seqnum : this.local_seqnum += 1;

    // Add Session Timer headers (RFC 4028)
    if (method === JsSIP.C.INVITE || method === JsSIP.C.UPDATE) {
      var min_se = this.session_timer.min_interval;
      var interval = this.session_timer.interval;

      if (min_se > C.DEFAULT_MIN_SE) {
        extraHeaders.push('Min-SE: ' + min_se);
      }

      if (interval !== null) {
        var expires = min_se > interval ? min_se : interval;
        var refresher = this.session_timer.localRefresher ? 'uac' : 'uas';
        extraHeaders.push('Session-Expires: ' + expires + ';refresher=' + refresher);
      }
    }

    if (this.owner instanceof JsSIP.RTCSession) {
      extra_supported = JsSIP.Utils.getSessionExtensions(this.owner, method);
    }

    request = new JsSIP.OutgoingRequest(
      method,
      this.remote_target,
      this.owner.ua, {
        'cseq': cseq,
        'call_id': this.id.call_id,
        'from_uri': this.local_uri,
        'from_tag': this.id.local_tag,
        'to_uri': this.remote_uri,
        'to_tag': this.id.remote_tag,
        'route_set': this.route_set,
        'extra_supported': extra_supported
      }, extraHeaders);

    request.dialog = this;

    return request;
  },

  /**
  * @param {JsSIP.IncomingRequest} request
  * @returns {Boolean}
  */

  // RFC 3261 12.2.2
  checkInDialogRequest: function(request) {
    var retryAfter;

    if(!this.remote_seqnum) {
      this.remote_seqnum = request.cseq;
    } else if(request.cseq < this.remote_seqnum) {
        //Do not try to reply to an ACK request.
        if (request.method !== JsSIP.C.ACK) {
          request.reply(500);
        }
        return false;
    } else if(request.cseq > this.remote_seqnum) {
      this.remote_seqnum = request.cseq;
    }

    switch(request.method) {
      case JsSIP.C.INVITE:
        // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-
        if(this.last_invite_tx &&
            this.last_invite_tx.state === JsSIP.Transactions.C.STATUS_PROCEEDING) {
          retryAfter = (Math.random() * 10 | 0) + 1;
          request.reply(500, null, ['Retry-After:'+ retryAfter]);
          return false;
        }
        // Cache the transaction to check next time
        this.last_invite_tx = request.server_transaction;
        break;
      case JsSIP.C.UPDATE:
        // RFC3311 5.2
        if(this.last_update_tx) {
          switch(this.last_update_tx.state) {
          case JsSIP.Transactions.C.STATUS_TRYING:
          case JsSIP.Transactions.C.STATUS_PROCEEDING:
            // We have not yet responded to the previous UPDATE
            retryAfter = (Math.random() * 10 | 0) + 1;
            request.reply(500, null, ['Retry-After:'+ retryAfter]);
            return false;
          default:
            break;
          }
        }
        // Cache this UPDATE transaction to check next time
        this.last_update_tx = request.server_transaction;
        break;
    }

    return true;
  },

  /**
  * @param {JsSIP.IncomingRequest} request
  */
  receiveRequest: function(request) {
    //Check in-dialog request
    if(!this.checkInDialogRequest(request)) {
      return;
    }

    if(!this.owner.receiveRequest(request)) {
      return;
    }

    // The request was accepted, so now check for target refresh
    switch(request.method) {
      case JsSIP.C.INVITE:    // RFC3261 12.2.2
      case JsSIP.C.UPDATE:    // RFC3311 5.2
      case JsSIP.C.NOTIFY:    // RFC6655 3.2
        if(request.hasHeader('contact')) {
          this.remote_target = request.parseHeader('contact').uri;
        }
        break;
    }
  },

  updateMinSessionExpires: function (interval) {
    if (interval > this.session_timer.min_interval) {
      this.session_timer.min_interval = interval;
    }
  },

  /**
   * Configures the appropriate session timer timeout and behaviour, based
   * on the provided session expires interval and whether the local endpoint
   * is responsible for refreshes.
   * @param {Number} interval The session expires interval (in seconds).
   * @param {Boolean} localRefresher
   */
  setSessionRefreshTimer: function () {
    var localRefresher = this.session_timer.localRefresher;
    var interval = this.session_timer.interval;
    var timeout;
    var action;
    var self = this;

    if (localRefresher) {
      timeout = interval / 2;
      action = function () {
        self.session_timer.timer_id = null;
        self.owner.emit('refresh', self.owner, {});
      };
    } else {
      timeout = interval - Math.max(interval / 3, 32);
      action = function () {
        self.session_timer.timer_id = null;
        self.owner.sendBye({
          status_code: 408,
          reason_phrase: JsSIP.C.causes.SESSION_TIMER
        });
        self.owner.ended('system', null, JsSIP.C.causes.SESSION_TIMER);
      };
    }

    this.session_timer.timer_id = window.setTimeout(action, timeout * 1000);
  },

  clearSessionRefreshTimer: function () {
    if (this.session_timer.timer_id !== null) {
      window.clearTimeout(this.session_timer.timer_id);
      this.session_timer.timer_id = null;
    }
  },

  disableSessionRefresh: function () {
    this.session_timer.interval = null;
    this.clearSessionRefreshTimer();
  },

  /**
   * Should only be called when we receive, or are about to send, a 2xx response
   * to a method that acts as a session refresher (currently INVITE and UPDATE).
   * @param message The received message (may be request or response)
   */
  processSessionTimerHeaders: function (message) {
    if (message.hasHeader('min-se')) {
      this.updateMinSessionExpires(message.parseHeader('min-se'));
    }

    if (!message.hasHeader('session-expires')) {
      this.disableSessionRefresh();
      return;
    }

    this.clearSessionRefreshTimer();

    var se = message.parseHeader('session-expires');
    var localRefresher = true;

    if (message instanceof JsSIP.IncomingRequest) {
      // Session timer requested
      // Refresher parameter is optional at this stage
      if (se.params && se.params.refresher) {
        localRefresher = se.params.refresher === 'uas';
      }
    } else if (message instanceof JsSIP.IncomingResponse) {
      // Session timer enabled
      // Refresher parameter is required at this stage
      localRefresher = se.params.refresher === 'uac';
    } else {
      throw new TypeError('Unexpected message type');
    }

    this.session_timer.interval = se.interval;
    this.session_timer.localRefresher = localRefresher;

    this.setSessionRefreshTimer();
  },

  /**
   * Adds the Session-Expires header to the provided extra headers array.
   * Should only be used for a 2xx response to a method that acts as a session
   * refresher (currently INVITE and UPDATE).
   * @param extraHeaders
   */
  addSessionTimerResponseHeaders: function (extraHeaders) {
    var interval = this.session_timer.interval;
    if (interval) {
      var refresher = this.session_timer.localRefresher ? 'uas' : 'uac';
      extraHeaders.push('Session-Expires: ' + interval + ';refresher=' + refresher);
    }
  }
};

Dialog.C = C;
JsSIP.DialogId = DialogId;
JsSIP.Dialog = Dialog;
}(JsSIP));




/**
 * @fileoverview Request Sender
 */

/**
 * @augments JsSIP
 * @class Class creating a request sender.
 * @param {Object} applicant
 * @param {JsSIP.UA} ua
 */
(function(JsSIP) {
var RequestSender,
  LOG_PREFIX = JsSIP.name +' | '+ 'REQUEST SENDER' +' | ';

RequestSender = function(applicant, ua) {
  this.ua = ua;
  this.applicant = applicant;
  this.method = applicant.request.method;
  this.request = applicant.request;
  this.credentials = null;
  this.challenged = false;
  this.staled = false;

  // If ua is in closing process or even closed just allow sending Bye and ACK
  if (ua.status === JsSIP.UA.C.STATUS_USER_CLOSED && (this.method !== JsSIP.C.BYE || this.method !== JsSIP.C.ACK)) {
    this.onTransportError();
  }
};

/**
* Create the client transaction and send the message.
*/
RequestSender.prototype = {
  send: function() {
    switch(this.method) {
      case "INVITE":
        this.clientTransaction = new JsSIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);
        break;
      case "ACK":
        this.clientTransaction = new JsSIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);
        break;
      default:
        this.clientTransaction = new JsSIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);
    }
    this.clientTransaction.send();
  },

  /**
  * Callback fired when receiving a request timeout error from the client transaction.
  * To be re-defined by the applicant.
  * @event
  */
  onRequestTimeout: function() {
    this.applicant.onRequestTimeout();
  },

  /**
  * Callback fired when receiving a transport error from the client transaction.
  * To be re-defined by the applicant.
  * @event
  */
  onTransportError: function() {
    this.applicant.onTransportError();
  },

  /**
  * Called from client transaction when receiving a correct response to the request.
  * Authenticate request if needed or pass the response back to the applicant.
  * @param {JsSIP.IncomingResponse} response
  */
  receiveResponse: function(response) {
    var cseq, challenge, authorization_header_name,
      status_code = response.status_code;

    /*
    * Authentication
    * Authenticate once. _challenged_ flag used to avoid infinite authentications.
    */
    if ((status_code === 401 || status_code === 407) && this.ua.configuration.password !== null) {

      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
      if (response.status_code === 401) {
        challenge = response.parseHeader('www-authenticate');
        authorization_header_name = 'authorization';
      } else {
        challenge = response.parseHeader('proxy-authenticate');
        authorization_header_name = 'proxy-authorization';
      }

      // Verify it seems a valid challenge.
      if (! challenge) {
        console.warn(LOG_PREFIX + response.status_code + ' with wrong or missing challenge, cannot authenticate');
        this.applicant.receiveResponse(response);
        return;
      }

      if (!this.challenged || (!this.staled && challenge.stale === true)) {
        if (!this.credentials) {
          this.credentials = new JsSIP.DigestAuthentication(this.ua);
        }

        // Verify that the challenge is really valid.
        if (!this.credentials.authenticate(this.request, challenge)) {
          this.applicant.receiveResponse(response);
          return;
        }
        this.challenged = true;

        if (challenge.stale) {
          this.staled = true;
        }

        if (response.method === JsSIP.C.REGISTER) {
          cseq = this.applicant.cseq += 1;
        } else if (this.request.dialog){
          cseq = this.request.dialog.local_seqnum += 1;
        } else {
          cseq = this.request.cseq + 1;
          this.request.cseq = cseq;
        }
        this.request.setHeader('cseq', cseq +' '+ this.method);

        this.request.setHeader(authorization_header_name, this.credentials.toString());
        this.send();
      } else {
        this.applicant.receiveResponse(response);
      }
    } else {
      this.applicant.receiveResponse(response);
    }
  }
};

JsSIP.RequestSender = RequestSender;
}(JsSIP));



/**
 * @fileoverview In-Dialog Request Sender
 */

/**
 * @augments JsSIP
 * @class Class creating an In-dialog request sender.
 * @param {Object} applicant
 */
/**
 * @fileoverview in-Dialog Request Sender
 */

(function(JsSIP) {
var InDialogRequestSender;

InDialogRequestSender = function(applicant) {
  this.applicant = applicant;
  this.request = applicant.request;
};

InDialogRequestSender.prototype = {
  send: function() {
    var request_sender = new JsSIP.RequestSender(this, this.applicant.session.ua);
    request_sender.send();
  },

  onRequestTimeout: function() {
    this.applicant.session.onRequestTimeout();
    this.applicant.onRequestTimeout();
  },

  onTransportError: function() {
    this.applicant.session.onTransportError();
    this.applicant.onTransportError();
  },

  receiveResponse: function(response) {
    // RFC3261 14.1. Terminate the dialog if a 408 or 481 is received from a re-Invite.
    if (response.status_code === 408 || response.status_code === 481) {
      if (this.request.method !== JsSIP.C.BYE) {
        // Send a BYE as per section 12.2.1.2.
        this.applicant.session.sendBye({
          status_code: response.status_code,
          reason_phrase: response.reason_phrase
        });
      }
      this.applicant.session.ended('remote', response, JsSIP.C.causes.DIALOG_ERROR);
    }
    this.applicant.receiveResponse(response);
  }
};

JsSIP.InDialogRequestSender = InDialogRequestSender;
}(JsSIP));



/**
 * @fileoverview Registrator Agent
 */

/**
 * @augments JsSIP
 * @class Class creating a registrator agent.
 * @param {JsSIP.UA} ua
 * @param {JsSIP.Transport} transport
 */
(function(JsSIP) {
var Registrator,
  LOG_PREFIX = JsSIP.name +' | '+ 'REGISTRATOR' +' | ';

Registrator = function(ua, transport) {
  var reg_id=1; //Force reg_id to 1.

  this.ua = ua;
  this.transport = transport;

  this.registrar = ua.configuration.registrar_server;
  this.expires = ua.configuration.register_expires;

  // Call-ID and CSeq values RFC3261 10.2
  this.call_id = JsSIP.Utils.createRandomToken(22);
  this.cseq = 80;

  // this.to_uri
  this.to_uri = ua.configuration.uri;

  this.registrationTimer = null;

  // Set status
  this.registered = this.registered_before = false;

  // Save into ua instance
  this.ua.registrator = this;

  // Contact header
  this.contact = this.ua.contact.toString();

  if(reg_id) {
    this.contact += ';reg-id='+ reg_id;
    this.contact += ';+sip.instance="<urn:'+ this.ua.configuration.instance_id+'>"';
  }
};

Registrator.prototype = {
  /**
   * @param {Object} [options]
   */
  register: function(options) {
    var request_sender, cause, extraHeaders,
      self = this;

    options = options || {};
    extraHeaders = options.extraHeaders || [];
    extraHeaders.push('Contact: '+ this.contact + ';expires=' + this.expires);

    this.request = new JsSIP.OutgoingRequest(JsSIP.C.REGISTER, this.registrar, this.ua, {
        'to_uri': this.to_uri,
        'call_id': this.call_id,
        'cseq': (this.cseq += 1)
      }, extraHeaders);

    request_sender = new JsSIP.RequestSender(this, this.ua);

    /**
    * @private
    */
    this.receiveResponse = function(response) {
      var contact, expires,
        contacts = response.countHeader('contact');

      // Discard responses to older REGISTER/un-REGISTER requests.
      if(response.cseq !== this.cseq) {
        return;
      }

      switch(true) {
        case /^1[0-9]{2}$/.test(response.status_code):
          // Ignore provisional responses.
          break;
        case /^2[0-9]{2}$/.test(response.status_code):
          if(response.hasHeader('expires')) {
            expires = response.getHeader('expires');
          }

          // Search the Contact pointing to us and update the expires value accordingly.
          if (!contacts) {
            console.warn(LOG_PREFIX +'no Contact header in response to REGISTER, response ignored');
            break;
          }

          while(contacts--) {
            contact = response.parseHeader('contact', contacts);
            if(contact.uri.user === this.ua.contact.uri.user) {
              expires = contact.getParam('expires');
              break;
            } else {
              contact = null;
            }
          }

          if (!contact) {
            console.warn(LOG_PREFIX +'no Contact header pointing to us, response ignored');
            break;
          }

          if(!expires) {
            expires = this.expires;
          }

          // Re-Register before the expiration interval has elapsed.
          // For that, decrease the expires value. ie: 3 seconds
          this.registrationTimer = window.setTimeout(function() {
            self.register();
          }, (expires * 1000) - 3000);

          //Save gruu values
          if (contact.hasParam('temp-gruu')) {
            this.ua.contact.temp_gruu = contact.getParam('temp-gruu').replace(/"/g,'');
          }
          if (contact.hasParam('pub-gruu')) {
            this.ua.contact.pub_gruu = contact.getParam('pub-gruu').replace(/"/g,'');
          }

          this.registered = true;
          this.ua.emit('registered', this.ua, {
            response: response
          });
          break;
        // Interval too brief RFC3261 10.2.8
        case /^423$/.test(response.status_code):
          if(response.hasHeader('min-expires')) {
            // Increase our registration interval to the suggested minimum
            this.expires = response.getHeader('min-expires');
            // Attempt the registration again immediately 
            this.registrationTimer = window.setTimeout(function() {
              self.register();
            }, 0);
          } else { //This response MUST contain a Min-Expires header field
            console.warn(LOG_PREFIX +'423 response received for REGISTER without Min-Expires');
            this.registrationFailure(response, JsSIP.C.causes.SIP_FAILURE_CODE);
          }
          break;
        default:
          cause = JsSIP.Utils.sipErrorCause(response.status_code);
          this.registrationFailure(response, cause);
      }
    };

    /**
    * @private
    */
    this.onRequestTimeout = function() {
      this.registrationFailure(null, JsSIP.C.causes.REQUEST_TIMEOUT);
    };

    /**
    * @private
    */
    this.onTransportError = function() {
      this.registrationFailure(null, JsSIP.C.causes.CONNECTION_ERROR);
    };

    request_sender.send();
  },

  /**
  * @param {Object} [options]
  */
  unregister: function(options) {
    var extraHeaders;

    if(!this.registered) {
      console.warn(LOG_PREFIX +'already unregistered');
      return;
    }

    options = options || {};
    extraHeaders = options.extraHeaders || [];

    this.registered = false;

    // Clear the registration timer.
    window.clearTimeout(this.registrationTimer);

    if(options.all) {
      extraHeaders.push('Contact: *');
      extraHeaders.push('Expires: 0');

      this.request = new JsSIP.OutgoingRequest(JsSIP.C.REGISTER, this.registrar, this.ua, {
          'to_uri': this.to_uri,
          'call_id': this.call_id,
          'cseq': (this.cseq += 1)
        }, extraHeaders);
    } else {
      extraHeaders.push('Contact: '+ this.contact + ';expires=0');

      this.request = new JsSIP.OutgoingRequest(JsSIP.C.REGISTER, this.registrar, this.ua, {
          'to_uri': this.to_uri,
          'call_id': this.call_id,
          'cseq': (this.cseq += 1)
        }, extraHeaders);
    }

    var request_sender = new JsSIP.RequestSender(this, this.ua);

    /**
    * @private
    */
    this.receiveResponse = function(response) {
      var cause;

      switch(true) {
        case /^1[0-9]{2}$/.test(response.status_code):
          // Ignore provisional responses.
          break;
        case /^2[0-9]{2}$/.test(response.status_code):
          this.unregistered(response);
          break;
        default:
          cause = JsSIP.Utils.sipErrorCause(response.status_code);
          this.unregistered(response, cause);
      }
    };

    /**
    * @private
    */
    this.onRequestTimeout = function() {
      this.unregistered(null, JsSIP.C.causes.REQUEST_TIMEOUT);
    };

    /**
    * @private
    */
    this.onTransportError = function() {
      this.unregistered(null, JsSIP.C.causes.CONNECTION_ERROR);
    };

    request_sender.send();
  },

  /**
  * @private
  */
  registrationFailure: function(response, cause) {
    this.ua.emit('registrationFailed', this.ua, {
      response: response || null,
      cause: cause
    });

    if (this.registered) {
      this.registered = false;
      this.ua.emit('unregistered', this.ua, {
        response: response || null,
        cause: cause
      });
    }
  },

  /**
   * @private
   */
  unregistered: function(response, cause) {
    this.registered = false;
    this.ua.emit('unregistered', this.ua, {
      response: response || null,
      cause: cause || null
    });
  },

  /**
  * @private
  */
  onTransportClosed: function() {
    this.registered_before = this.registered;
    window.clearTimeout(this.registrationTimer);

    if(this.registered) {
      this.registered = false;
      this.ua.emit('unregistered', this.ua);
    }
  },

  /**
  * @private
  */
  onTransportConnected: function() {
    this.register();
  },

  /**
  * @private
  */
  close: function() {
    this.registered_before = this.registered;
    this.unregister();
  }
};

JsSIP.Registrator = Registrator;
}(JsSIP));


/**
 * @fileoverview Session
 */

/**
 * @augments JsSIP
 * @class Invite Session
 */
(function(JsSIP) {

// Load dependencies
var RequestSender   = /**
 * @fileoverview RequestSender
 */

/**
 * @class Session RequestSender
 * @param {JsSIP.RTCSession | RTCSession applicant} applicant
 * @param {JsSIP.OutgoingRequest} [request]
 */
(function(JsSIP){

var RequestSender = function(applicant, request) {
  this.applicant = applicant;
  this.request = request || applicant.request;
  this.session = (applicant instanceof JsSIP.RTCSession)? applicant : applicant.session;
  this.reattempt = false;
  this.reatemptTimer = null;
  this.request_sender = new JsSIP.InDialogRequestSender(this);
};

RequestSender.prototype = {
  receiveResponse: function(response) {
    var
      self = this,
      status_code = response.status_code;

    if (response.method === JsSIP.C.INVITE && status_code === 491) {
      if (!this.reattempt) {
        this.request.cseq.value = this.request.dialog.local_seqnum += 1;
        this.reatemptTimer = window.setTimeout(
          function() {
            if (self.session.status !== JsSIP.RTCSession.C.STATUS_TERMINATED) {
              self.reattempt = true;
              self.request_sender.send();
            }
          },
          this.getReattemptTimeout()
        );
      } else {
        this.applicant.receiveResponse(response);
      }
    } else {
      this.applicant.receiveResponse(response);
    }
  },

  send: function() {
    this.request_sender.send();
  },

  onRequestTimeout: function() {
    this.applicant.onRequestTimeout();
  },

  onTransportError: function() {
    this.applicant.onTransportError();
  },

  // RFC3261 14.1
  getReattemptTimeout: function() {
    if(this.session.direction === 'outgoing') {
      return (Math.random() * (4 - 2.1) + 2.1).toFixed(2);
    } else {
      return (Math.random() * 2).toFixed(2);
    }
  }
};

return RequestSender;
}(JsSIP));

var RTCMediaHandler = /**
 * @fileoverview RTCMediaHandler
 */

/* RTCMediaHandler
 * @class PeerConnection helper Class.
 * @param {JsSIP.RTCSession} session
 * @param {Object} [contraints]
 */
(function(JsSIP){

var RTCMediaHandler = function(session, constraints) {
  constraints = constraints || {};

  this.session = session;
  this.localMedia = null;
  this.peerConnection = null;

  this.init(constraints);
};

RTCMediaHandler.prototype = {

  createOffer: function(onSuccess, onFailure) {
    var
      self = this,
      sent = false;

    this.onIceCompleted = function() {
      if (!sent) {
        sent = true;
        onSuccess(self.peerConnection.localDescription.sdp);
      }
    };

    this.peerConnection.createOffer(
      function(sessionDescription){
        self.setLocalDescription(
          sessionDescription,
          onFailure
        );
      },
      function(e) {
        console.error(LOG_PREFIX +'unable to create offer');
        console.error(e);
        onFailure();
      }
    );
  },

  createAnswer: function(onSuccess, onFailure) {
    var
      self = this,
      sent = false;

    this.onIceCompleted = function() {
      if (!sent) {
        sent = true;
        onSuccess(self.peerConnection.localDescription.sdp);
      }
    };

    this.peerConnection.createAnswer(
      function(sessionDescription){
        self.setLocalDescription(
          sessionDescription,
          onFailure
        );
      },
      function(e) {
        console.error(LOG_PREFIX +'unable to create answer');
        console.error(e);
        onFailure();
      }
    );
  },

  setLocalDescription: function(sessionDescription, onFailure) {
    this.peerConnection.setLocalDescription(
      sessionDescription,
      null,
      function(e) {
        console.error(LOG_PREFIX +'unable to set local description');
        console.error(e);
        onFailure();
      }
    );
  },

  addStream: function(stream, onSuccess, onFailure, constraints) {
    try {
      this.peerConnection.addStream(stream, constraints);
    } catch(e) {
      console.error(LOG_PREFIX +'error adding stream');
      console.error(e);
      onFailure();
      return;
    }

    onSuccess();
  },

  /**
  * peerConnection creation.
  * @param {Function} onSuccess Fired when there are no more ICE candidates
  */
  init: function(constraints) {
    var idx, server, scheme, url,
      self = this,
      servers = [];

    for (idx in this.session.ua.configuration.stun_servers) {
      server = this.session.ua.configuration.stun_servers[idx];
      servers.push({'url': server});
    }

    for (idx in this.session.ua.configuration.turn_servers) {
      server = this.session.ua.configuration.turn_servers[idx];
      url = server.server;
      scheme = url.substr(0, url.indexOf(':'));
      servers.push({
        'url': scheme + ':' + server.username + '@' + url.substr(scheme.length+1),
        'credential': server.password
      });
    }

    this.peerConnection = new JsSIP.WebRTC.RTCPeerConnection({'iceServers': servers}, constraints);

    this.peerConnection.onaddstream = function(e) {
      console.log(LOG_PREFIX +'stream added: '+ e.stream.id);
    };

    this.peerConnection.onremovestream = function(e) {
      console.log(LOG_PREFIX +'stream removed: '+ e.stream.id);
    };

    this.peerConnection.onicecandidate = function(e) {
      if (e.candidate) {
        console.log(LOG_PREFIX +'ICE candidate received: '+ e.candidate.candidate);
      } else {
        self.onIceCompleted();
      }
    };

    // To be deprecated as per https://code.google.com/p/webrtc/issues/detail?id=1393
    this.peerConnection.ongatheringchange = function(e) {
      if (e.currentTarget.iceGatheringState === 'complete' && this.iceConnectionState !== 'closed') {
        self.onIceCompleted();
      }
    };

    this.peerConnection.onicechange = function() {
      console.log(LOG_PREFIX +'ICE connection state changed to "'+ this.iceConnectionState +'"');
    };

    this.peerConnection.onstatechange = function() {
      console.log(LOG_PREFIX +'PeerConnection state changed to "'+ this.readyState +'"');
    };
  },

  close: function() {
    console.log(LOG_PREFIX + 'closing PeerConnection');
    if(this.peerConnection) {
      this.peerConnection.close();

      if(this.localMedia) {
        this.localMedia.stop();
      }
    }
  },

  /**
  * @param {Object} mediaConstraints
  * @param {Function} onSuccess
  * @param {Function} onFailure
  */
  getUserMedia: function(onSuccess, onFailure, constraints) {
    var self = this;

    console.log(LOG_PREFIX + 'requesting access to local media');

    JsSIP.WebRTC.getUserMedia(constraints,
      function(stream) {
        console.log(LOG_PREFIX + 'got local media stream');
        self.localMedia = stream;
        onSuccess(stream);
      },
      function(e) {
        console.error(LOG_PREFIX +'unable to get user media');
        console.error(e);
        onFailure();
      }
    );
  },

  /**
  * Message reception.
  * @param {String} type
  * @param {String} sdp
  * @param {Function} onSuccess
  * @param {Function} onFailure
  */
  onMessage: function(type, body, onSuccess, onFailure) {
    this.peerConnection.setRemoteDescription(
      new JsSIP.WebRTC.RTCSessionDescription({type: type, sdp:body}),
      onSuccess,
      onFailure
    );
  }
};

// Return since it will be assigned to a variable.
return RTCMediaHandler;
}(JsSIP));

var DTMF            = /**
 * @fileoverview DTMF
 */

/**
 * @class DTMF
 * @param {JsSIP.RTCSession} session
 */
(function(JsSIP) {

var DTMF,
  C = {
    MIN_DURATION:            70,
    MAX_DURATION:            6000,
    DEFAULT_DURATION:        100,
    MIN_INTER_TONE_GAP:      50,
    DEFAULT_INTER_TONE_GAP:  500
  };

DTMF = function(session) {
  var events = [
  'succeeded',
  'failed'
  ];

  this.session = session;
  this.direction = null;
  this.tone = null;
  this.duration = null;

  this.initEvents(events);
};
DTMF.prototype = new JsSIP.EventEmitter();


DTMF.prototype.send = function(tone, options) {
  var request_sender, event, eventHandlers, extraHeaders;

  if (tone === undefined) {
    throw new TypeError('Not enough arguments');
  }

  this.direction = 'outgoing';

  // Check RTCSession Status
  if (this.session.status !== JsSIP.RTCSession.C.STATUS_CONFIRMED && this.session.status !== JsSIP.RTCSession.C.STATUS_WAITING_FOR_ACK) {
    throw new JsSIP.Exceptions.InvalidStateError(this.session.status);
  }

  // Get DTMF options
  options = options || {};
  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
  eventHandlers = options.eventHandlers || {};

  // Check tone type
  if (typeof tone === 'string' ) {
    tone = tone.toUpperCase();
  } else if (typeof tone === 'number') {
    tone = tone.toString();
  } else {
    throw new TypeError('Invalid tone: '+ tone);
  }

  // Check tone value
  if (!tone.match(/^[0-9A-D#*]$/)) {
    throw new TypeError('Invalid tone: '+ tone);
  } else {
    this.tone = tone;
  }

  // Duration is checked/corrected in RTCSession
  this.duration = options.duration;

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  extraHeaders.push('Content-Type: application/dtmf-relay');

  this.request = this.session.dialog.createRequest(JsSIP.C.INFO, extraHeaders);

  this.request.body = "Signal= " + this.tone + "\r\n";
  this.request.body += "Duration= " + this.duration;

  request_sender = new RequestSender(this);

  this.session.emit('newDTMF', this.session, {
    originator: 'local',
    dtmf: this,
    request: this.request
  });

  request_sender.send();
};

/**
 * @private
 */
DTMF.prototype.receiveResponse = function(response) {
  var cause;

  switch(true) {
    case /^1[0-9]{2}$/.test(response.status_code):
      // Ignore provisional responses.
      break;

    case /^2[0-9]{2}$/.test(response.status_code):
      this.emit('succeeded', this, {
        originator: 'remote',
        response: response
      });
      break;

    default:
      cause = JsSIP.Utils.sipErrorCause(response.status_code);
      this.emit('failed', this, {
        originator: 'remote',
        response: response,
        cause: cause
      });
      break;
  }
};

/**
 * @private
 */
DTMF.prototype.onRequestTimeout = function() {
  this.emit('failed', this, {
    originator: 'system',
    cause: JsSIP.C.causes.REQUEST_TIMEOUT
  });
};

/**
 * @private
 */
DTMF.prototype.onTransportError = function() {
  this.emit('failed', this, {
    originator: 'system',
    cause: JsSIP.C.causes.CONNECTION_ERROR
  });
};

/**
 * @private
 */
DTMF.prototype.init_incoming = function(request) {
  var body,
    reg_tone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/,
    reg_duration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;

  this.direction = 'incoming';
  this.request = request;

  request.reply(200);

  if (request.body) {
    body = request.body.split('\r\n');
    if (body.length === 2) {
      if (reg_tone.test(body[0])) {
        this.tone = body[0].replace(reg_tone,"$2");
      }
      if (reg_duration.test(body[1])) {
        this.duration = parseInt(body[1].replace(reg_duration,"$2"), 10);
      }
    }
  }

  if (!this.tone || !this.duration) {
    console.warn(LOG_PREFIX +'invalid INFO DTMF received, discarded');
  } else {
    this.session.emit('newDTMF', this.session, {
      originator: 'remote',
      dtmf: this,
      request: request
    });
  }
};

DTMF.C = C;
return DTMF;
}(JsSIP));

var Reinvite        = /**
 * @fileoverview Reinvite
 */

/**
 * @param {JsSIP} JsSIP - The JsSIP namespace
 * @returns {function} The Reinvite constructor
 */
(function(JsSIP) {
  
  var Reinvite,
    LOG_PREFIX = JsSIP.name +' | '+ 'REINVITE' +' | ';
  
  /**
   * @class Reinvite
   * @param {JsSIP.RTCSession} session
   */
  Reinvite = function(session) {
    var events = [
    'succeeded',
    'failed',
    'completed'
    ];
  
    this.session = session;
    this.direction = null;
    this.status = JsSIP.RTCSession.C.STATUS_NULL;
    this.timers = {};
  
    this.initEvents(events);
  };
  Reinvite.prototype = new JsSIP.EventEmitter();
  
  
  Reinvite.prototype.send = function(sdp, options) {
    var request_sender, event, eventHandlers, extraHeaders;
  
    if (sdp === undefined) {
      throw new TypeError('Not enough arguments');
    }
  
    this.direction = 'outgoing';
  
    // Check RTCSession Status
    if (this.session.status !== JsSIP.RTCSession.C.STATUS_CONFIRMED) {
      throw new JsSIP.Exceptions.InvalidStateError(this.session.status);
    }
  
    // Get options
    options = options || {};
    extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
    eventHandlers = options.eventHandlers || {};
  
    // Set event handlers
    for (event in eventHandlers) {
      this.on(event, eventHandlers[event]);
    }
  
    extraHeaders.push('Contact: '+ this.session.contact);
    if (sdp) {
      extraHeaders.push('Content-Type: application/sdp');
    }
  
    this.request = this.session.dialog.createRequest(JsSIP.C.INVITE, extraHeaders);
  
    this.request.body = sdp;
  
    request_sender = new RequestSender(this);
  
    this.session.emit('reinvite', this.session, {
      originator: 'local',
      reinvite: this,
      request: this.request
    });
  
    request_sender.send();
    this.status = JsSIP.RTCSession.C.STATUS_INVITE_SENT;
  };
  
  /**
   * @private
   */
  Reinvite.prototype.receiveResponse = function(response) {
    var code = response.status_code;
    var cause;

    switch (this.status) {
    case JsSIP.RTCSession.C.STATUS_CONFIRMED:
    case JsSIP.RTCSession.C.STATUS_CANCELED:
      // Looks like a retransmission
      // Double-check that the session has not been terminated
      if (this.session.status === JsSIP.RTCSession.C.STATUS_CONFIRMED) {
        console.info(LOG_PREFIX +'Retransmitting ACK');
        this.session.sendACK();
      }
      return;
    }

    if (code >= 100 && code < 200) {
      // Ignore provisional responses.
      this.status = JsSIP.RTCSession.C.STATUS_1XX_RECEIVED;
      return;
    }

    if (code >= 200 && code < 300) {
      this.status = JsSIP.RTCSession.C.STATUS_CONFIRMED;
      // Double-check that the session has not been terminated
      if (this.session.status === JsSIP.RTCSession.C.STATUS_CONFIRMED) {
        this.session.sendACK();
        console.log(LOG_PREFIX +'re-INVITE ACK sent', Date.now());

        this.session.dialog.processSessionTimerHeaders(response);

        this.emit('succeeded', this, {
          originator: 'remote',
          response: response,
          sdp: response.body
        });
      }
    } else {
      // Rejecting a reinvite only rejects the change to the session.
      // The session itself is still valid.
      this.status = JsSIP.RTCSession.C.STATUS_CANCELED;
      // Ack sent by transaction layer 
      cause = JsSIP.Utils.sipErrorCause(response.status_code);
      this.emit('failed', this, {
        originator: 'remote',
        response: response,
        cause: cause
      });
    }

    this.emit('completed', this, {
      originator: 'local'
    });
  };
  
  /**
   * @private
   */
  Reinvite.prototype.receiveAck = function() {
    this.status = JsSIP.RTCSession.C.STATUS_CONFIRMED;
    console.log(LOG_PREFIX +'re-INVITE ACK received', Date.now());
    if (this.timers.invite2xxTimer) {
      window.clearTimeout(this.timers.invite2xxTimer);
      delete this.timers.invite2xxTimer;
    }
    if (this.timers.ackTimer) {
      window.clearTimeout(this.timers.ackTimer);
      delete this.timers.ackTimer;
    }
    this.emit('completed', this, {
      originator: 'remote'
    });
  };
  
  /**
   * @private
   */
  Reinvite.prototype.onRequestTimeout = function() {
    this.status = JsSIP.RTCSession.C.STATUS_TERMINATED;
    this.emit('failed', this, {
      originator: 'system',
      cause: JsSIP.C.causes.REQUEST_TIMEOUT
    });
  };
  
  /**
   * @private
   */
  Reinvite.prototype.onTransportError = function() {
    switch (this.status) {
    case JsSIP.RTCSession.C.STATUS_CONFIRMED:
    case JsSIP.RTCSession.C.STATUS_CANCELED:
    case JsSIP.RTCSession.C.STATUS_TERMINATED:
      // Transport closed before the transaction terminated, but we were done anyway
      return;
    }

    this.status = JsSIP.RTCSession.C.STATUS_TERMINATED;
    this.emit('failed', this, {
      originator: 'system',
      cause: JsSIP.C.causes.CONNECTION_ERROR
    });
  };
  
  /**
   * @private
   */
  Reinvite.prototype.init_incoming = function(request) {
    var sdp = null,
      contentType = request.getHeader('Content-Type');
  
    this.direction = 'incoming';
    this.request = request;
    this.status = JsSIP.RTCSession.C.STATUS_INVITE_RECEIVED;
  
    if (request.body && contentType === 'application/sdp') {
      sdp = request.body;
    }
  
    this.session.emit('reinvite', this.session, {
      originator: 'remote',
      reinvite: this,
      request: request,
      sdp: sdp
    });
  };
  
  /**
   * @private
   */
  Reinvite.prototype.successResponseSent = function(request, extraHeaders, body) {
    var self = this.session,
      retransmissions = 1,
      timeout = JsSIP.Timers.T1;

    /**
     * RFC3261 13.3.1.4
     * Response retransmissions cannot be accomplished by transaction layer
     *  since it is destroyed when receiving the first 2xx answer
     */
    this.timers.invite2xxTimer = window.setTimeout(function invite2xxRetransmission() {
        if (self.status !== JsSIP.RTCSession.C.STATUS_WAITING_FOR_ACK) {
          return;
        }

        console.log(LOG_PREFIX +'Retransmitting 2xx:', retransmissions++);
        request.reply(200, null, extraHeaders, body);

        if (timeout < JsSIP.Timers.T2) {
          timeout = timeout * 2;
          if (timeout > JsSIP.Timers.T2) {
            timeout = JsSIP.Timers.T2;
          }
        }
        self.timers.invite2xxTimer = window.setTimeout(invite2xxRetransmission,
          timeout
        );
      },
      timeout
    );
    console.log(LOG_PREFIX +'re-INVITE response sent', Date.now());

    /**
     * RFC3261 14.2
     * If a UAS generates a 2xx response and never receives an ACK,
     *  it SHOULD generate a BYE to terminate the dialog.
     */
    this.timers.ackTimer = window.setTimeout(function() {
        if(self.status === JsSIP.RTCSession.C.STATUS_WAITING_FOR_ACK) {
          console.log(LOG_PREFIX + 'no ACK received, terminating the call');
          if (self.timers.invite2xxTimer) {
            window.clearTimeout(self.timers.invite2xxTimer);
            delete self.timers.invite2xxTimer;
          }
          self.session.sendBye();
          self.session.ended('remote', null, JsSIP.C.causes.NO_ACK);
        }
      },
      JsSIP.Timers.TIMER_H
    );
  };

  /**
   * Indicates that the incoming SDP is valid
   * Only valid for incoming reINVITEs
   */
  Reinvite.prototype.sdpValid = function() {
    var self = this,
      request = this.request,
      expires = null,
      no_answer_timeout = self.session.ua.configuration.no_answer_timeout;

    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "sdpValid" for an outgoing reINVITE');
    }

    this.status = JsSIP.RTCSession.C.STATUS_WAITING_FOR_ANSWER;

    //Get the Expires header value if exists
    if(request.hasHeader('expires')) {
      expires = request.getHeader('expires') * 1000;
    }

    // Schedule a provisional response for 1 second's time - this will be
    // cancelled if the application calls the accept() or reject() method first.
    this.timers.provisionalResponse = window.setTimeout(function () {
      // Start sending provisional responses while we await a final answer
      request.reply(180, null, ['Contact: ' + self.session.contact]);
      delete self.timers.provisionalResponse;
    }, 1000);

    if (expires && expires < no_answer_timeout) {
      // Set expiresTimer (see RFC3261 13.3.1)
      this.timers.answer = window.setTimeout(function() {
          request.reply(487);
          self.emit('failed', self, {
            originator: 'system',
            cause: JsSIP.C.causes.EXPIRES
          });
        }, expires
      );
    } else {
      // Set userNoAnswerTimer
      this.timers.answer = window.setTimeout(function() {
          request.reply(480);
          self.emit('failed', self, {
            originator: 'local',
            cause: JsSIP.C.causes.NO_ANSWER
          });
        }, no_answer_timeout
      );
    }
  };

  /**
   * Indicates that the incoming SDP is invalid
   * Only valid for incoming reINVITEs
   */
  Reinvite.prototype.sdpInvalid = function() {
    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "sdpInvalid" for an outgoing reINVITE');
    }
  
    this.request.reply(488);
    this.status = JsSIP.RTCSession.C.STATUS_WAITING_FOR_ACK;
    this.emit('failed', this, {
      originator: 'remote',
      cause: JsSIP.C.causes.BAD_MEDIA_DESCRIPTION
    });
  };

  /**
   * Accept the incoming reINVITE
   * Only valid for incoming reINVITEs
   */
  Reinvite.prototype.accept = function(options) {
    options = options || {};
  
    var self = this,
      request = this.request,
      extraHeaders = options.extraHeaders || [],
      sdp = options.sdp;
  
    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "accept" for an outgoing reINVITE');
    }
  
    if (this.timers.provisionalResponse) {
      window.clearTimeout(this.timers.provisionalResponse);
      delete this.timers.provisionalResponse;
    }
    if (this.timers.answer) {
      window.clearTimeout(this.timers.answer);
      delete this.timers.answer;
    }
  
    this.session.dialog.processSessionTimerHeaders(request);
    this.session.dialog.addSessionTimerResponseHeaders(extraHeaders);

    extraHeaders.push('Contact: ' + self.session.contact);
    extraHeaders.push('Allow: '+ JsSIP.Utils.getAllowedMethods(self.session.ua));
    extraHeaders.push('Content-Type: application/sdp');

    var replyFailed = function () {
      self.session.onTransportError();
      self.onTransportError();
    };

    request.reply(200, null, extraHeaders,
      sdp,
      this.successResponseSent.bind(this, request, extraHeaders, sdp),
      replyFailed
    );
    this.status = JsSIP.RTCSession.C.STATUS_WAITING_FOR_ACK;
  };
  
  /**
   * Reject the incoming reINVITE
   * Only valid for incoming reINVITEs
   *
   * @param {Number} status_code
   * @param {String} [reason_phrase]
   */
  Reinvite.prototype.reject = function(options) {
    options = options || {};
  
    var
      status_code = options.status_code || 480,
      reason_phrase = options.reason_phrase,
      extraHeaders = options.extraHeaders || [];
  
    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "reject" for an outgoing reINVITE');
    }
  
    if (status_code < 300 || status_code >= 700) {
      throw new TypeError('Invalid status_code: '+ status_code);
    }

    if (this.timers.provisionalResponse) {
      window.clearTimeout(this.timers.provisionalResponse);
      delete this.timers.provisionalResponse;
    }
    if (this.timers.answer) {
      window.clearTimeout(this.timers.answer);
      delete this.timers.answer;
    }
  
    this.request.reply(status_code, reason_phrase, extraHeaders);
    this.status = JsSIP.RTCSession.C.STATUS_WAITING_FOR_ACK;
  };
  
  Reinvite.C = C;
  return Reinvite;
}(JsSIP));

var Update          = /**
 * @fileoverview Update
 */

/**
 * @param {JsSIP} JsSIP - The JsSIP namespace
 * @returns {function} The Update constructor
 */
(function(JsSIP) {
  
  var Update;
  
  /**
   * @class Update
   * @param {JsSIP.RTCSession} session
   */
  Update = function(session) {
    var events = [
    'succeeded',
    'failed'
    ];
  
    this.session = session;
    this.direction = null;
    this.accepted = null;
  
    this.initEvents(events);
  };
  Update.prototype = new JsSIP.EventEmitter();
  
  
  Update.prototype.send = function(options) {
    var request_sender, event, eventHandlers, extraHeaders, sdp;
  
    this.direction = 'outgoing';
  
    // Check RTCSession Status
    if (this.session.status !== JsSIP.RTCSession.C.STATUS_CONFIRMED &&
        this.session.status !== JsSIP.RTCSession.C.STATUS_WAITING_FOR_ACK) {
      throw new JsSIP.Exceptions.InvalidStateError(this.session.status);
    }
  
    // Get Update options
    options = options || {};
    extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
    eventHandlers = options.eventHandlers || {};
    sdp = options.sdp;
  
    // Set event handlers
    for (event in eventHandlers) {
      this.on(event, eventHandlers[event]);
    }
  
    extraHeaders.push('Contact: '+ this.session.contact);
    if (sdp) {
      extraHeaders.push('Content-Type: application/sdp');
    }
  
    this.request = this.session.dialog.createRequest(JsSIP.C.UPDATE, extraHeaders);
  
    this.request.body = sdp;
  
    request_sender = new RequestSender(this);
  
    this.session.emit('update', this.session, {
      originator: 'local',
      update: this,
      request: this.request
    });
  
    request_sender.send();
  };
  
  /**
   * @private
   */
  Update.prototype.receiveResponse = function(response) {
    var cause;
  
    // Double-check that the session has not been terminated
    if (this.session.status !== JsSIP.RTCSession.C.STATUS_CONFIRMED) {
      return;
    }

    switch(true) {
      case /^1[0-9]{2}$/.test(response.status_code):
        // Ignore provisional responses.
        break;
  
      case /^2[0-9]{2}$/.test(response.status_code):
        this.session.dialog.processSessionTimerHeaders(response);
        this.emit('succeeded', this, {
          originator: 'remote',
          response: response
        });
        break;
  
      default:
        cause = JsSIP.Utils.sipErrorCause(response.status_code);
        this.emit('failed', this, {
          originator: 'remote',
          response: response,
          cause: cause
        });
        break;
    }
  };
  
  /**
   * @private
   */
  Update.prototype.onRequestTimeout = function() {
    this.emit('failed', this, {
      originator: 'system',
      cause: JsSIP.C.causes.REQUEST_TIMEOUT
    });
  };
  
  /**
   * @private
   */
  Update.prototype.onTransportError = function() {
    this.emit('failed', this, {
      originator: 'system',
      cause: JsSIP.C.causes.CONNECTION_ERROR
    });
  };
  
  /**
   * @private
   * @returns {Boolean} true if a 2xx response was sent, false otherwise
   */
  Update.prototype.init_incoming = function(request) {
    this.direction = 'incoming';
    this.request = request;
  
    this.session.emit('update', this.session, {
      originator: 'remote',
      update: this,
      request: request
    });

    if (this.accepted === null) {
      // No response sent yet
      // Just accept empty UPDATEs (for session timer refreshes)
      var contentType = request.getHeader('content-type');
      if(contentType || request.body) {
        this.reject({status_code: 488});
      } else {
        this.accept();
      }
    }

    return this.accepted;
  };
  
  /**
   * Accept the incoming Update
   * Only valid for incoming Updates
   */
  Update.prototype.accept = function(options) {
    options = options || {};

    var
      extraHeaders = options.extraHeaders || [],
      body = options.body;

    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "accept" for an outgoing update');
    }

    this.session.dialog.processSessionTimerHeaders(this.request);
    this.session.dialog.addSessionTimerResponseHeaders(extraHeaders);

    extraHeaders.push('Contact: ' + this.session.contact);

    this.request.reply(200, null, extraHeaders, body);
    this.accepted = true;
  };

  /**
   * Reject the incoming Update
   * Only valid for incoming Updates
   *
   * @param {Number} status_code
   * @param {String} [reason_phrase]
   */
  Update.prototype.reject = function(options) {
    options = options || {};

    var
      status_code = options.status_code || 480,
      reason_phrase = options.reason_phrase,
      extraHeaders = options.extraHeaders || [],
      body = options.body;

    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "reject" for an outgoing update');
    }

    if (status_code < 300 || status_code >= 700) {
      throw new TypeError('Invalid status_code: '+ status_code);
    }

    this.request.reply(status_code, reason_phrase, extraHeaders, body);
    this.accepted = false;
  };

  return Update;
}(JsSIP));


var Refer           = /**
 * @fileoverview Refer
 */

/**
 * @param {JsSIP} JsSIP - The JsSIP namespace
 * @returns The Refer constructor
 */
(function(JsSIP) {
  var Refer,
    LOG_PREFIX = JsSIP.name +' | '+ 'IN-DIALOG REFER' +' | ',
    DEFAULT_EXPIRES = 3 * 60 * 1000;

  /**
   * @class Class representing an in-dialog SIP REFER request.
   * @augments EventEmitter
   * @param {JsSIP.RTCSession} session
   */
  Refer = function(session) {
    var events = [
      'accepted',
      'failed',
      'notify'
    ];

    this.session = session;
    this.ua = session.ua;
    this.closed = false;
    this.request = null;
    this.id = null;
    this.contact = session.contact;
    this.notify_timer = null;
    this.dialog = session.dialog;
    this.subscription_state = 'pending';
    this.subscription_expires = null;
    this.expire_timer = null;
    this.last_notify_body = null;
    this.accepted = false;
    this.rejected = false;

    // Public properties
    this.direction = null;
    this.refer_uri = null;

    // Custom Refer empty object for high level use
    this.data = {};

    this.initEvents(events);
  };
  Refer.prototype = new JsSIP.EventEmitter();

  Refer.prototype.send = function(refer_uri, options) {
    var request_sender, event, contentType, eventHandlers, extraHeaders, request,
      failCause = null;

    if (refer_uri === undefined) {
      throw new TypeError('Not enough arguments');
    }

    // Check RTCSession Status
    if (this.session.status !== JsSIP.RTCSession.C.STATUS_CONFIRMED &&
        this.session.status !== JsSIP.RTCSession.C.STATUS_WAITING_FOR_ACK) {
      throw new JsSIP.Exceptions.InvalidStateError(this.session.status);
    }
  
    // Get call options
    options = options || {};
    extraHeaders = options.extraHeaders || [];
    eventHandlers = options.eventHandlers || {};
    contentType = options.contentType || 'text/plain';

    // Set event handlers
    for (event in eventHandlers) {
      this.on(event, eventHandlers[event]);
    }

    // Check refer-to validity
    try {
      refer_uri = JsSIP.Utils.normalizeURI(refer_uri, this.ua.configuration.hostport_params);
    } catch(e) {
      refer_uri = JsSIP.URI.parse(JsSIP.C.INVALID_TARGET_URI);
      failCause = JsSIP.C.causes.INVALID_REFER_TO_TARGET;
    }

    // Refer parameter initialization
    this.direction = 'outgoing';
    this.refer_uri = refer_uri;

    request = this.dialog.createRequest(JsSIP.C.REFER, extraHeaders);
    this.request = request;
    this.id = request.call_id + this.dialog.id.local_tag;

    request.setHeader('contact', this.contact);
    request.setHeader('refer-to', refer_uri);

    if(options.body) {
      request.setHeader('content-type', contentType);
      request.body = options.body;
    }

    request_sender = new RequestSender(this);

    this.ua.emit('newRefer', this.ua, {
      originator: 'local',
      refer: this,
      request: this.request
    });

    if (failCause) {
      this.emit('failed', this, {
        originator: 'local',
        cause: failCause
      });
    } else {
      request_sender.send();
      console.log(LOG_PREFIX + this.id + ' sent');
      this.notify_timer = setTimeout(
          this.onNotifyTimeout.bind(this),
          JsSIP.Timers.TIMER_F);
    }
  };

  /**
  * @private
  */
  Refer.prototype.receiveResponse = function(response) {
    var cause;

    if(this.closed) {
      return;
    }

    switch(true) {
      case /^1[0-9]{2}$/.test(response.status_code):
        // Ignore provisional responses.
        break;

      case /^2[0-9]{2}$/.test(response.status_code):
        // The initial NOTIFY creates the dialog, not the 2xx response
        console.log(LOG_PREFIX + this.id + ' accepted');
        this.emit('accepted', this, {
          originator: 'remote',
          response: response
        });
        break;

      default:
        console.log(LOG_PREFIX + this.id + ' rejected (early)');
        this.close();
        cause = JsSIP.Utils.sipErrorCause(response.status_code);
        this.emit('failed', this, {
          originator: 'remote',
          message: response,
          cause: cause
        });
        break;
    }
  };

  /**
   * @private
   */
  Refer.prototype.onRequestTimeout = function() {
    if(this.closed) {
      return;
    }
    console.log(LOG_PREFIX + this.id + ' request timeout');
    this.close();
    this.emit('failed', this, {
      originator: 'system',
      cause: JsSIP.C.causes.REQUEST_TIMEOUT
    });
  };

  /**
   * @private
   */
  Refer.prototype.onTransportError = function() {
    if(this.closed) {
      return;
    }
    console.log(LOG_PREFIX + this.id + ' transport error');
    this.close();
    this.emit('failed', this, {
      originator: 'system',
      cause: JsSIP.C.causes.CONNECTION_ERROR
    });
  };

  /**
   * @private
   */
  Refer.prototype.onNotifyTimeout = function() {
    if (this.closed || this.subscription_state !== 'pending') {
      return;
    }
    console.log(LOG_PREFIX + this.id + ' notify timeout');
    this.emitFinalNotify();
    this.close();
  };

  /**
   * Re-emit the last notify, or a 100 Trying if we never received one.
   * @private
   */
  Refer.prototype.emitFinalNotify = function() {
    var sessionEvent,
      parsed = this.last_notify_body;

    if (!parsed) {
      parsed = JsSIP.Parser.parseMessage('SIP/2.0 100 Trying\r\n', true);
    }
  
    if (parsed.status_code < 200) {
      sessionEvent = 'progress';
    } else if (parsed.status_code < 300) {
      sessionEvent = 'started';
    } else {
      sessionEvent = 'failed';
    }
  
    this.emit('notify', this, {
      originator: 'system',
      request: null,
      sipFrag: parsed,
      sessionEvent: sessionEvent,
      finalNotify: true
    });
  };

  /**
   * @private
   */
  Refer.prototype.close = function() {
    if (this.subscription_state === 'active') {
      console.warn(LOG_PREFIX + this.id + ' closed with active subscription');

      if (this.direction === 'incoming') {
        // Send a NOTIFY that terminates the subscription
        this.notify({
          body: this.last_notify_body,
          finalNotify: true
        });
      } else {
        this.emitFinalNotify();
      }
    }

    if (this.expire_timer !== null) {
      clearTimeout(this.expire_timer);
      this.expire_timer = null;
    }

    if (this.notify_timer !== null) {
      clearTimeout(this.notify_timer);
      this.notify_timer = null;
    }

    this.closed = true;
    console.log(LOG_PREFIX + this.id + ' closed');
  };

  /**
   * @private
   */
  Refer.prototype.subscriptionExpired = function() {
    if (this.subscription_state === 'terminated') {
      return;
    }

    this.notify({
      body: this.last_notify_body,
      finalNotify: true,
      terminateReason: 'timeout'
    });
    // Don't close the refer in case they re-subscribe as a result of this notify
    this.expire_timer = null;
    console.log(LOG_PREFIX + this.id + ' subscription expired');
  };

  /**
   * @private
   * @param {IncomingRequest} request
   */
  Refer.prototype.init_incoming = function(request) {
    this.direction = 'incoming';
    this.request = request;
    this.id = request.call_id + request.from_tag;

    // Check Refer-To header
    if (!request.hasHeader('refer-to')) {
      request.reply(400, 'Missing Refer-To header field');
      return false;
    }
    if (request.countHeader('refer-to') > 1) {
      request.reply(400, 'Too many Refer-To header fields');
      return false;
    }
    this.refer_uri = request.parseHeader('refer-to').uri;

    console.log(LOG_PREFIX + this.id + ' received');
    this.ua.emit('newRefer', this.ua, {
      originator: 'remote',
      refer: this,
      request: request,
      session: this.session
    });

    if (!this.accepted && !this.rejected) {
      this.accept();
    }

    return this.accepted;
  };

  /**
   * Call the refer URI. The referrer will be notified of the progress and
   * result of the call establishment process.
   *
   * @param {Object} [options]
   * Call options as used with the <code>UA.call</code> method.
   * @returns {JsSIP.RTCSession}
   *
   * @throws {TypeError}
   * @throws {JsSIP.Exceptions.InvalidTargetError}
   */
  Refer.prototype.call = function(options) {
    var session,
      uri = this.refer_uri;

    if (uri.scheme !== JsSIP.C.SIP) {
      throw new JsSIP.Exceptions.InvalidTargetError(uri);
    }

    if (!this.accepted) {
      this.accept();
    }

    session = new JsSIP.RTCSession(this.ua);
    session.connect(uri, options);
    this.addSessionNotifyHandlers(session);

    return session;
  };

  /**
   * Adds handlers to the provided session to send appropriate NOTIFY
   * messages to the referrer.
   * @param {JsSIP.RTCSession} session
   */
  Refer.prototype.addSessionNotifyHandlers = function(session) {
    var self = this;

    session.on('progress', function(event) {
      var response = event.data.response;
      self.notify({
        status_code: response.status_code,
        reason_phrase: response.reason_phrase
      });
    });

    session.once('started', function(event) {
      var response = event.data.response;
      self.notify({
        status_code: response.status_code,
        reason_phrase: response.reason_phrase
      });
      self.close();
    });

    session.once('failed', function(event) {
      var status_code = 500,
        reason_phrase = null,
        message = event.data.message;

      if (message && message instanceof JsSIP.IncomingResponse) {
        status_code = message.status_code;
        reason_phrase = message.reason_phrase;
      }

      self.notify({
        status_code: status_code,
        reason_phrase: reason_phrase
      });
      self.close();
    });
  };

  /**
   * Accept the incoming Refer. Use this for non-SIP refer URIs; for SIP URIs
   * use the <code>call</code> method instead.
   * <p>
   * After calling this method, the application should call the
   * <code>notify</code> method to inform the referrer of the progress/result
   * of the refer. This is handled automatically if the <code>call</code>
   * method is used instead.
   * 
   * @param {Object} [options]
   * @param {String[]} [options.extraHeaders]
   * Extra headers to add to the response.
   * @param {String} [options.body]
   * A message body to include in the response.
   */
  Refer.prototype.accept = function(options) {
    options = options || {};

    var
      extraHeaders = options.extraHeaders || [],
      body = options.body;

    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "accept" for an outgoing refer');
    }

    if (this.closed) {
      return;
    }

    // Set the subscription state and expiry
    this.subscription_state = 'active';
    this.subscription_expires = Date.now() + DEFAULT_EXPIRES;
    this.expire_timer = setTimeout(this.subscriptionExpired.bind(this),
        DEFAULT_EXPIRES);

    extraHeaders.push('Contact: ' + this.contact);

    this.request.reply(202, null, extraHeaders, body);
    // Send initial notify
    this.notify();
    this.accepted = true;
    console.log(LOG_PREFIX + this.id + ' accepted');
  };

  /**
   * Reject the incoming Refer.
   *
   * @param {Object} [options]
   * @param {Number} [options.status_code]
   * @param {String} [options.reason_phrase]
   * @param {String[]} [options.extraHeaders]
   * @param {String} [options.body]
   */
  Refer.prototype.reject = function(options) {
    options = options || {};

    var
      status_code = options.status_code || 603,
      reason_phrase = options.reason_phrase,
      extraHeaders = options.extraHeaders || [],
      body = options.body;

    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "reject" for an outgoing refer');
    }

    if (status_code < 300 || status_code >= 700) {
      throw new TypeError('Invalid status_code: '+ status_code);
    }

    if (this.closed) {
      return;
    }

    if (this.accepted) {
      // Delayed reject (required user input)
      console.log(LOG_PREFIX + this.id + ' rejected (late)');
      this.notify({
        status_code: status_code,
        reason_phrase: reason_phrase
      });
    } else {
      // Immediate reject (policy)
      console.log(LOG_PREFIX + this.id + ' rejected (early)');
      this.request.reply(status_code, reason_phrase, extraHeaders, body);
      this.rejected = true;
    }

    this.close();
  };

  /**
   * Notify the referrer of the current refer progress, or final result.
   * <p>
   * The application should either provide a SIP status code, or a message body
   * of type <code>message/sipfrag</code>. If neither is provided, a
   * <code>100 Trying</code> message will be constructed. If a message body is
   * provided, the <code>finalNotify</code> flag should also be set to indicate
   * whether this is the final NOTIFY message.
   *
   * @param {Object} [options]
   * @param {Number} [options.status_code]
   * @param {String} [options.reason_phrase]
   * @param {String} [options.body]
   * @param {Boolean} [options.finalNotify]
   * @param {String} [options.terminateReason]
   * @param {String[]} [options.extraHeaders]
   */
  Refer.prototype.notify = function(options) {
    var status_code, reason_phrase, finalNotify, newState, reason, stateHeader,
      body, notify,
      self = this;

    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "notify" for an outgoing refer');
    }

    options = options || {};
    if (options.body && typeof options.finalNotify === 'undefined') {
      throw new TypeError('Must specify finalNotify when providing notify body');
    }

    if (this.subscription_state !== 'active') {
      // Ignore
      return;
    }

    status_code = options.status_code || 100;
    reason_phrase = options.reason_phrase || JsSIP.C.REASON_PHRASE[status_code] || '';
    finalNotify = options.finalNotify || status_code >= 200;

    if (finalNotify) {
      newState = 'terminated';
      reason = options.terminateReason || 'noresource';
      stateHeader = newState + ';reason=' + reason;
    } else {
      newState = 'active';
      stateHeader = newState + ';expires=' +
          Math.round((this.subscription_expires - Date.now()) / 1000);
    }

    body = options.body || 'SIP/2.0 ' + status_code + ' ' + reason_phrase + '\r\n';
    this.last_notify_body = body;

    notify = new JsSIP.Notify(this);
    notify.send('refer;id=' + this.request.cseq, stateHeader, {
      extraHeaders: options.extraHeaders,
      eventHandlers: options.eventHandlers,
      content_type: 'message/sipfrag',
      body: body
    });

    this.subscription_state = newState;

    if (!finalNotify) {
      // If the notify fails, terminate the subscription
      notify.on('failed', function(){
        self.subscription_state = 'terminated';
        console.log(LOG_PREFIX + self.id + ' unsubscribed (rejected notify)');
        self.close();
      });
    }
  };

  /**
   * Receives further messages on the Refer dialog (i.e. NOTIFYs for outgoing
   * refers, and possibly SUBSCRIBEs for incoming refers).
   * @private
   * @param {IncomingRequest} request
   * @returns <code>true</code> if a success response was sent,
   * <code>false</code> otherwise.
   */
  Refer.prototype.receiveRequest = function(request) {
    switch (request.method) {
    case JsSIP.C.NOTIFY:
      return this.receiveNotify(request);
    case JsSIP.C.SUBSCRIBE:
      return this.receiveSubscribe(request);
    }

    request.reply(405, null, ['Allow: '+ JsSIP.Utils.getAllowedMethods(this.ua)]);
    return false;
  };

  /**
   * Receives NOTIFY messages on the Refer dialog.
   * @private
   * @param {IncomingRequest} request
   * @returns <code>true</code> if a success response was sent,
   * <code>false</code> otherwise.
   */
  Refer.prototype.receiveNotify = function(request) {
    var eventHeader, stateHeader, typeHeader, parsed, sessionEvent,
      extraHeaders, sipfrag,
      finalNotify = false;

    if (this.direction !== 'outgoing' ||
        (this.subscription_state !== 'active' &&
            this.subscription_state !== 'pending')) {
      request.reply(481, 'Subscription Does Not Exist');
      return false;
    }

    eventHeader = request.parseHeader('event');
    if (!eventHeader || eventHeader.event !== 'refer') {
      request.reply(489);
      this.close();
      return false;
    }

    stateHeader = request.parseHeader('subscription-state');
    if (!stateHeader) {
      request.reply(400, 'Missing Subscription-State Header');
      this.close();
      return false;
    }

    typeHeader = request.getHeader('content-type');
    if (typeHeader && typeHeader.indexOf('message/sipfrag') < 0) {
      request.reply(415);
      this.close();
      return false;
    }

    sipfrag = request.body;
    if (!/\r\n$/.test(sipfrag)) {
      // Strictly this is an invalid sipfrag, but fudge it by appending the
      // expected end-line characters.
      sipfrag += '\r\n';
    }

    parsed = JsSIP.Parser.parseMessage(sipfrag, true);
    if (!parsed || !parsed instanceof JsSIP.IncomingResponse) {
      request.reply(400, 'Bad Message Body');
      this.close();
      return false;
    }

    if (this.listeners('notify').length === 0) {
      console.log(LOG_PREFIX + this.id + ' no notify listeners; unsubscribing');
      request.reply(603);
      this.subscription_state = 'terminated';
      this.close();
      return false;
    }

    this.subscription_state = stateHeader.state;
    this.subscription_expires = Date.now() + stateHeader.expires * 1000;
    this.last_notify_body = parsed;
    if (this.notify_timer !== null) {
      clearTimeout(this.notify_timer);
      this.notify_timer = null;
    }
    if (this.expire_timer !== null) {
      clearTimeout(this.expire_timer);
      this.expire_timer = null;
    }

    extraHeaders = ['Contact: ' + this.contact];
    request.reply(200, null, extraHeaders);

    if (parsed.status_code < 200) {
      sessionEvent = 'progress';
    } else if (parsed.status_code < 300) {
      sessionEvent = 'started';
    } else {
      sessionEvent = 'failed';
    }

    console.log(LOG_PREFIX + this.id + ' notify: ' + sessionEvent);

    if (this.subscription_state === 'terminated') {
      finalNotify = true;
      this.close();
    } else {
      this.expire_timer = setTimeout(this.close.bind(this),
          (stateHeader.expires + JsSIP.Timers.T4) * 1000);
    }

    this.emit('notify', this, {
      originator: 'remote',
      request: request,
      sipFrag: parsed,
      sessionEvent: sessionEvent,
      finalNotify: finalNotify
    });

    return true;
  };

  /**
   * Receives SUBSCRIBE messages on the Refer dialog.
   * @private
   * @param {IncomingRequest} request
   */
  Refer.prototype.receiveSubscribe = function(request) {
    var eventHeader, expires, extraHeaders;

    if (this.direction !== 'incoming') {
      request.reply(481);
      return false;
    }

    if (this.subscription_state !== 'active' &&
        this.subscription_state !== 'terminated') {
      request.reply(403);
      return false;
    }

    eventHeader = request.parseHeader('event');
    if (!eventHeader || eventHeader.event !== 'refer') {
      request.reply(489);
      return false;
    }

    expires = request.parseHeader('expires');
    if (expires === 0) {
      console.log(LOG_PREFIX + this.id + ' unsubscribed (expires=0)');
      // Remote party is unsubscribing, send a final notify
      this.notify({
        body: this.last_notify_body,
        finalNotify: true
      });
      extraHeaders = [
        'Contact: ' + this.contact
      ];
      request.reply(200, null, extraHeaders);
      this.close();
      return true;
    }

    if (expires > 0) {
      expires = expires * 1000;
    } else {
      expires = DEFAULT_EXPIRES;
    }

    this.subscription_state = 'active';
    this.subscription_expires = Date.now() + expires;
    if (this.expire_timer !== null) {
      clearTimeout(this.expire_timer);
    }
    this.expire_timer = setTimeout(this.subscriptionExpired.bind(this), expires);

    extraHeaders = [
      'Contact: ' + this.contact,
      'Expires: ' + expires / 1000
    ];
    request.reply(200, null, extraHeaders);
    console.log(LOG_PREFIX + this.id + ' subscription extended');
    return true;
  };

  return Refer;
}(JsSIP));


var RTCSession,
  LOG_PREFIX = JsSIP.name +' | '+ 'RTC SESSION' +' | ',
  C = {
    // RTCSession states
    STATUS_NULL:               0,
    STATUS_INVITE_SENT:        1,
    STATUS_1XX_RECEIVED:       2,
    STATUS_INVITE_RECEIVED:    3,
    STATUS_WAITING_FOR_ANSWER: 4,
    STATUS_WAITING_FOR_ACK:    5,
    STATUS_CANCELED:           6,
    STATUS_TERMINATED:         7,
    STATUS_CONFIRMED:          8
  };


RTCSession = function(ua) {
  var events = [
  'progress',
  'failed',
  'started',
  'ended',
  'newDTMF',
  'reinvite',
  'refresh',
  'update'
  ];

  this.ua = ua;
  this.status = C.STATUS_NULL;
  this.lastReinvite = null;
  this.dialog = null;
  this.earlyDialogs = {};
  this.rtcMediaHandler = null;
  this.tones = null;
  this.allowed = null;
  this.supported = null;
  this.incoming_refer = null;
  this.outgoing_refer = null;

  // Session Timers
  this.timers = {
    ackTimer: null,
    expiresTimer: null,
    invite2xxTimer: null,
    userNoAnswerTimer: null
  };

  // Session info (public properties)
  this.direction = null;
  this.local_identity = null;
  this.remote_identity = null;
  this.start_time = null;
  this.end_time = null;

  // Custom session empty object for high level use
  this.data = {};

  this.initEvents(events);
};
RTCSession.prototype = new JsSIP.EventEmitter();


/**
 * User API
 */

/**
 * Terminate the call.
 * @param {Object} [options]
 */
RTCSession.prototype.terminate = function(options) {
  options = options || {};

  var cancel_reason,
    status_code = options.status_code,
    reason_phrase = options.reason_phrase,
    extraHeaders = options.extraHeaders || [],
    body = options.body;

  // Check Session Status
  if (this.status === C.STATUS_TERMINATED) {
    throw new JsSIP.Exceptions.InvalidStateError(this.status);
  }

  switch(this.status) {
    // - UAC -
    case C.STATUS_NULL:
    case C.STATUS_INVITE_SENT:
    case C.STATUS_1XX_RECEIVED:
      console.log(LOG_PREFIX +'canceling RTCSession');

      if (status_code && (status_code < 200 || status_code >= 700)) {
        throw new TypeError('Invalid status_code: '+ status_code);
      } else if (status_code) {
        reason_phrase = reason_phrase || JsSIP.C.REASON_PHRASE[status_code] || '';
        cancel_reason = 'SIP ;cause=' + status_code + ' ;text="' + reason_phrase + '"';
      }

      // Check Session Status
      if (this.status === C.STATUS_NULL) {
        this.isCanceled = true;
        this.cancelReason = cancel_reason;
      } else if (this.status === C.STATUS_INVITE_SENT) {
        if(this.received_100) {
          this.request.cancel(cancel_reason);
        } else {
          this.isCanceled = true;
          this.cancelReason = cancel_reason;
        }
      } else if(this.status === C.STATUS_1XX_RECEIVED) {
        this.request.cancel(cancel_reason);
      }

      this.failed('local', null, JsSIP.C.causes.CANCELED);
      break;

      // - UAS -
    case C.STATUS_WAITING_FOR_ANSWER:
      console.log(LOG_PREFIX +'rejecting RTCSession');

      status_code = status_code || 480;

      if (status_code < 300 || status_code >= 700) {
        throw new TypeError('Invalid status_code: '+ status_code);
      }

      this.request.reply(status_code, reason_phrase, extraHeaders, body);
      this.failed('local', null, JsSIP.C.causes.REJECTED);
      break;
    case C.STATUS_WAITING_FOR_ACK:
      // TODO: fix this - RFC 3261 section 15:
      // "...the callee's UA MUST NOT send a BYE on a confirmed dialog
      // until it has received an ACK for its 2xx response or until the server
      // transaction times out."
    case C.STATUS_CONFIRMED:
      console.log(LOG_PREFIX +'terminating RTCSession');

      // Send Bye
      this.sendBye(options);
      this.ended('local', null, JsSIP.C.causes.BYE);
      break;
  }

  this.close();
};

/**
 * Answer the call.
 * @param {Object} [options]
 */
RTCSession.prototype.answer = function(options) {
  options = options || {};

  var
    self = this,
    request = this.request,
    extraHeaders = options.extraHeaders || [],
    mediaConstraints = options.mediaConstraints || {'audio':true, 'video':true},
    sdp = options.sdp,

    // User media succeeded
    userMediaSucceeded = function(stream) {
      self.rtcMediaHandler.addStream(
        stream,
        streamAdditionSucceeded,
        streamAdditionFailed
      );
    },

    // User media failed
    userMediaFailed = function() {
      request.reply(480);
      self.failed('local', null, JsSIP.C.causes.USER_DENIED_MEDIA_ACCESS);
    },

    // rtcMediaHandler.addStream successfully added
    streamAdditionSucceeded = function() {
      self.rtcMediaHandler.createAnswer(
        answerCreationSucceeded,
        answerCreationFailed
      );
    },

    // rtcMediaHandler.addStream failed
    streamAdditionFailed = function() {
      if (self.status === C.STATUS_TERMINATED) {
        return;
      }

      self.failed('local', null, JsSIP.C.causes.WEBRTC_ERROR);
    },

    // rtcMediaHandler.createAnswer succeeded
    answerCreationSucceeded = function(body) {
      var supported,
        // run for reply success callback
        replySucceeded = function() {
          var retransmissions = 1,
            timeout = JsSIP.Timers.T1;
          self.status = C.STATUS_WAITING_FOR_ACK;

          /**
           * RFC3261 13.3.1.4
           * Response retransmissions cannot be accomplished by transaction layer
           *  since it is destroyed when receiving the first 2xx answer
           */
          self.timers.invite2xxTimer = window.setTimeout(function invite2xxRetransmission() {
              if (self.status !== JsSIP.RTCSession.C.STATUS_WAITING_FOR_ACK) {
                return;
              }

              console.log(LOG_PREFIX +'Retransmitting 2xx:', retransmissions++);
              request.reply(200, null, ['Contact: '+ self.contact], body);

              if (timeout < JsSIP.Timers.T2) {
                timeout = timeout * 2;
                if (timeout > JsSIP.Timers.T2) {
                  timeout = JsSIP.Timers.T2;
                }
              }
              self.timers.invite2xxTimer = window.setTimeout(invite2xxRetransmission,
                timeout
              );
            },
            timeout
          );

          /**
           * RFC3261 14.2
           * If a UAS generates a 2xx response and never receives an ACK,
           *  it SHOULD generate a BYE to terminate the dialog.
           */
          self.timers.ackTimer = window.setTimeout(function() {
              if(self.status === C.STATUS_WAITING_FOR_ACK) {
                console.log(LOG_PREFIX + 'no ACK received, terminating the call');
                window.clearTimeout(self.timers.invite2xxTimer);
                self.sendBye();
                self.ended('remote', null, JsSIP.C.causes.NO_ACK);
              }
            },
            JsSIP.Timers.TIMER_H
          );

          self.started('local');
        },

        // run for reply failure callback
        replyFailed = function() {
          self.failed('system', null, JsSIP.C.causes.CONNECTION_ERROR);
        };

      extraHeaders.push('Contact: ' + self.contact);
      extraHeaders.push('Allow: '+ JsSIP.Utils.getAllowedMethods(self.ua));
      supported = JsSIP.Utils.getSupportedExtensions(self.ua,
          JsSIP.Utils.getSessionExtensions(self, JsSIP.C.INVITE));
      extraHeaders.push('Supported: ' + supported.join(','));

      request.reply(200, null, extraHeaders,
        body,
        replySucceeded,
        replyFailed
      );
    },

    // rtcMediaHandler.createAnsewr failed
    answerCreationFailed = function() {
      if (self.status === C.STATUS_TERMINATED) {
        return;
      }

      self.failed('local', null, JsSIP.C.causes.WEBRTC_ERROR);
    };


  // Check Session Direction and Status
  if (this.direction !== 'incoming') {
    throw new TypeError('Invalid method "answer" for an outgoing call');
  } else if (this.status !== C.STATUS_WAITING_FOR_ANSWER) {
    throw new JsSIP.Exceptions.InvalidStateError(this.status);
  }

  // An error on dialog creation will fire 'failed' event
  if(!this.createDialog(request, 'UAS')) {
    request.reply(500, 'Missing Contact header field');
    return;
  }

  window.clearTimeout(this.timers.userNoAnswerTimer);

  this.dialog.processSessionTimerHeaders(request);
  this.dialog.addSessionTimerResponseHeaders(extraHeaders);

  if (sdp) {
    // Use the application-provided SDP
    answerCreationSucceeded(sdp);
  } else {
    // Handle PeerConnection, SDP, etc internally
    this.rtcMediaHandler.getUserMedia(
      userMediaSucceeded,
      userMediaFailed,
      mediaConstraints
    );
  }
};

/**
 * Send a DTMF
 *
 * @param {String|Number} tones
 * @param {Object} [options]
 */
RTCSession.prototype.sendDTMF = function(tones, options) {
  var duration, interToneGap,
    position = 0,
    self = this;

  options = options || {};
  duration = options.duration || null;
  interToneGap = options.interToneGap || null;

  if (tones === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Check Session Status
  if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {
    throw new JsSIP.Exceptions.InvalidStateError(this.status);
  }

  // Check tones
  if (!tones || (typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {
    throw new TypeError('Invalid tones: '+ tones);
  }

  tones = tones.toString();

  // Check duration
  if (duration && !JsSIP.Utils.isDecimal(duration)) {
    throw new TypeError('Invalid tone duration: '+ duration);
  } else if (!duration) {
    duration = DTMF.C.DEFAULT_DURATION;
  } else if (duration < DTMF.C.MIN_DURATION) {
    console.warn(LOG_PREFIX +'"duration" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_DURATION+ ' milliseconds');
    duration = DTMF.C.MIN_DURATION;
  } else if (duration > DTMF.C.MAX_DURATION) {
    console.warn(LOG_PREFIX +'"duration" value is greater than the maximum allowed, setting it to '+ DTMF.C.MAX_DURATION +' milliseconds');
    duration = DTMF.C.MAX_DURATION;
  } else {
    duration = Math.abs(duration);
  }
  options.duration = duration;

  // Check interToneGap
  if (interToneGap && !JsSIP.Utils.isDecimal(interToneGap)) {
    throw new TypeError('Invalid interToneGap: '+ interToneGap);
  } else if (!interToneGap) {
    interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;
  } else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {
    console.warn(LOG_PREFIX +'"interToneGap" value is lower than the minimum allowed, setting it to '+ DTMF.C.MIN_INTER_TONE_GAP +' milliseconds');
    interToneGap = DTMF.C.MIN_INTER_TONE_GAP;
  } else {
    interToneGap = Math.abs(interToneGap);
  }

  if (this.tones) {
    // Tones are already queued, just add to the queue
    this.tones += tones;
    return;
  }

  // New set of tones to start sending
  this.tones = tones;

  var sendDTMF = function () {
    var tone, timeout,
      tones = self.tones;

    if (self.status === C.STATUS_TERMINATED || !tones || position >= tones.length) {
      // Stop sending DTMF
      self.tones = null;
      return;
    }

    tone = tones[position];
    position += 1;

    if (tone === ',') {
      timeout = 2000;
    } else {
      var dtmf = new DTMF(self);
      dtmf.on('failed', function(){self.tones = null;});
      dtmf.send(tone, options);
      timeout = duration + interToneGap;
    }

    // Set timeout for the next tone
    window.setTimeout(sendDTMF, timeout);
  };

  // Send the first tone
  sendDTMF();
};


/**
 * Send a reINVITE
 *
 * @param {Object} [options]
 */
RTCSession.prototype.sendReinvite = function(options) {
  var sdp;

  options = options || {};
  sdp = options.sdp;

  // TODO: could get offer from PeerConnection if JsSIP is handling media 

  // Check whether the last INVITE transaction has completed
  // See RFC 3261 section 14.1
  if (this.lastReinvite) {
    switch (this.lastReinvite.status) {
    case C.STATUS_CONFIRMED:
    case C.STATUS_CANCELED:
    case C.STATUS_TERMINATED:
      break;
    default:
      throw new JsSIP.Exceptions.InvalidStateError(this.lastReinvite.status);
    }
  }

  // TODO: check whether there is an outstanding offer/answer exchange (including UPDATE)

  var reinvite = new Reinvite(this);
  reinvite.send(sdp, options);

  this.lastReinvite = reinvite;
};


/**
 * Send an UPDATE
 *
 * @param {Object} [options]
 */
RTCSession.prototype.sendUpdate = function(options) {
  var sdp;

  options = options || {};
  sdp = options.sdp;

  if (sdp) {
    // TODO: check whether there is an outstanding offer/answer exchange
  }

  var update = new Update(this);
  update.send(options);
};


/**
 * Send a REFER
 *
 * @param {URI} target
 * @param {Object} [options]
 * @param {Object} [options.eventHandlers]
 * @param {String[]} [options.extraHeaders]
 * @param {String} [options.contentType]
 * @param {String} [options.body]
 */
RTCSession.prototype.sendRefer = function(refer_uri, options) {
  var refer,
    target = this.dialog.remote_target;

  options = options || {};
  options.targetDialog = this.dialog;

  // Do they support REFER?
  if (!this.isMethodAllowed(JsSIP.C.REFER, false)) {
    throw new JsSIP.Exceptions.RemoteSupportError(JsSIP.C.REFER);
  }

  // Can we use out-of-dialog REFER?
  if (this.isOptionSupported(JsSIP.C.SIP_EXTENSIONS.GRUU) &&
      target.hasParam('gr') &&
      this.isOptionSupported(JsSIP.C.SIP_EXTENSIONS.TARGET_DIALOG)) {
    refer = new JsSIP.Refer(this.ua);
    refer.send(target, refer_uri, options);
    return;
  }

  // Resort to in-dialog refer
  refer = this.outgoing_refer;
  if (refer && !refer.closed) {
    throw new JsSIP.Exceptions.InvalidStateError('Refer in progress');
  }

  refer = new Refer(this);
  refer.send(refer_uri, options);
  this.outgoing_refer = refer;
};


/**
 * Checks whether the provided method is present in an Allow header received
 * from the remote party.  If an Allow header has not been received, the
 * provided default is returned instead.
 * @param {String} method The SIP method to check.
 * @param {Boolean} defaultValue The value to return if no Allow header has
 * been received.
 * @returns {Boolean}
 */
RTCSession.prototype.isMethodAllowed = function(method, defaultValue) {
  if (!this.allowed) {
    return defaultValue;
  }
  if (this.allowed.indexOf(method) >= 0) {
    return true;
  }
  return false;
};


/**
 * Checks whether the provided option is present in a Supported header received
 * from the remote party.  If a Supported header has not been received, the
 * assumption is that no options are supported.
 * @param {String} option The SIP option/extension to check.
 * @returns {Boolean}
 */
RTCSession.prototype.isOptionSupported = function(option) {
  if (this.supported && this.supported.indexOf(option) >= 0) {
    return true;
  }
  return false;
};


/**
 * RTCPeerconnection handlers
 */
RTCSession.prototype.getLocalStreams = function() {
  return this.rtcMediaHandler &&
    this.rtcMediaHandler.peerConnection &&
    this.rtcMediaHandler.peerConnection.getLocalStreams() || [];
};

RTCSession.prototype.getRemoteStreams = function() {
  return this.rtcMediaHandler &&
    this.rtcMediaHandler.peerConnection &&
    this.rtcMediaHandler.peerConnection.getRemoteStreams() || [];
};


/**
 * Session Management
 */

/**
* @private
*/
RTCSession.prototype.init_incoming = function(request) {
  var expires,
    self = this,
    contentType = request.getHeader('Content-Type');

  // Check body and content type
  if(!request.body || (contentType !== 'application/sdp')) {
    request.reply(415);
    return;
  }

  // Session parameter initialization
  this.status = C.STATUS_INVITE_RECEIVED;
  this.from_tag = request.from_tag;
  this.id = request.call_id + this.from_tag;
  this.request = request;
  this.contact = this.ua.contact.toString();

  //Save the session into the ua sessions collection.
  this.ua.sessions[this.id] = this;

  // Store the allowed methods if provided
  if(request.hasHeader('allow')) {
    this.allowed = request.parseHeader('allow');
  }
  // Store the supported options if provided
  if(request.hasHeader('supported')) {
    this.supported = request.parseHeader('supported');
  }

  //Get the Expires header value if exists
  if(request.hasHeader('expires')) {
    expires = request.getHeader('expires') * 1000;
  }

  /* Set the to_tag before
   * replying a response code that will create a dialog.
   */
  request.to_tag = JsSIP.Utils.newTag();

  // An error on dialog creation will fire 'failed' event
  if(!this.createDialog(request, 'UAS', true)) {
    request.reply(500, 'Missing Contact header field');
    return;
  }

  // Set up reply/media handling functions
  var sdpValid = function() {
    request.reply(180, null, ['Contact: ' + self.contact]);
    self.status = C.STATUS_WAITING_FOR_ANSWER;

    // Set userNoAnswerTimer
    self.timers.userNoAnswerTimer = window.setTimeout(function() {
        request.reply(480);
        self.failed('local',null, JsSIP.C.causes.NO_ANSWER);
      }, self.ua.configuration.no_answer_timeout
    );

    /* Set expiresTimer
     * RFC3261 13.3.1
     */
    if (expires) {
      self.timers.expiresTimer = window.setTimeout(function() {
          if(self.status === C.STATUS_WAITING_FOR_ANSWER) {
            request.reply(487);
            self.failed('system', null, JsSIP.C.causes.EXPIRES);
          }
        }, expires
      );
    }
  },
  
  sdpInvalid = function () {
    request.reply(488);
    self.failed('remote', request, JsSIP.C.causes.BAD_MEDIA_DESCRIPTION);
  },
  
  handleMedia = function() {
    self.rtcMediaHandler = new RTCMediaHandler(self);
    self.rtcMediaHandler.onMessage(
      'offer',
      request.body,
      /*
       * onSuccess
       * SDP Offer is valid. Fire UA newRTCSession
       */
      function() {
        sdpValid();
        self.newRTCSession('remote', request);
      },
      /*
       * onFailure
       * Bad media description
       */
      function(e) {
        console.warn(LOG_PREFIX +'invalid SDP');
        console.warn(e);
        sdpInvalid();
      }
    );
  };

  if (this.ua.configuration.handle_media) {
    //Initialize Media Session
    handleMedia();
  } else {
    /* Just notify the application of the new session.  It is responsible for
     * processing the SDP, and must call sdpValid() or sdpInvalid() as
     * appropriate.
     */
    this.newRTCSession('remote', request, sdpValid, sdpInvalid, handleMedia);
  }
};

/**
 * @private
 */
RTCSession.prototype.connect = function(target, options) {
  options = options || {};

  var event, requestParams, request,
    invalidTarget = false,
    eventHandlers = options.eventHandlers || {},
    extraHeaders = options.extraHeaders || [],
    mediaConstraints = options.mediaConstraints || {audio: true, video: true},
    RTCConstraints = options.RTCConstraints || {},
    featureTags = options.featureTags || '',
    sdp = options.sdp;

  if (target === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Check Session Status
  if (this.status !== C.STATUS_NULL) {
    throw new JsSIP.Exceptions.InvalidStateError(this.status);
  }

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  // Check target validity
  try {
    target = JsSIP.Utils.normalizeURI(target, this.ua.configuration.hostport_params);
  } catch(e) {
    target = JsSIP.URI.parse(JsSIP.C.INVALID_TARGET_URI);
    invalidTarget = true;
  }

  // Session parameter initialization
  this.from_tag = JsSIP.Utils.newTag();
  if (!sdp) {
    this.rtcMediaHandler = new RTCMediaHandler(this, RTCConstraints);
  }

  // Set anonymous property
  this.anonymous = options.anonymous;

  // OutgoingSession specific parameters
  this.isCanceled = false;
  this.received_100 = false;

  requestParams = {
      from_tag: this.from_tag,
      extra_supported: JsSIP.Utils.getSessionExtensions(this, JsSIP.C.INVITE)
  };

  this.contact = this.ua.contact.toString({
    anonymous: this.anonymous,
    outbound: true
  }) + featureTags;

  if (this.anonymous) {
    requestParams.from_display_name = 'Anonymous';
    requestParams.from_uri = 'sip:anonymous@anonymous.invalid';

    extraHeaders.push('P-Preferred-Identity: '+ this.ua.configuration.uri.toString());
    extraHeaders.push('Privacy: id');
  }

  request = new JsSIP.OutgoingRequest(JsSIP.C.INVITE, target, this.ua, requestParams, extraHeaders);
  this.request = request;
  request.setHeader('contact', this.contact);
  request.setHeader('content-type', 'application/sdp');

  this.id = this.request.call_id + this.from_tag;

  //Save the session into the ua sessions collection.
  this.ua.sessions[this.id] = this;

  this.newRTCSession('local', this.request);

  if (invalidTarget) {
    this.failed('local', null, JsSIP.C.causes.INVALID_TARGET);
  } else {
    if (sdp) {
      // Send the request now
      var request_sender = new JsSIP.RequestSender(this, this.ua);
      
      this.request.body = sdp;
      this.status = C.STATUS_INVITE_SENT;
      
      request_sender.send();
    } else {
      // Jump through some extra hoops to get media, SDP, etc
      this.sendInitialRequest(mediaConstraints);
    }
  }
};

/**
* @private
*/
RTCSession.prototype.close = function() {
  var idx;

  if(this.status === C.STATUS_TERMINATED) {
    return;
  }

  console.log(LOG_PREFIX +'closing INVITE session ' + this.id);

  // 1st Step. Terminate media.
  if (this.rtcMediaHandler){
    this.rtcMediaHandler.close();
  }

  // 2nd Step. Terminate signaling.

  // Close down any refers sharing the dialog
  if(this.incoming_refer) {
    this.incoming_refer.close();
  }

  if(this.outgoing_refer) {
    this.outgoing_refer.close();
  }

  // Clear session timers
  for(idx in this.timers) {
    window.clearTimeout(this.timers[idx]);
  }

  // Terminate dialogs

  // Terminate confirmed dialog
  if(this.dialog) {
    this.dialog.terminate();
    delete this.dialog;
  }

  // Terminate early dialogs
  for(idx in this.earlyDialogs) {
    this.earlyDialogs[idx].terminate();
    delete this.earlyDialogs[idx];
  }

  this.status = C.STATUS_TERMINATED;

  delete this.ua.sessions[this.id];
};

/**
 * Dialog Management
 * @private
 */
RTCSession.prototype.calcDialogId = function(message, type) {
  var local_tag = (type === 'UAS') ? message.to_tag : message.from_tag,
    remote_tag = (type === 'UAS') ? message.from_tag : message.to_tag;
    return message.call_id + local_tag + remote_tag;
};

/**
 * Dialog Management
 * @private
 */
RTCSession.prototype.createDialog = function(message, type, early) {
  var dialog, early_dialog,
    id = this.calcDialogId(message, type);

    early_dialog = this.earlyDialogs[id];

  // Early Dialog
  if (early) {
    if (early_dialog) {
      return true;
    } else {
      early_dialog = new JsSIP.Dialog(this, message, type, JsSIP.Dialog.C.STATUS_EARLY);

      // Dialog has been successfully created.
      if(early_dialog.id) {
        this.earlyDialogs[id] = early_dialog;
        return true;
      }
      // Dialog not created due to an error.
      else {
        this.failed('remote', message, JsSIP.C.causes.INTERNAL_ERROR);
        return false;
      }
    }
  }

  // Confirmed Dialog
  else {
    // In case the dialog is in _early_ state, update it
    if (early_dialog) {
      early_dialog.update(message, type);
      this.dialog = early_dialog;
      delete this.earlyDialogs[id];
      return true;
    }

    // Otherwise, create a _confirmed_ dialog
    dialog = new JsSIP.Dialog(this, message, type);

    if(dialog.id) {
      this.to_tag = message.to_tag;
      this.dialog = dialog;
      return true;
    }
    // Dialog not created due to an error
    else {
      this.failed('remote', message, JsSIP.C.causes.INTERNAL_ERROR);
      return false;
    }
  }
};


/**
 * In dialog Request Reception
 * @private
 * @returns true if the request is accepted, false otherwise
 */
RTCSession.prototype.receiveRequest = function(request) {
  var contentType, reinvite, update, refer, eventHeader;

  if(request.method === JsSIP.C.CANCEL) {
    /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
    * was in progress and that the UAC MAY continue with the session established by
    * any 2xx response, or MAY terminate with BYE. JsSIP does continue with the
    * established session. So the CANCEL is processed only if the session is not yet
    * established.
    */

    if(this.status === C.STATUS_WAITING_FOR_ANSWER) {
      // No response sent yet - terminate the session
      this.status = C.STATUS_CANCELED;
      // Reply 487 to the INVITE
      this.request.reply(487);
      // Reply 200 to the CANCEL
      request.reply(200);
      this.failed('remote', request, JsSIP.C.causes.CANCELED);
      return true;
    }

    // Reply 481 to the CANCEL
    request.reply(481);
    return false;
  }

  // Requests arriving here are in-dialog requests.
  switch(request.method) {
    case JsSIP.C.ACK:
      if(this.status === C.STATUS_WAITING_FOR_ACK) {
        window.clearTimeout(this.timers.ackTimer);
        window.clearTimeout(this.timers.invite2xxTimer);
        this.status = C.STATUS_CONFIRMED;
      } else if(this.lastReinvite &&
          this.lastReinvite.status === C.STATUS_WAITING_FOR_ACK) {
        this.lastReinvite.receiveAck();
      }
      break;
    case JsSIP.C.BYE:
      if(this.status === C.STATUS_CONFIRMED) {
        request.reply(200);
        this.ended('remote', request, JsSIP.C.causes.BYE);
      }
      break;
    case JsSIP.C.INVITE:
      if(this.status !== C.STATUS_CONFIRMED) {
        request.reply(491);
        return false;
      }
      if (this.lastReinvite) {
        switch (this.lastReinvite.status) {
        case C.STATUS_CONFIRMED:
        case C.STATUS_CANCELED:
        case C.STATUS_TERMINATED:
          // Previous reinvite has completed
          break;
        default:
          request.reply(491);
          return false;
        }
      }
      reinvite = new Reinvite(this);
      reinvite.init_incoming(request);
      this.lastReinvite = reinvite;
      break;
    case JsSIP.C.INFO:
      if(this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {
        contentType = request.getHeader('content-type');
        if (contentType && (contentType.match(/^application\/dtmf-relay/i))) {
          new DTMF(this).init_incoming(request);
        }
      }
      break;
    case JsSIP.C.UPDATE:
      update = new Update(this);
      return update.init_incoming(request);
    case JsSIP.C.REFER:
      if (this.incoming_refer && !this.incoming_refer.closed) {
        request.reply(491, 'Existing Refer In Progress');
        return false;
      }
      refer = new Refer(this);
      this.incoming_refer = refer;
      return refer.init_incoming(request);
    case JsSIP.C.NOTIFY:
      if (!request.hasHeader('event')) {
        request.reply(400, 'Missing Event Header');
        return false;
      }
      eventHeader = request.parseHeader('event');
      if (eventHeader && eventHeader.event === 'refer') {
        refer = this.outgoing_refer;
        if (refer) {
          return refer.receiveRequest(request);
        }
        // RFC 6665 section 4.1.3 says we MUST send a 481 unless another
        // 4xx/5xx response is more appropriate - note that this will tear down
        // the INVITE session as well.
        request.reply(481, 'Subscription Does Not Exist');
        return false;
      }
      request.reply(489);
      return false;
    case JsSIP.C.SUBSCRIBE:
      if (!request.hasHeader('event')) {
        request.reply(400, 'Missing Event Header');
        return false;
      }
      eventHeader = request.parseHeader('event');
      if (eventHeader && eventHeader.event === 'refer') {
        refer = this.incoming_refer;
        if (refer) {
          return refer.receiveRequest(request);
        }
        request.reply(403);
        return false;
      }
      request.reply(489);
      return false;
  }

  return true;
};


/**
 * Initial Request Sender
 * @private
 */
RTCSession.prototype.sendInitialRequest = function(constraints) {
  var
  self = this,
 request_sender = new JsSIP.RequestSender(self, this.ua),

 // User media succeeded
 userMediaSucceeded = function(stream) {
   self.rtcMediaHandler.addStream(
     stream,
     streamAdditionSucceeded,
     streamAdditionFailed
   );
 },

 // User media failed
 userMediaFailed = function() {
   if (self.status === C.STATUS_TERMINATED) {
     return;
   }

   self.failed('local', null, JsSIP.C.causes.USER_DENIED_MEDIA_ACCESS);
 },

 // rtcMediaHandler.addStream successfully added
 streamAdditionSucceeded = function() {
   self.rtcMediaHandler.createOffer(
     offerCreationSucceeded,
     offerCreationFailed
   );
 },

 // rtcMediaHandler.addStream failed
 streamAdditionFailed = function() {
   if (self.status === C.STATUS_TERMINATED) {
     return;
   }

   self.failed('local', null, JsSIP.C.causes.WEBRTC_ERROR);
 },

 // rtcMediaHandler.createOffer succeeded
 offerCreationSucceeded = function(offer) {
   if (self.isCanceled || self.status === C.STATUS_TERMINATED) {
     return;
   }

   self.request.body = offer;
   self.status = C.STATUS_INVITE_SENT;
   request_sender.send();
 },

 // rtcMediaHandler.createOffer failed
 offerCreationFailed = function() {
   if (self.status === C.STATUS_TERMINATED) {
     return;
   }

   self.failed('local', null, JsSIP.C.causes.WEBRTC_ERROR);
 };

 this.rtcMediaHandler.getUserMedia(
   userMediaSucceeded,
   userMediaFailed,
   constraints
 );
};

/**
 * Reception of Response for Initial Request
 * @private
 */
RTCSession.prototype.receiveResponse = function(response) {
  switch (response.method) {
  case JsSIP.C.INVITE:
    this.receiveInviteResponse(response);
    break;
  case JsSIP.C.BYE:
    // We don't care about the response
    break;
  default:
    console.warn(LOG_PREFIX + 'Unexpected response received:', response);
    break;
  }
};

/**
 * Reception of Response for Initial Request
 * @private
 */
RTCSession.prototype.receiveInviteResponse = function(response) {
  var cause,
    session = this;

  if(this.status !== C.STATUS_INVITE_SENT &&
      this.status !== C.STATUS_1XX_RECEIVED &&
      this.status !== C.STATUS_CONFIRMED) {
    console.warn(LOG_PREFIX +'Unexpected INVITE response:', response);
    return;
  }

  // Proceed to cancellation if the user requested.
  if(this.isCanceled) {
    if(response.status_code >= 100 && response.status_code < 200) {
      this.request.cancel(this.cancelReason);
    } else if(response.status_code >= 200 && response.status_code < 299) {
      this.acceptAndTerminate(response);
    }
    return;
  }

  switch(true) {
    case /^100$/.test(response.status_code):
      this.received_100 = true;
      break;
    case /^1[0-9]{2}$/.test(response.status_code):
      // Do nothing with 1xx responses without To tag.
      if(!response.to_tag) {
        console.warn(LOG_PREFIX +'1xx response received without to tag');
        break;
      }

      // Create Early Dialog if 1XX comes with contact
      if(response.hasHeader('contact')) {
        // An error on dialog creation will fire 'failed' event
        this.createDialog(response, 'UAC', true);
      }

      this.status = C.STATUS_1XX_RECEIVED;
      this.progress('remote', response);
      break;
    case /^2[0-9]{2}$/.test(response.status_code):
      if (this.status === C.STATUS_CONFIRMED) {
        // We already have a confirmed dialog
        var did = this.calcDialogId(response, 'UAC');
        if (did === this.dialog.id.toString()) {
          // Looks like a retransmission - resend ACK
          console.info(LOG_PREFIX +'Retransmitting ACK');
          this.sendACK();
        } else {
          // Looks like a fork - clear it down gracefully
          console.info(LOG_PREFIX +'Accepting and terminating fork, did:', did);
          this.acceptAndTerminate(response);
        }

        break;
      }
      this.status = C.STATUS_CONFIRMED;

      if(!response.body) {
        this.acceptAndTerminate(response, 400, 'Missing session description');
        this.failed('remote', response, JsSIP.C.causes.BAD_MEDIA_DESCRIPTION);
        break;
      }
      
      // An error on dialog creation will fire 'failed' event
      if (!this.createDialog(response, 'UAC')) {
        break;
      }

      this.sendACK();

      // Store the allowed methods if provided
      if(response.hasHeader('allow')) {
        this.allowed = response.parseHeader('allow');
      }
      // Store the supported options if provided
      if(response.hasHeader('supported')) {
        this.supported = response.parseHeader('supported');
      }

      this.dialog.processSessionTimerHeaders(response);

      if (this.rtcMediaHandler) {
        // We're handling the SDP, media, peer connection, etc
        this.rtcMediaHandler.onMessage(
            'answer',
            response.body,
            /*
             * onSuccess
             * SDP Answer fits with Offer. Media will start
             */
            function() {
              session.started('remote', response);
            },
            /*
             * onFailure
             * SDP Answer does not fit the Offer. Accept the call and Terminate.
             */
            function(e) {
              console.warn(e);
              session.sendBye({
                status_code: 488,
                reason_phrase: 'Not Acceptable Here'
              });
              session.failed('remote', response, JsSIP.C.causes.BAD_MEDIA_DESCRIPTION);
            }
          );
      } else {
        // The application is responsible for handling the media.
        // It must close the session if the SDP is unacceptable.
        session.started('remote', response);
      }
      break;
    default:
      cause = JsSIP.Utils.sipErrorCause(response.status_code);
      this.failed('remote', response, cause);
  }
};


/**
* @private
*/
RTCSession.prototype.acceptAndTerminate = function(response, status_code, reason_phrase) {
  // Send ACK and BYE
  // This method may be used with early dialogs - cannot just use confirmed dialog!
  var did = this.calcDialogId(response, 'UAC');
  var dialog = null;
  if (!this.dialog) {
    // Might as well confirm this dialog
    if (this.createDialog(response, 'UAC')){
      dialog = this.dialog;
    }
  } else if (this.dialog && did === this.dialog.id.toString()) {
    // Not sure why we would be accepting and terminating the confirmed dialog...
    dialog = this.dialog;
  } else if (this.earlyDialogs[did]) {
    // Use the existing early dialog
    dialog = this.earlyDialogs[did];
  } else {
    // Unknown dialog - create an early one
    if (this.createDialog(response, 'UAC', true)) {
      dialog = this.earlyDialogs[did];
    }
  }

  // An error on dialog creation will fire 'failed' event
  if (dialog) {
    this.sendACK({
      dialog: dialog
    });
    this.sendBye({
      dialog: dialog,
      status_code: status_code,
      reason_phrase: reason_phrase
    });
  }
};

/**
* @private
*/
RTCSession.prototype.sendACK = function(options) {
  options = options || {};

  var dialog = options.dialog || this.dialog, 
    request = dialog.createRequest(JsSIP.C.ACK);

  this.sendRequest(request);
};

/**
* @private
*/
RTCSession.prototype.sendBye = function(options) {
  options = options || {};

  var request, reason,
    status_code = options.status_code,
    reason_phrase = options.reason_phrase || JsSIP.C.REASON_PHRASE[status_code] || '',
    extraHeaders = options.extraHeaders || [],
    body = options.body,
    dialog = options.dialog || this.dialog;

  if (status_code && (status_code < 200 || status_code >= 700)) {
    throw new TypeError('Invalid status_code: '+ status_code);
  } else if (status_code) {
    reason = 'SIP ;cause=' + status_code + '; text="' + reason_phrase + '"';
    extraHeaders.push('Reason: '+ reason);
  }

  request = dialog.createRequest(JsSIP.C.BYE, extraHeaders);
  request.body = body;

  this.sendRequest(request);
};

/**
 * @private
 */
RTCSession.prototype.sendRequest = function(request) {
  var request_sender = new RequestSender(this, request);
  request_sender.send();
};

/**
 * Session Callbacks
 */

/**
* Callback to be called from UA instance when TransportError occurs
* @private
*/
RTCSession.prototype.onTransportError = function() {
  if(this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('system', null, JsSIP.C.causes.CONNECTION_ERROR);
    } else {
      this.failed('system', null, JsSIP.C.causes.CONNECTION_ERROR);
    }
  }
};

/**
* Callback to be called from UA instance when RequestTimeout occurs
* @private
*/
RTCSession.prototype.onRequestTimeout = function() {
  if(this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('system', null, JsSIP.C.causes.REQUEST_TIMEOUT);
    } else {
      this.failed('system', null, JsSIP.C.causes.CONNECTION_ERROR);
    }
  }
};

/**
 * Internal Callbacks
 */

/**
 * @private
 */
RTCSession.prototype.newRTCSession = function(originator, request, sdpValid, sdpInvalid, handleMedia) {
  var session = this,
    event_name = 'newRTCSession';

  if (originator === 'remote') {
    session.direction = 'incoming';
    session.local_identity = request.to;
    session.remote_identity = request.from;
  } else if (originator === 'local'){
    session.direction = 'outgoing';
    session.local_identity = request.from;
    session.remote_identity = request.to;
  }

  session.ua.emit(event_name, session.ua, {
    originator: originator,
    session: session,
    request: request,
    sdpValid: sdpValid || null,
    sdpInvalid: sdpInvalid || null,
    handleMedia: handleMedia || null
  });
};

/**
 * @private
 */
RTCSession.prototype.connecting = function(originator, request) {
  var session = this,
  event_name = 'connecting';

  session.emit(event_name, session, {
    originator: 'local',
    request: request
  });
};

/**
 * @private
 */
RTCSession.prototype.progress = function(originator, response) {
  var session = this,
    event_name = 'progress';

  session.emit(event_name, session, {
    originator: originator,
    response: response || null
  });
};

/**
 * @private
 */
RTCSession.prototype.started = function(originator, message) {
  var session = this,
    event_name = 'started';

  session.start_time = new Date();

  session.emit(event_name, session, {
    originator: originator,
    response: message || null
  });
};

/**
 * @private
 */
RTCSession.prototype.ended = function(originator, message, cause) {
  var session = this,
    event_name = 'ended';

  session.end_time = new Date();

  session.close();
  session.emit(event_name, session, {
    originator: originator,
    message: message || null,
    cause: cause
  });
};

/**
 * @private
 */
RTCSession.prototype.failed = function(originator, message, cause) {
  var session = this,
    event_name = 'failed';

  session.close();
  session.emit(event_name, session, {
    originator: originator,
    message: message || null,
    cause: cause
  });
};


RTCSession.C = C;
JsSIP.RTCSession = RTCSession;
}(JsSIP));



/**
 * @fileoverview Message
 */

/**
 * @augments JsSIP
 * @class Class creating SIP MESSAGE request.
 * @param {JsSIP.UA} ua
 */
(function(JsSIP) {
var Message;

Message = function(ua) {
  this.ua = ua;
  this.direction = null;
  this.local_identity = null;
  this.remote_identity = null;

  // Custom message empty object for high level use
  this.data = {};
};
Message.prototype = new JsSIP.EventEmitter();


Message.prototype.send = function(target, body, options) {
  var request_sender, event, contentType, eventHandlers, extraHeaders,
    events = [
      'succeeded',
      'failed'
    ],
    invalidTarget = false;

  if (target === undefined || body === undefined) {
    throw new TypeError('Not enough arguments');
  }

  this.initEvents(events);

  // Get call options
  options = options || {};
  extraHeaders = options.extraHeaders || [];
  eventHandlers = options.eventHandlers || {};
  contentType = options.contentType || 'text/plain';

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  // Check target validity
  try {
    target = JsSIP.Utils.normalizeURI(target, this.ua.configuration.hostport_params);
  } catch(e) {
    target = JsSIP.URI.parse(JsSIP.C.INVALID_TARGET_URI);
    invalidTarget = true;
  }

  // Message parameter initialization
  this.direction = 'outgoing';
  this.local_identity = this.ua.configuration.uri;
  this.remote_identity = target;

  this.closed = false;
  this.ua.applicants[this] = this;

  extraHeaders.push('Content-Type: '+ contentType);

  this.request = new JsSIP.OutgoingRequest(JsSIP.C.MESSAGE, target, this.ua, null, extraHeaders);

  if(body) {
    this.request.body = body;
  }

  request_sender = new JsSIP.RequestSender(this, this.ua);

  this.ua.emit('newMessage', this.ua, {
    originator: 'local',
    message: this,
    request: this.request
  });

  if (invalidTarget) {
    this.emit('failed', this, {
      originator: 'local',
      cause: JsSIP.C.causes.INVALID_TARGET
    });
  } else {
    request_sender.send();
  }
};

/**
* @private
*/
Message.prototype.receiveResponse = function(response) {
  var cause;

  if(this.closed) {
    return;
  }
  switch(true) {
    case /^1[0-9]{2}$/.test(response.status_code):
      // Ignore provisional responses.
      break;

    case /^2[0-9]{2}$/.test(response.status_code):
      delete this.ua.applicants[this];
      this.emit('succeeded', this, {
        originator: 'remote',
        response: response
      });
      break;

    default:
      delete this.ua.applicants[this];
      cause = JsSIP.Utils.sipErrorCause(response.status_code);
      this.emit('failed', this, {
        originator: 'remote',
        response: response,
        cause: cause
      });
      break;
  }
};


/**
* @private
*/
Message.prototype.onRequestTimeout = function() {
  if(this.closed) {
    return;
  }
  this.emit('failed', this, {
    originator: 'system',
    cause: JsSIP.C.causes.REQUEST_TIMEOUT
  });
};

/**
* @private
*/
Message.prototype.onTransportError = function() {
  if(this.closed) {
    return;
  }
  this.emit('failed', this, {
    originator: 'system',
    cause: JsSIP.C.causes.CONNECTION_ERROR
  });
};

/**
* @private
*/
Message.prototype.close = function() {
  this.closed = true;
  delete this.ua.applicants[this];
};

/**
 * @private
 */
Message.prototype.init_incoming = function(request) {
  var transaction;

  this.direction = 'incoming';
  this.request = request;
  this.local_identity = request.to.uri;
  this.remote_identity = request.from.uri;

  this.ua.emit('newMessage', this.ua, {
    originator: 'remote',
    message: this,
    request: request
  });

  transaction = this.ua.transactions.nist[request.via_branch];

  if (transaction && (transaction.state === JsSIP.Transactions.C.STATUS_TRYING || transaction.state === JsSIP.Transactions.C.STATUS_PROCEEDING)) {
    request.reply(200);
  }
};

/**
 * Accept the incoming Message
 * Only valid for incoming Messages
 */
Message.prototype.accept = function(options) {
  options = options || {};

  var
    extraHeaders = options.extraHeaders || [],
    body = options.body;

  if (this.direction !== 'incoming') {
    throw new TypeError('Invalid method "accept" for an outgoing message');
  }

  this.request.reply(200, null, extraHeaders, body);
};

/**
 * Reject the incoming Message
 * Only valid for incoming Messages
 *
 * @param {Number} status_code
 * @param {String} [reason_phrase]
 */
Message.prototype.reject = function(options) {
  options = options || {};

  var
    status_code = options.status_code || 480,
    reason_phrase = options.reason_phrase,
    extraHeaders = options.extraHeaders || [],
    body = options.body;

  if (this.direction !== 'incoming') {
    throw new TypeError('Invalid method "reject" for an outgoing message');
  }

  if (status_code < 300 || status_code >= 700) {
    throw new TypeError('Invalid status_code: '+ status_code);
  }

  this.request.reply(status_code, reason_phrase, extraHeaders, body);
};

JsSIP.Message = Message;
}(JsSIP));



/**
 * @fileoverview SIP User Agent
 */


/**
 * @augments JsSIP
 * @class Class creating a SIP User Agent.
 */
(function(JsSIP) {
var UA,
  LOG_PREFIX = JsSIP.name +' | '+ 'UA' +' | ',
  C = {
    // UA status codes
    STATUS_INIT :                0,
    STATUS_READY:                1,
    STATUS_USER_CLOSED:          2,
    STATUS_NOT_READY:            3,

    // UA error codes
    CONFIGURATION_ERROR:  1,
    NETWORK_ERROR:        2,

    /* UA events and corresponding SIP Methods.
     * Dynamically added to 'Allow' header field if the
     * corresponding event handler is set.
     */
    EVENT_METHODS: {
      'newRTCSession': 'INVITE,UPDATE',
      'newMessage': 'MESSAGE',
      'newRefer': 'REFER'
    },

    ALLOWED_METHODS: [
      'ACK',
      'CANCEL',
      'BYE',
      'OPTIONS',
      'NOTIFY'
    ],

    ACCEPTED_BODY_TYPES: [
      'application/sdp',
      'application/dtmf-relay'
    ],

    SUPPORTED_EXTENSIONS: [
      'path',
      'outbound',
      'gruu'
    ],

    /*
     * Additional SIP extensions that are supported if the corresponding UA
     * event is handled.
     * Dynamically added to 'Supported' header field.
     */
    EVENT_EXTENSIONS: {
      'tdialog': 'newRefer'
    },

    /*
     * Additional SIP extensions that are supported if the corresponding Session
     * event is handled.
     * Dynamically added to 'Supported' header field.
     */
    SESSION_EVENT_EXTENSIONS: {
      'timer': 'refresh'
    },

    MAX_FORWARDS: 69,
    TAG_LENGTH: 10
  };

UA = function(configuration) {
  var events = [
    'connected',
    'disconnected',
    'registered',
    'unregistered',
    'registrationFailed',
    'newRTCSession',
    'newMessage',
    'newOptions',
    'newRefer'
  ];

  // Set Accepted Body Types
  C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();

  this.cache = {
    credentials: {}
  };

  this.configuration = {};
  this.dialogs = {};
  this.registrator = null;

  //User actions outside any session/dialog (MESSAGE)
  this.applicants = {};

  this.sessions = {};
  this.refers = {};
  this.transport = null;
  this.contact = null;
  this.status = C.STATUS_INIT;
  this.error = null;
  this.transactions = {
    nist: {},
    nict: {},
    ist: {},
    ict: {}
  };

  this.transportRecoverAttempts = 0;

  /**
   * Load configuration
   *
   * @throws {JsSIP.Exceptions.ConfigurationError}
   * @throws {TypeError}
   */

  if(configuration === undefined) {
    throw new TypeError('Not enough arguments');
  }

  try {
    this.loadConfig(configuration);
    this.initEvents(events);
  } catch(e) {
    this.status = C.STATUS_NOT_READY;
    this.error = C.CONFIGURATION_ERROR;
    throw e;
  }
};
UA.prototype = new JsSIP.EventEmitter();

//=================
//  High Level API
//=================

/**
 * Register.
 *
 *
 */
UA.prototype.register = function(options) {
  this.configuration.register = true;
  this.registrator.register(options);
};

/**
 * Unregister.
 *
 * @param {Boolean} [all] unregister all user bindings.
 *
 */
UA.prototype.unregister = function(options) {
  this.configuration.register = false;
  this.registrator.unregister(options);
};

/**
 * Registration state.
 * @param {Boolean}
 */
UA.prototype.isRegistered = function() {
  if(this.registrator && this.registrator.registered) {
    return true;
  } else {
    return false;
  }
};

/**
 * Connection state.
 * @param {Boolean}
 */
UA.prototype.isConnected = function() {
  if(this.transport) {
    return this.transport.connected;
  } else {
    return false;
  }
};

/**
 * Make an outgoing call.
 *
 * @param {String} target
 * @param {Object} views
 * @param {Object} [options]
 *
 * @throws {TypeError}
 *
 */
UA.prototype.call = function(target, options) {
  var session;

  session = new JsSIP.RTCSession(this);
  session.connect(target, options);
};

/**
 * Send a message.
 *
 * @param {String} target
 * @param {String} body
 * @param {Object} [options]
 *
 * @throws {TypeError}
 *
 */
UA.prototype.sendMessage = function(target, body, options) {
  var message;

  message = new JsSIP.Message(this);
  message.send(target, body, options);
};

/**
 * Gracefully close.
 *
 */
UA.prototype.stop = function() {
  var session, refer, applicant,
    ua = this;

  console.log(LOG_PREFIX +'user requested closure...');

  if(this.status === C.STATUS_USER_CLOSED) {
    console.warn('UA already closed');
    return;
  }

  // Close registrator
  if(this.registrator) {
    console.log(LOG_PREFIX +'closing registrator');
    this.registrator.close();
  }

  // Run  _terminate_ on every Session
  for(session in this.sessions) {
    console.log(LOG_PREFIX +'closing session ' + session);
    this.sessions[session].terminate();
  }

  // Run  _close_ on every Refer
  for(refer in this.refers) {
    this.refers[refer].close();
  }

  // Run  _close_ on every applicant
  for(applicant in this.applicants) {
    this.applicants[applicant].close();
  }

  this.status = C.STATUS_USER_CLOSED;
  if (!this.isAnyTransactionOutstanding()) {
    // Disconnect now, no grace time needed
    ua.transport.disconnect();
  } else {
    // Run a grace timer to allow outstanding transactions to complete if
    // possible, but disconnect before that if they do complete.
    this.transactionCheckTimer = window.setInterval(function () {
      if (!ua.isAnyTransactionOutstanding()) {
        // Disconnect now
        window.clearInterval(ua.transactionCheckTimer);
        window.clearTimeout(ua.shutdownGraceTimer);
        ua.transport.disconnect();
      }
    }, 500);

    this.shutdownGraceTimer = window.setTimeout(
      function() {
        window.clearInterval(ua.transactionCheckTimer);
        ua.transport.disconnect();
      },
      '5000'
    );
  }
};

/**
 * Connect to the WS server if status = STATUS_INIT.
 * Resume UA after being closed.
 *
 */
UA.prototype.start = function() {
  var server;

  console.log(LOG_PREFIX +'user requested startup...');

  if (this.status === C.STATUS_INIT) {
    server = this.getNextWsServer();
    new JsSIP.Transport(this, server);
  } else if(this.status === C.STATUS_USER_CLOSED) {
    console.log(LOG_PREFIX +'resuming');
    this.status = C.STATUS_READY;
    this.transport.connect();
  } else if (this.status === C.STATUS_READY) {
    console.log(LOG_PREFIX +'UA is in READY status, not resuming');
  } else {
    console.error('Connection is down. Auto-Recovery system is trying to connect');
  }
};


//===============================
//  Private (For internal use)
//===============================

UA.prototype.saveCredentials = function(credentials) {
  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};
  this.cache.credentials[credentials.realm][credentials.uri] = credentials;
};

UA.prototype.getCredentials = function(request) {
  var realm, credentials;

  realm = request.ruri.host;

  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {
    credentials = this.cache.credentials[realm][request.ruri];
    credentials.method = request.method;
  }

  return credentials;
};

UA.prototype.isAnyTransactionOutstanding = function() {
  var client_transactions = ['nict', 'ict', 'nist', 'ist'];

  for(var type in client_transactions) {
    for(var idx in this.transactions[client_transactions[type]]) {
      return !!idx;
    }
  }

  return false;
};

//==========================
// Event Handlers
//==========================

/**
 * Transport Close event.
 * @private
 * @event
 * @param {JsSIP.Transport} transport.
 */
UA.prototype.onTransportClosed = function(transport) {
  // Run _onTransportError_ callback on every client transaction using _transport_
  var type, idx,
    client_transactions = ['nict', 'ict', 'nist', 'ist'];

  transport.server.status = JsSIP.Transport.C.STATUS_DISCONNECTED;
  console.log(LOG_PREFIX +'connection state set to '+ JsSIP.Transport.C.STATUS_DISCONNECTED);

  for(type in client_transactions) {
    for(idx in this.transactions[client_transactions[type]]) {
      this.transactions[client_transactions[type]][idx].onTransportError();
    }
  }

  // Close sessions if GRUU is not being used
  if (!this.contact.pub_gruu) {
    this.closeSessionsOnTransportError();
  }

};

/**
 * Unrecoverable transport event.
 * Connection reattempt logic has been done and didn't success.
 * @private
 * @event
 * @param {JsSIP.Transport} transport.
 */
UA.prototype.onTransportError = function(transport) {
  var server;

  console.log(LOG_PREFIX +'transport ' + transport.server.ws_uri + ' failed | connection state set to '+ JsSIP.Transport.C.STATUS_ERROR);

  // Close sessions.
  //Mark this transport as 'down' and try the next one
  transport.server.status = JsSIP.Transport.C.STATUS_ERROR;

  this.emit('disconnected', this, {
    transport: transport,
    code: transport.lastTransportError.code,
    reason: transport.lastTransportError.reason
  });

  server = this.getNextWsServer();

  if(server) {
    new JsSIP.Transport(this, server);
  }else {
    this.closeSessionsOnTransportError();
    if (!this.error || this.error !== C.NETWORK_ERROR) {
      this.status = C.STATUS_NOT_READY;
      this.error = C.NETWORK_ERROR;
    }
    // Transport Recovery process
    this.recoverTransport();
  }
};

/**
 * Transport connection event.
 * @private
 * @event
 * @param {JsSIP.Transport} transport.
 */
UA.prototype.onTransportConnected = function(transport) {
  this.transport = transport;

  // Reset transport recovery counter
  this.transportRecoverAttempts = 0;

  transport.server.status = JsSIP.Transport.C.STATUS_READY;
  console.log(LOG_PREFIX +'connection state set to '+ JsSIP.Transport.C.STATUS_READY);

  if(this.status === C.STATUS_USER_CLOSED) {
    return;
  }

  this.status = C.STATUS_READY;
  this.error = null;
  this.emit('connected', this, {
    transport: transport
  });

  if(this.configuration.register) {
    if(this.registrator) {
      this.registrator.onTransportConnected();
    } else {
      this.registrator = new JsSIP.Registrator(this, transport);
      this.register();
    }
  } else {
    this.registrator = new JsSIP.Registrator(this, transport);
  }
};

//=========================
// receiveRequest
//=========================

/**
 * Request reception
 * @private
 * @param {JsSIP.IncomingRequest} request.
 */
UA.prototype.receiveRequest = function(request) {
  var dialog, session, message, refer,
    method = request.method;

  // Check that Ruri points to us
  if(request.ruri.user !== this.configuration.uri.user && request.ruri.user !== this.contact.uri.user) {
    console.warn(LOG_PREFIX +'Request-URI does not point to us');
    if (request.method !== JsSIP.C.ACK) {
      request.reply_sl(404);
    }
    return;
  }

  // Check transaction
  if(JsSIP.Transactions.checkTransaction(this, request)) {
    return;
  }

  // Check Require header (RFC 3261 section 8.2.2.3)
  if(request.hasHeader('require')) {
    var supported = JsSIP.Utils.getSupportedExtensions(this);
    var tokens = request.parseHeader('require');

    for (var idx = 0, len = tokens.length; idx < len; idx++) {
      var token = tokens[idx];
      if (supported.indexOf(token) < 0 && !C.SESSION_EVENT_EXTENSIONS[token]) {
        // Unrecognised option-tag/extension
        if (request.method !== JsSIP.C.ACK) {
          request.reply_sl(420);
        }
        return;
      }
    }
  }

  // Create the server transaction
  if(method === JsSIP.C.INVITE) {
    new JsSIP.Transactions.InviteServerTransaction(request, this);
  } else if(method !== JsSIP.C.ACK) {
    new JsSIP.Transactions.NonInviteServerTransaction(request, this);
  }

  /* RFC3261 12.2.2
   * Requests that do not change in any way the state of a dialog may be
   * received within a dialog (for example, an OPTIONS request).
   * They are processed as if they had been received outside the dialog.
   */
  if(method === JsSIP.C.OPTIONS) {
    var extraHeaders = [
      'Allow: '+ JsSIP.Utils.getAllowedMethods(this),
      'Accept: '+ C.ACCEPTED_BODY_TYPES,
      'Supported: ' + JsSIP.Utils.getSupportedExtensions(this).join(',')
    ];
    
    if (!this.checkEvent('newOptions') || this.listeners('newOptions').length === 0) {
      request.reply(200, null, extraHeaders);
    } else {
      this.emit('newOptions', this, {
        originator: 'remote',
        request: request,
        extraHeaders: extraHeaders
      });      
    }
    
    return;
  } else if (method === JsSIP.C.MESSAGE) {
    if (!this.checkEvent('newMessage') || this.listeners('newMessage').length === 0) {
      request.reply(405, null, ['Allow: '+ JsSIP.Utils.getAllowedMethods(this)]);
      return;
    }
    message = new JsSIP.Message(this);
    message.init_incoming(request);
    
    return;
  }

  if(!request.to_tag) {
    // Initial Request
    if(!this.isRegistered()) {
      // High user does not want to be contacted
      request.reply(410);
      return;
    }

    switch(method) {
      case JsSIP.C.INVITE:
        if(!this.configuration.handle_media || JsSIP.WebRTC.isSupported) {
          session = new JsSIP.RTCSession(this);
          session.init_incoming(request);
        } else {
          console.warn(LOG_PREFIX +'INVITE received but WebRTC is not supported');
          request.reply(488);
        }
        break;
      case JsSIP.C.BYE:
        // Out of dialog BYE received
        request.reply(481);
        break;
      case JsSIP.C.CANCEL:
        session = this.findSession(request);
        if(session) {
          session.receiveRequest(request);
        } else {
          request.reply(481);
          console.warn(LOG_PREFIX +'received CANCEL request for a non existent session');
        }
        break;
      case JsSIP.C.ACK:
        /* Absorb it.
         * ACK request without a corresponding Invite Transaction
         * and without To tag.
         */
        break;
      case JsSIP.C.REFER:
        refer = new JsSIP.Refer(this);
        refer.init_incoming(request);
        break;
      default:
        request.reply(405, null, ['Allow: '+ JsSIP.Utils.getAllowedMethods(this)]);
        break;
    }
  } else {
    // In-dialog request
    dialog = this.findDialog(request);
    if(dialog) {
      dialog.receiveRequest(request);
      return;
    }

    if (method === JsSIP.C.NOTIFY) {
      // Notify may be dialog-forming - find the target session/refer
      session = this.findSession(request);
      if(session) {
        session.receiveRequest(request);
        return;
      }

      refer = this.refers[request.call_id + request.to_tag];
      if (refer) {
        refer.receiveRequest(request);
        return;
      }

      console.warn(LOG_PREFIX +'received NOTIFY request for a non existent session');
      request.reply(481, 'Subscription does not exist');
      return;
    }

    /* RFC3261 12.2.2
     * Request with to tag, but no matching dialog found.
     * Exception: ACK for an Invite request for which a dialog has not
     * been created.
     */
    if(method !== JsSIP.C.ACK) {
      request.reply(481);
      return;
    }
  }
};

//=================
// Utils
//=================

/**
 * Get the session to which the request belongs to, if any.
 * @private
 * @param {JsSIP.IncomingRequest} request.
 * @returns {JsSIP.OutgoingSession|JsSIP.IncomingSession|null}
 */
UA.prototype.findSession = function(request) {
  var
    sessionIDa = request.call_id + request.from_tag,
    sessionA = this.sessions[sessionIDa],
    sessionIDb = request.call_id + request.to_tag,
    sessionB = this.sessions[sessionIDb];

  if(sessionA) {
    return sessionA;
  } else if(sessionB) {
    return sessionB;
  } else {
    return null;
  }
};

/**
 * Get the dialog to which the request belongs to, if any.
 * @private
 * @param {JsSIP.IncomingRequest}
 * @returns {JsSIP.Dialog|null}
 */
UA.prototype.findDialog = function(request) {
  var
    id = request.call_id + request.from_tag + request.to_tag,
    dialog = this.dialogs[id];

  if(dialog) {
    return dialog;
  } else {
    id = request.call_id + request.to_tag + request.from_tag;
    dialog = this.dialogs[id];
    if(dialog) {
      return dialog;
    } else {
      return null;
    }
  }
};

/**
 * Retrieve the next server to which connect.
 * @private
 * @returns {Object} ws_server
 */
UA.prototype.getNextWsServer = function() {
  // Order servers by weight
  var idx, ws_server,
    candidates = [];

  for (idx in this.configuration.ws_servers) {
    ws_server = this.configuration.ws_servers[idx];

    if (ws_server.status === JsSIP.Transport.C.STATUS_ERROR) {
      continue;
    } else if (candidates.length === 0) {
      candidates.push(ws_server);
    } else if (ws_server.weight > candidates[0].weight) {
      candidates = [ws_server];
    } else if (ws_server.weight === candidates[0].weight) {
      candidates.push(ws_server);
    }
  }

  idx = Math.floor((Math.random()* candidates.length));

  return candidates[idx];
};

/**
 * Close all sessions on transport error.
 * @private
 */
UA.prototype.closeSessionsOnTransportError = function() {
  var idx;

  // Run _transportError_ for every Session
  for(idx in this.sessions) {
    this.sessions[idx].onTransportError();
  }
  // Call registrator _onTransportClosed_
  if(this.registrator){
    this.registrator.onTransportClosed();
  }
};

UA.prototype.recoverTransport = function(ua) {
  var idx, k, nextRetry, count, server;

  ua = ua || this;
  count = ua.transportRecoverAttempts;

  for (idx in ua.configuration.ws_servers) {
    ua.configuration.ws_servers[idx].status = 0;
  }

  server = ua.getNextWsServer();

  k = Math.floor((Math.random() * Math.pow(2,count)) +1);
  nextRetry = k * ua.configuration.connection_recovery_min_interval;

  if (nextRetry > ua.configuration.connection_recovery_max_interval) {
    console.log(LOG_PREFIX + 'time for next connection attempt exceeds connection_recovery_max_interval, resetting counter');
    nextRetry = ua.configuration.connection_recovery_min_interval;
    count = 0;
  }

  console.log(LOG_PREFIX + 'next connection attempt in '+ nextRetry +' seconds');

  window.setTimeout(
    function(){
      ua.transportRecoverAttempts = count + 1;
      new JsSIP.Transport(ua, server);
    }, nextRetry * 1000);
};

/**
 * Configuration load.
 * @private
 * returns {Boolean}
 */
UA.prototype.loadConfig = function(configuration) {
  // Settings and default values
  var parameter, value, checked_value, hostport_params, registrar_server,
    settings = {
      /* Host address
      * Value to be set in Via sent_by and host part of Contact FQDN
      */
      via_host: JsSIP.Utils.createRandomToken(12) + '.invalid',

      // Password
      password: null,

      // Registration parameters
      register_expires: 600,
      register_min_expires: 120,
      register: true,
      registrar_server: null,

      // Transport related parameters
      ws_server_max_reconnection: 3,
      ws_server_reconnection_timeout: 4,

      connection_recovery_min_interval: 2,
      connection_recovery_max_interval: 30,

      use_preloaded_route: false,

      // Session parameters
      no_answer_timeout: 60,
      stun_servers: ['stun:stun.l.google.com:19302'],
      turn_servers: [],
      handle_media: true,

      // Logging parameters
      trace_sip: false,

      // Hacks
      hack_via_tcp: false,
      hack_ip_in_contact: false
    };

  // Pre-Configuration

  // Check Mandatory parameters
  for(parameter in UA.configuration_check.mandatory) {
    if(!configuration.hasOwnProperty(parameter)) {
      throw new JsSIP.Exceptions.ConfigurationError(parameter);
    } else {
      value = configuration[parameter];
      checked_value = UA.configuration_check.mandatory[parameter](value);
      if (checked_value !== undefined) {
        settings[parameter] = checked_value;
      } else {
        throw new JsSIP.Exceptions.ConfigurationError(parameter, value);
      }
    }
  }

  // Check Optional parameters
  for(parameter in UA.configuration_check.optional) {
    if(configuration.hasOwnProperty(parameter)) {
      value = configuration[parameter];

      // If the parameter value is null, empty string or undefined then apply its default value.
      if(value === null || value === "" || value === undefined) { continue; }
      // If it's a number with NaN value then also apply its default value.
      // NOTE: JS does not allow "value === NaN", the following does the work:
      else if(typeof(value) === 'number' && window.isNaN(value)) { continue; }

      checked_value = UA.configuration_check.optional[parameter](value);
      if (checked_value !== undefined) {
        settings[parameter] = checked_value;
      } else {
        throw new JsSIP.Exceptions.ConfigurationError(parameter, value);
      }
    }
  }

  // Sanity Checks

  // Connection recovery intervals
  if(settings.connection_recovery_max_interval < settings.connection_recovery_min_interval) {
    throw new JsSIP.Exceptions.ConfigurationError('connection_recovery_max_interval', settings.connection_recovery_max_interval);
  }

  // Post Configuration Process

  // Allow passing 0 number as display_name.
  if (settings.display_name === 0) {
    settings.display_name = '0';
  }

  // Instance-id for GRUU
  if (!settings.instance_id) {
    settings.instance_id = 'uuid:' + JsSIP.Utils.newUUID();
  }

  // jssip_id instance parameter. Static random tag of length 5
  settings.jssip_id = JsSIP.Utils.createRandomToken(5);

  // String containing settings.uri without scheme and user.
  hostport_params = settings.uri.clone();
  hostport_params.user = null;
  settings.hostport_params = hostport_params.toString().replace(/^sip:/i, '');

  /* Check whether authorization_user is explicitly defined.
   * Take 'settings.uri.user' value if not.
   */
  if (!settings.authorization_user) {
    settings.authorization_user = settings.uri.user;
  }

  /* If no 'registrar_server' is set use the 'uri' value without user portion. */
  if (!settings.registrar_server) {
    registrar_server = settings.uri.clone();
    registrar_server.user = null;
    settings.registrar_server = registrar_server;
  }

  // User no_answer_timeout
  settings.no_answer_timeout = settings.no_answer_timeout * 1000;

  // Via Host
  if (settings.hack_ip_in_contact) {
    settings.via_host = JsSIP.Utils.getRandomTestNetIP();
  }

  this.contact = {
    pub_gruu: null,
    temp_gruu: null,
    uri: new JsSIP.URI('sip', JsSIP.Utils.createRandomToken(8), settings.via_host, null, {transport: 'ws'}),
    toString: function(options){
      options = options || {};

      var
        anonymous = options.anonymous || null,
        outbound = options.outbound || null,
        contact = '<';

      if (anonymous) {
        contact += this.temp_gruu || 'sip:anonymous@anonymous.invalid;transport=ws';
      } else {
        contact += this.pub_gruu || this.uri.toString();
      }

      if (outbound) {
        contact += ';ob';
      }

      contact += '>';

      return contact;
    }
  };

  // Fill the value of the configuration_skeleton
  console.log(LOG_PREFIX + 'configuration parameters after validation:');
  for(parameter in settings) {
    switch(parameter) {
      case 'uri':
      case 'registrar_server':
        console.log('· ' + parameter + ': ' + settings[parameter]);
        break;
      default:
        console.log('· ' + parameter + ': ' + window.JSON.stringify(settings[parameter]));
    }
    UA.configuration_skeleton[parameter].value = settings[parameter];
  }

  Object.defineProperties(this.configuration, UA.configuration_skeleton);

  // Clean UA.configuration_skeleton
  for(parameter in settings) {
    UA.configuration_skeleton[parameter].value = '';
  }

  return;
};


/**
 * Configuration Object skeleton.
 * @private
 */
UA.configuration_skeleton = (function() {
  var idx,  parameter,
    skeleton = {},
    parameters = [
      // Internal parameters
      "jssip_id",
      "register_min_expires",
      "ws_server_max_reconnection",
      "ws_server_reconnection_timeout",
      "hostport_params",

      // Mandatory user configurable parameters
      "uri",
      "ws_servers",

      // Optional user configurable parameters
      "authorization_user",
      "connection_recovery_max_interval",
      "connection_recovery_min_interval",
      "display_name",
      "hack_via_tcp", // false.
      "hack_ip_in_contact", //false
      "handle_media", //true
      "instance_id",
      "no_answer_timeout", // 30 seconds.
      "password",
      "register_expires", // 600 seconds.
      "registrar_server",
      "stun_servers",
      "trace_sip",
      "turn_servers",
      "use_preloaded_route",

      // Post-configuration generated parameters
      "via_core_value",
      "via_host"
    ];

  for(idx in parameters) {
    parameter = parameters[idx];
    skeleton[parameter] = {
      value: '',
      writable: false,
      configurable: false
    };
  }

  skeleton['register'] = {
    value: '',
    writable: true,
    configurable: false
  };

  return skeleton;
}());

/**
 * Configuration checker.
 * @private
 * @return {Boolean}
 */
UA.configuration_check = {
  mandatory: {

    uri: function(uri) {
      var parsed;

      if (!/^sip:/i.test(uri)) {
        uri = JsSIP.C.SIP + ':' + uri;
      }
      parsed = JsSIP.URI.parse(uri);

      if(!parsed) {
        return;
      } else if(!parsed.user) {
        return;
      } else {
        return parsed;
      }
    },

    ws_servers: function(ws_servers) {
      var idx, url;

      /* Allow defining ws_servers parameter as:
       *  String: "host"
       *  Array of Strings: ["host1", "host2"]
       *  Array of Objects: [{ws_uri:"host1", weight:1}, {ws_uri:"host2", weight:0}]
       *  Array of Objects and Strings: [{ws_uri:"host1"}, "host2"]
       */
      if (typeof ws_servers === 'string') {
        ws_servers = [{ws_uri: ws_servers}];
      } else if (ws_servers instanceof Array) {
        for(idx in ws_servers) {
          if (typeof ws_servers[idx] === 'string'){
            ws_servers[idx] = {ws_uri: ws_servers[idx]};
          }
        }
      } else {
        return;
      }

      if (ws_servers.length === 0) {
        return false;
      }

      for (idx in ws_servers) {
        if (!ws_servers[idx].ws_uri) {
          console.error(LOG_PREFIX +'missing "ws_uri" attribute in ws_servers parameter');
          return;
        }
        if (ws_servers[idx].weight && !Number(ws_servers[idx].weight)) {
          console.error(LOG_PREFIX +'"weight" attribute in ws_servers parameter must be a Number');
          return;
        }

        url = JsSIP.Grammar.parse(ws_servers[idx].ws_uri, 'absoluteURI');

        if(url === -1) {
          console.error(LOG_PREFIX +'invalid "ws_uri" attribute in ws_servers parameter: ' + ws_servers[idx].ws_uri);
          return;
        } else if(url.scheme !== 'wss' && url.scheme !== 'ws') {
          console.error(LOG_PREFIX +'invalid URI scheme in ws_servers parameter: ' + url.scheme);
          return;
        } else {
          ws_servers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=ws;lr>';

          if (!ws_servers[idx].weight) {
            ws_servers[idx].weight = 0;
          }

          ws_servers[idx].status = 0;
          ws_servers[idx].scheme = url.scheme.toUpperCase();
        }
      }
      return ws_servers;
    }
  },

  optional: {

    authorization_user: function(authorization_user) {
      if(JsSIP.Grammar.parse('"'+ authorization_user +'"', 'quoted_string') === -1) {
        return;
      } else {
        return authorization_user;
      }
    },

    connection_recovery_max_interval: function(connection_recovery_max_interval) {
      var value;
      if(JsSIP.Utils.isDecimal(connection_recovery_max_interval)) {
        value = window.Number(connection_recovery_max_interval);
        if(value > 0) {
          return value;
        }
      }
    },

    connection_recovery_min_interval: function(connection_recovery_min_interval) {
      var value;
      if(JsSIP.Utils.isDecimal(connection_recovery_min_interval)) {
        value = window.Number(connection_recovery_min_interval);
        if(value > 0) {
          return value;
        }
      }
    },

    display_name: function(display_name) {
      if(JsSIP.Grammar.parse('"' + display_name + '"', 'display_name') === -1) {
        return;
      } else {
        return display_name;
      }
    },

    hack_via_tcp: function(hack_via_tcp) {
      if (typeof hack_via_tcp === 'boolean') {
        return hack_via_tcp;
      }
    },

    hack_ip_in_contact: function(hack_ip_in_contact) {
      if (typeof hack_ip_in_contact === 'boolean') {
        return hack_ip_in_contact;
      }
    },

    handle_media: function(handle_media) {
      if (typeof handle_media === 'boolean') {
        return handle_media;
      }
    },

    instance_id: function(instance_id) {
      if (!(/^uuid?:/.test(instance_id))) {
        instance_id = 'uuid:' + instance_id;
      }

      if(JsSIP.Grammar.parse(instance_id, 'uuid_URI') === -1) {
        return;
      } else {
        return instance_id;
      }
    },

    no_answer_timeout: function(no_answer_timeout) {
      var value;
      if (JsSIP.Utils.isDecimal(no_answer_timeout)) {
        value = window.Number(no_answer_timeout);
        if (value > 0) {
          return value;
        }
      }
    },

    password: function(password) {
      return String(password);
    },

    register: function(register) {
      if (typeof register === 'boolean') {
        return register;
      }
    },

    register_expires: function(register_expires) {
      var value;
      if (JsSIP.Utils.isDecimal(register_expires)) {
        value = window.Number(register_expires);
        if (value > 0) {
          return value;
        }
      }
    },

    registrar_server: function(registrar_server) {
      var parsed;

      if (!/^sip:/i.test(registrar_server)) {
        registrar_server = JsSIP.C.SIP + ':' + registrar_server;
      }
      parsed = JsSIP.URI.parse(registrar_server);

      if(!parsed) {
        return;
      } else if(parsed.user) {
        return;
      } else {
        return parsed;
      }
    },

    stun_servers: function(stun_servers) {
      var idx, stun_server;

      if (typeof stun_servers === 'string') {
        stun_servers = [stun_servers];
      } else if (!(stun_servers instanceof Array)) {
        return;
      }

      for (idx in stun_servers) {
        stun_server = stun_servers[idx];
        if (!(/^stuns?:/.test(stun_server))) {
          stun_server = 'stun:' + stun_server;
        }

        if(JsSIP.Grammar.parse(stun_server, 'stun_URI') === -1) {
          return;
        } else {
          stun_servers[idx] = stun_server;
        }
      }
      return stun_servers;
    },

    trace_sip: function(trace_sip) {
      if (typeof trace_sip === 'boolean') {
        return trace_sip;
      }
    },

    turn_servers: function(turn_servers) {
      var idx, turn_server;

      if (turn_servers instanceof Array) {
        // Do nothing
      } else {
        turn_servers = [turn_servers];
      }

      for (idx in turn_servers) {
        turn_server = turn_servers[idx];
        if (!turn_server.server || !turn_server.username || !turn_server.password) {
          return;
        } else if (!(/^turns?:/.test(turn_server.server))) {
          turn_server.server = 'turn:' + turn_server.server;
        }

        if(JsSIP.Grammar.parse(turn_server.server, 'turn_URI') === -1) {
          return;
        } else if(JsSIP.Grammar.parse(turn_server.username, 'user') === -1) {
          return;
        } else if(JsSIP.Grammar.parse(turn_server.password, 'password') === -1) {
          return;
        }
      }
      return turn_servers;
    },

    use_preloaded_route: function(use_preloaded_route) {
      if (typeof use_preloaded_route === 'boolean') {
        return use_preloaded_route;
      }
    }
  }
};

UA.C = C;
JsSIP.UA = UA;
}(JsSIP));



/**
 * @fileoverview Utils
 */

(function(JsSIP) {
var Utils;

Utils= {

  str_utf8_length: function(string) {
    return window.unescape(encodeURIComponent(string)).length;
  },

  isFunction: function(fn) {
    if (fn !== undefined) {
      return (Object.prototype.toString.call(fn) === '[object Function]')? true : false;
    } else {
      return false;
    }
  },

  isDecimal: function (num) {
    return !isNaN(num) && (parseFloat(num) === parseInt(num,10));
  },

  createRandomToken: function(size, base) {
    var i, r,
      token = '';

    base = base || 32;

    for( i=0; i < size; i++ ) {
      r = Math.random() * base|0;
      token += r.toString(base);
    }

    return token;
  },

  newTag: function() {
    return JsSIP.Utils.createRandomToken(JsSIP.UA.C.TAG_LENGTH);
  },

  // http://stackoverflow.com/users/109538/broofa
  newUUID: function() {
    var UUID =  'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
      return v.toString(16);
    });

    return UUID;
  },

  hostType: function(host) {
    if (!host) {
      return;
    } else {
      host = JsSIP.Grammar.parse(host,'host');
      if (host !== -1) {
        return host.host_type;
      }
    }
  },

  /**
  * Normalize SIP URI.
  * NOTE: It does not allow a SIP URI without username.
  * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
  * Detects the domain part (if given) and properly hex-escapes the user portion.
  * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
  * @private
  * @param {String} target
  * @param {String} [domain]
  */
  normalizeURI: function(target, domain) {
    var uri, target_array, target_user, target_domain,
      original_target = target;

    // If no target is given then raise an error.
    if (!target) {
      throw new JsSIP.Exceptions.InvalidTargetError(original_target);

    // If a JsSIP.URI instance is given then return it.
    } else if (target instanceof JsSIP.URI) {
      return target;

    // If a string is given split it by '@':
    // - Last fragment is the desired domain.
    // - Otherwise append the given domain argument.
    } else if (typeof target === 'string') {
      target_array = target.split('@');

      switch(target_array.length) {
        case 1:
          if (!domain) {
            throw new JsSIP.Exceptions.InvalidTargetError(original_target);
          }
          target_user = target;
          target_domain = domain;
          break;
        case 2:
          target_user = target_array[0];
          target_domain = target_array[1];
          break;
        default:
          target_user = target_array.slice(0, target_array.length-1).join('@');
          target_domain = target_array[target_array.length-1];
      }

      // Remove the URI scheme (if present).
      target_user = target_user.replace(/^(sips?|tel):/i, '');

      // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
      if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(target_user)) {
        target_user = target_user.replace(/[\-\.\(\)]/g, '');
      }

      // Build the complete SIP URI.
      target = JsSIP.C.SIP + ':' + JsSIP.Utils.escapeUser(target_user) + '@' + target_domain;

      // Finally parse the resulting URI.
      if (uri = JsSIP.URI.parse(target)) {
        return uri;
      } else {
        throw new JsSIP.Exceptions.InvalidTargetError(original_target);
      }
    }

    // Otherwise raise an error.
    else {
      throw new JsSIP.Exceptions.InvalidTargetError(original_target);
    }
  },

  /**
  * Hex-escape a SIP URI user.
  * @private
  * @param {String} user
  */
  escapeUser: function(user) {
    // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
    return window.encodeURIComponent(window.decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');
  },

  headerize: function(string) {
    var exceptions = {
      'Call-Id': 'Call-ID',
      'Cseq': 'CSeq',
      'Www-Authenticate': 'WWW-Authenticate',
      'Min-Se': 'Min-SE'
      },
      name = string.toLowerCase().replace(/_/g,'-').split('-'),
      hname = '', part;

    for (part in name) {
      if (part !== '0') {
        hname +='-';
      }
      hname += name[part].charAt(0).toUpperCase()+name[part].substring(1);
    }
    if (exceptions[hname]) {
      hname = exceptions[hname];
    }
    return hname;
  },

  sipErrorCause: function(status_code) {
    var cause;

    for (cause in JsSIP.C.SIP_ERROR_CAUSES) {
      if (JsSIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {
        return JsSIP.C.causes[cause];
      }
    }

    return JsSIP.C.causes.SIP_FAILURE_CODE;
  },

  /**
  * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)
  * @private
  */
  getRandomTestNetIP: function() {
    function getOctet(from,to) {
      return window.Math.floor(window.Math.random()*(to-from+1)+from);
    }
    return '192.0.2.' + getOctet(1, 254);
  },

  getAllowedMethods: function(ua) {
    var event,
      allowed = JsSIP.UA.C.ALLOWED_METHODS.toString();

    for (event in JsSIP.UA.C.EVENT_METHODS) {
      if (ua.checkEvent(event) && ua.listeners(event).length > 0) {
        allowed += ','+ JsSIP.UA.C.EVENT_METHODS[event];
      }
    }

    return allowed;
  },

  getSupportedExtensions: function(ua, extraExtensions) {
    var extension, event,
      supported = JsSIP.UA.C.SUPPORTED_EXTENSIONS.slice();

    for (extension in JsSIP.UA.C.EVENT_EXTENSIONS) {
      event = JsSIP.UA.C.EVENT_EXTENSIONS[extension];
      if (ua.checkEvent(event) && ua.listeners(event).length > 0) {
        supported.push(extension);
      }
    }

    if (extraExtensions) {
      return supported.concat(extraExtensions);
    }
    return supported;
  },

  getSessionExtensions: function(session) {
    var extension, event,
      supported = [];

    for (extension in JsSIP.UA.C.SESSION_EVENT_EXTENSIONS) {
      event = JsSIP.UA.C.SESSION_EVENT_EXTENSIONS[extension];
      if (session.checkEvent(event) && session.listeners(event).length > 0) {
        supported.push(extension);
      }
    }

    return supported;
  },

  // MD5 (Message-Digest Algorithm) http://www.webtoolkit.info
  calculateMD5: function(string) {
    function RotateLeft(lValue, iShiftBits) {
      return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
    }

    function AddUnsigned(lX,lY) {
      var lX4,lY4,lX8,lY8,lResult;
      lX8 = (lX & 0x80000000);
      lY8 = (lY & 0x80000000);
      lX4 = (lX & 0x40000000);
      lY4 = (lY & 0x40000000);
      lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
      if (lX4 & lY4) {
        return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
      }
      if (lX4 | lY4) {
        if (lResult & 0x40000000) {
          return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
        } else {
          return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
        }
      } else {
        return (lResult ^ lX8 ^ lY8);
      }
    }

    function F(x,y,z) {
      return (x & y) | ((~x) & z);
    }

    function G(x,y,z) {
      return (x & z) | (y & (~z));
    }

    function H(x,y,z) {
      return (x ^ y ^ z);
    }

    function I(x,y,z) {
      return (y ^ (x | (~z)));
    }

    function FF(a,b,c,d,x,s,ac) {
      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
      return AddUnsigned(RotateLeft(a, s), b);
    }

    function GG(a,b,c,d,x,s,ac) {
      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
      return AddUnsigned(RotateLeft(a, s), b);
    }

    function HH(a,b,c,d,x,s,ac) {
      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
      return AddUnsigned(RotateLeft(a, s), b);
    }

    function II(a,b,c,d,x,s,ac) {
      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
      return AddUnsigned(RotateLeft(a, s), b);
    }

    function ConvertToWordArray(string) {
      var lWordCount;
      var lMessageLength = string.length;
      var lNumberOfWords_temp1=lMessageLength + 8;
      var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
      var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
      var lWordArray=Array(lNumberOfWords-1);
      var lBytePosition = 0;
      var lByteCount = 0;
      while ( lByteCount < lMessageLength ) {
        lWordCount = (lByteCount-(lByteCount % 4))/4;
        lBytePosition = (lByteCount % 4)*8;
        lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
        lByteCount++;
      }
      lWordCount = (lByteCount-(lByteCount % 4))/4;
      lBytePosition = (lByteCount % 4)*8;
      lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
      lWordArray[lNumberOfWords-2] = lMessageLength<<3;
      lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
      return lWordArray;
    }

    function WordToHex(lValue) {
      var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
      for (lCount = 0;lCount<=3;lCount++) {
        lByte = (lValue>>>(lCount*8)) & 255;
        WordToHexValue_temp = "0" + lByte.toString(16);
        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
      }
      return WordToHexValue;
    }

    function Utf8Encode(string) {
      string = string.replace(/\r\n/g,"\n");
      var utftext = "";

      for (var n = 0; n < string.length; n++) {
        var c = string.charCodeAt(n);

        if (c < 128) {
          utftext += String.fromCharCode(c);
        }
        else if((c > 127) && (c < 2048)) {
          utftext += String.fromCharCode((c >> 6) | 192);
          utftext += String.fromCharCode((c & 63) | 128);
        }
        else {
          utftext += String.fromCharCode((c >> 12) | 224);
          utftext += String.fromCharCode(((c >> 6) & 63) | 128);
          utftext += String.fromCharCode((c & 63) | 128);
        }
      }
      return utftext;
    }

    var x=[];
    var k,AA,BB,CC,DD,a,b,c,d;
    var S11=7, S12=12, S13=17, S14=22;
    var S21=5, S22=9 , S23=14, S24=20;
    var S31=4, S32=11, S33=16, S34=23;
    var S41=6, S42=10, S43=15, S44=21;

    string = Utf8Encode(string);

    x = ConvertToWordArray(string);

    a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;

    for (k=0;k<x.length;k+=16) {
      AA=a; BB=b; CC=c; DD=d;
      a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);
      d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
      c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
      b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
      a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
      d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
      c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
      b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
      a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
      d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
      c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
      b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
      a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
      d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
      c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
      b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
      a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
      d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
      c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
      b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);
      a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
      d=GG(d,a,b,c,x[k+10],S22,0x2441453);
      c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
      b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
      a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
      d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
      c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
      b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
      a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
      d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
      c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
      b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
      a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
      d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
      c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
      b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
      a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
      d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
      c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
      b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
      a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
      d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);
      c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
      b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
      a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
      d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
      c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
      b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
      a=II(a,b,c,d,x[k+0], S41,0xF4292244);
      d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
      c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
      b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
      a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
      d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
      c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
      b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
      a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
      d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
      c=II(c,d,a,b,x[k+6], S43,0xA3014314);
      b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
      a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
      d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
      c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
      b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
      a=AddUnsigned(a,AA);
      b=AddUnsigned(b,BB);
      c=AddUnsigned(c,CC);
      d=AddUnsigned(d,DD);
    }

    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);

    return temp.toLowerCase();
  }
};

JsSIP.Utils = Utils;
}(JsSIP));



/**
 * @fileoverview Incoming SIP Message Sanity Check
 */

/**
 * SIP message sanity check.
 * @augments JsSIP
 * @function
 * @param {JsSIP.IncomingMessage} message
 * @param {JsSIP.UA} ua
 * @param {JsSIP.Transport} transport
 * @returns {Boolean}
 */
(function(JsSIP) {
var sanityCheck,
 LOG_PREFIX = JsSIP.name +' | '+ 'SANITY CHECK' +' | ',

 message, ua, transport,
 requests = [],
 responses = [],
 all = [];

/*
 * Sanity Check for incoming Messages
 *
 * Requests:
 *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
 *  - _rfc3261_16_3_4_ Receive a Request already sent by us
 *   Does not look at via sent-by but at jssip_id, which is inserted as
 *   a prefix in all initial requests generated by the ua
 *  - _rfc3261_18_3_request_ Body Content-Length
 *  - _rfc3261_8_2_2_2_ Merged Requests
 *
 * Responses:
 *  - _rfc3261_8_1_3_3_ Multiple Via headers
 *  - _rfc3261_18_1_2_ sent-by mismatch
 *  - _rfc3261_18_3_response_ Body Content-Length
 *
 * All:
 *  - Minimum headers in a SIP message
 */

// Sanity Check functions for requests
function rfc3261_8_2_2_1() {
  if(message.s('to').uri.scheme !== 'sip') {
    reply(416);
    return false;
  }
}

function rfc3261_16_3_4() {
  if(!message.to_tag) {
    if(message.call_id.substr(0, 5) === ua.configuration.jssip_id) {
      reply(482);
      return false;
    }
  }
}

function rfc3261_18_3_request() {
  var len = JsSIP.Utils.str_utf8_length(message.body),
  contentLength = message.getHeader('content-length');

  if(len < contentLength) {
    reply(400);
    return false;
  }
}

function rfc3261_8_2_2_2() {
  var tr, idx,
    fromTag = message.from_tag,
    call_id = message.call_id,
    cseq = message.cseq;

  if(!message.to_tag) {
    if(message.method === JsSIP.C.INVITE) {
      tr = ua.transactions.ist[message.via_branch];
      if(!tr) {
        return;
      } else {
        for(idx in ua.transactions.ist) {
          tr = ua.transactions.ist[idx];
          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
            reply(482);
            return false;
          }
        }
      }
    } else {
      tr = ua.transactions.nist[message.via_branch];
      if(!tr) {
        return;
      } else {
        for(idx in ua.transactions.nist) {
          tr = ua.transactions.nist[idx];
          if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
            reply(482);
            return false;
          }
        }
      }
    }
  }
}

// Sanity Check functions for responses
function rfc3261_8_1_3_3() {
  if(message.countHeader('via') > 1) {
    console.warn(LOG_PREFIX +'More than one Via header field present in the response. Dropping the response');
    return false;
  }
}

function rfc3261_18_1_2() {
  var via_host = ua.configuration.via_host;
  if(message.via.host !== via_host) {
    console.warn(LOG_PREFIX +'Via host in the response does not match UA Via host value. Dropping the response');
    return false;
  }
}

function rfc3261_18_3_response() {
  var
    len = JsSIP.Utils.str_utf8_length(message.body),
    contentLength = message.getHeader('content-length');

    if(len < contentLength) {
      console.warn(LOG_PREFIX +'Message body length is lower than the value in Content-Length header field. Dropping the response');
      return false;
    }
}

// Sanity Check functions for requests and responses
function minimumHeaders() {
  var
    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],
    idx = mandatoryHeaders.length;

  while(idx--) {
    if(!message.hasHeader(mandatoryHeaders[idx])) {
      console.warn(LOG_PREFIX +'Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');
      return false;
    }
  }
}

// Reply
function reply(status_code) {
  var to,
    response = "SIP/2.0 " + status_code + " " + JsSIP.C.REASON_PHRASE[status_code] + "\r\n",
    via_length = message.countHeader('via'),
    idx = 0;

  for(idx; idx < via_length; idx++) {
    response += "Via: " + message.getHeader('via', idx) + "\r\n";
  }

  to = message.getHeader('To');

  if(!message.to_tag) {
    to += ';tag=' + JsSIP.Utils.newTag();
  }

  response += "To: " + to + "\r\n";
  response += "From: " + message.getHeader('From') + "\r\n";
  response += "Call-ID: " + message.call_id + "\r\n";
  response += "CSeq: " + message.cseq + " " + message.method + "\r\n";
  response += "\r\n";

  transport.send(response);
}

requests.push(rfc3261_8_2_2_1);
requests.push(rfc3261_16_3_4);
requests.push(rfc3261_18_3_request);
requests.push(rfc3261_8_2_2_2);

responses.push(rfc3261_8_1_3_3);
responses.push(rfc3261_18_1_2);
responses.push(rfc3261_18_3_response);

all.push(minimumHeaders);

sanityCheck = function(m, u, t) {
  var len, pass;

  message = m;
  ua = u;
  transport = t;

  len = all.length;
  while(len--) {
    pass = all[len](message);
    if(pass === false) {
      return false;
    }
  }

  if(message instanceof JsSIP.IncomingRequest) {
    len = requests.length;
    while(len--) {
      pass = requests[len](message);
      if(pass === false) {
        return false;
      }
    }
  }

  else if(message instanceof JsSIP.IncomingResponse) {
    len = responses.length;
    while(len--) {
      pass = responses[len](message);
      if(pass === false) {
        return false;
      }
    }
  }

  //Everything is OK
  return true;
};

JsSIP.sanityCheck = sanityCheck;
}(JsSIP));




/**
 * @fileoverview SIP Digest Authentication
 */

/**
 * SIP Digest Authentication.
 * @augments JsSIP.
 * @function Digest Authentication
 * @param {JsSIP.UA} ua
 */
(function(JsSIP) {
var DigestAuthentication,
  LOG_PREFIX = JsSIP.name +' | '+ 'DIGEST AUTHENTICATION' +' | ';

DigestAuthentication = function(ua) {
  this.username = ua.configuration.authorization_user;
  this.password = ua.configuration.password;
  this.cnonce = null;
  this.nc = 0;
  this.ncHex = '00000000';
  this.response = null;
};


/**
* Performs Digest authentication given a SIP request and the challenge
* received in a response to that request.
* Returns true if credentials were successfully generated, false otherwise.
* 
* @param {JsSIP.OutgoingRequest} request
* @param {Object} challenge
*/
DigestAuthentication.prototype.authenticate = function(request, challenge) {
  // Inspect and validate the challenge.

  this.algorithm = challenge.algorithm;
  this.realm = challenge.realm;
  this.nonce = challenge.nonce;
  this.opaque = challenge.opaque;
  this.stale = challenge.stale;

  if (this.algorithm) {
    if (this.algorithm !== 'MD5') {
      console.warn(LOG_PREFIX + 'challenge with Digest algorithm different than "MD5", authentication aborted');
      return false;
    }
  } else {
    this.algorithm = 'MD5';
  }

  if (! this.realm) {
    console.warn(LOG_PREFIX + 'challenge without Digest realm, authentication aborted');
    return false;
  }

  if (! this.nonce) {
    console.warn(LOG_PREFIX + 'challenge without Digest nonce, authentication aborted');
    return false;
  }

  // 'qop' can contain a list of values (Array). Let's choose just one.
  if (challenge.qop) {
    if (challenge.qop.indexOf('auth') > -1) {
      this.qop = 'auth';
    } else if (challenge.qop.indexOf('auth-int') > -1) {
      this.qop = 'auth-int';
    } else {
      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
      console.warn(LOG_PREFIX + 'challenge without Digest qop different than "auth" or "auth-int", authentication aborted');
      return false;
    }
  } else {
    this.qop = null;
  }

  // Fill other attributes.

  this.method = request.method;
  this.uri = request.ruri;
  this.cnonce = JsSIP.Utils.createRandomToken(12);
  this.nc += 1;
  this.updateNcHex();

  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
  if (this.nc === 4294967296) {
    this.nc = 1;
    this.ncHex = '00000001';
  }

  // Calculate the Digest "response" value.
  this.calculateResponse();

  return true;
};


/**
* Generate Digest 'response' value.
* @private
*/
DigestAuthentication.prototype.calculateResponse = function() {
  var ha1, ha2;

  // HA1 = MD5(A1) = MD5(username:realm:password)
  ha1 = JsSIP.Utils.calculateMD5(this.username + ":" + this.realm + ":" + this.password);

  if (this.qop === 'auth') {
    // HA2 = MD5(A2) = MD5(method:digestURI)
    ha2 = JsSIP.Utils.calculateMD5(this.method + ":" + this.uri);
    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
    this.response = JsSIP.Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);

  } else if (this.qop === 'auth-int') {
    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
    ha2 = JsSIP.Utils.calculateMD5(this.method + ":" + this.uri + ":" + JsSIP.Utils.calculateMD5(this.body ? this.body : ""));
    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
    this.response = JsSIP.Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);

  } else if (this.qop === null) {
    // HA2 = MD5(A2) = MD5(method:digestURI)
    ha2 = JsSIP.Utils.calculateMD5(this.method + ":" + this.uri);
    // response = MD5(HA1:nonce:HA2)
    this.response = JsSIP.Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + ha2);
  }
};


/**
* Return the Proxy-Authorization or WWW-Authorization header value.
*/
DigestAuthentication.prototype.toString = function() {
  var auth_params = [];

  if (! this.response) {
    throw new Error('response field does not exist, cannot generate Authorization header');
  }

  auth_params.push('algorithm=' + this.algorithm);
  auth_params.push('username="' + this.username + '"');
  auth_params.push('realm="' + this.realm + '"');
  auth_params.push('nonce="' + this.nonce + '"');
  auth_params.push('uri="' + this.uri + '"');
  auth_params.push('response="' + this.response + '"');
  if (this.opaque) {
    auth_params.push('opaque="' + this.opaque + '"');
  }
  if (this.qop) {
    auth_params.push('qop=' + this.qop);
    auth_params.push('cnonce="' + this.cnonce + '"');
    auth_params.push('nc=' + this.ncHex);
  }

  return 'Digest ' + auth_params.join(', ');
};


/**
* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
* @private
*/
DigestAuthentication.prototype.updateNcHex = function() {
  var hex = Number(this.nc).toString(16);
  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;
};

JsSIP.DigestAuthentication = DigestAuthentication;
}(JsSIP));


/**
 * @fileoverview WebRTC
 */

(function(JsSIP) {
var WebRTC;

WebRTC = {};

// getUserMedia
if (window.navigator.webkitGetUserMedia) {
  WebRTC.getUserMedia = window.navigator.webkitGetUserMedia.bind(navigator);
}
else if (window.navigator.mozGetUserMedia) {
  WebRTC.getUserMedia = window.navigator.mozGetUserMedia.bind(navigator);
}
else if (window.navigator.getUserMedia) {
  WebRTC.getUserMedia = window.navigator.getUserMedia.bind(navigator);
}

// RTCPeerConnection
if (window.webkitRTCPeerConnection) {
  WebRTC.RTCPeerConnection = window.webkitRTCPeerConnection;
}
else if (window.mozRTCPeerConnection) {
  WebRTC.RTCPeerConnection = window.mozRTCPeerConnection;
}
else if (window.RTCPeerConnection) {
  WebRTC.RTCPeerConnection = window.RTCPeerConnection;
}

// RTCSessionDescription
if (window.webkitRTCSessionDescription) {
  WebRTC.RTCSessionDescription = window.webkitRTCSessionDescription;
}
else if (window.mozRTCSessionDescription) {
  WebRTC.RTCSessionDescription = window.mozRTCSessionDescription;
}
else if (window.RTCSessionDescription) {
  WebRTC.RTCSessionDescription = window.RTCSessionDescription;
}

// New syntax for getting streams in Chrome M26.
if (WebRTC.RTCPeerConnection && WebRTC.RTCPeerConnection.prototype) {
  if (!WebRTC.RTCPeerConnection.prototype.getLocalStreams) {
    WebRTC.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this.localStreams;
    };
    WebRTC.RTCPeerConnection.prototype.getRemoteStreams = function() {
      return this.remoteStreams;
    };
  }
}

// isSupported attribute.
if (WebRTC.getUserMedia && WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {
  WebRTC.isSupported = true;
}
else {
  WebRTC.isSupported = false;
}

JsSIP.WebRTC = WebRTC;
}(JsSIP));



/**
 * @fileoverview Refer
 */

/**
 * @param {JsSIP} JsSIP - The JsSIP namespace
 */
(function(JsSIP) {
  var Refer,
    LOG_PREFIX = JsSIP.name +' | '+ 'REFER' +' | ',
    DEFAULT_EXPIRES = 3 * 60 * 1000;

  /**
   * @class Class representing an out-of-dialog SIP REFER request.
   * @augments EventEmitter
   * @param {JsSIP.UA} ua
   */
  Refer = function(ua) {
    var events = [
      'accepted',
      'failed',
      'notify'
    ];

    this.ua = ua;
    this.targetDialog = null;
    this.closed = false;
    this.request = null;
    this.local_tag = null;
    this.remote_tag = null;
    this.id = null;
    this.contact = null;
    this.notify_timer = null;
    this.dialog = null;
    this.subscription_state = 'pending';
    this.subscription_expires = null;
    this.expire_timer = null;
    this.last_notify_body = null;
    this.accepted = false;
    this.rejected = false;

    // Public properties
    this.direction = null;
    this.local_identity = null;
    this.remote_identity = null;
    this.refer_uri = null;

    // Custom Refer empty object for high level use
    this.data = {};

    this.initEvents(events);
  };
  Refer.prototype = new JsSIP.EventEmitter();

  Refer.prototype.send = function(target, refer_uri, options) {
    var request_sender, event, contentType, eventHandlers, extraHeaders, request,
      failCause = null;

    if (target === undefined || refer_uri === undefined) {
      throw new TypeError('Not enough arguments');
    }

    // Get call options
    options = options || {};
    extraHeaders = options.extraHeaders || [];
    eventHandlers = options.eventHandlers || {};
    contentType = options.contentType || 'text/plain';

    // Set event handlers
    for (event in eventHandlers) {
      this.on(event, eventHandlers[event]);
    }

    // Check target validity
    try {
      target = JsSIP.Utils.normalizeURI(target, this.ua.configuration.hostport_params);
    } catch(e) {
      target = JsSIP.URI.parse(JsSIP.C.INVALID_TARGET_URI);
      failCause = JsSIP.C.causes.INVALID_TARGET;
    }

    // Check refer-to validity
    try {
      refer_uri = JsSIP.Utils.normalizeURI(refer_uri, this.ua.configuration.hostport_params);
    } catch(e) {
      refer_uri = JsSIP.URI.parse(JsSIP.C.INVALID_TARGET_URI);
      failCause = JsSIP.C.causes.INVALID_REFER_TO_TARGET;
    }

    // Refer parameter initialization
    this.direction = 'outgoing';
    this.local_identity = this.ua.configuration.uri;
    this.remote_identity = target;
    this.refer_uri = refer_uri;
    this.local_tag = JsSIP.Utils.newTag();
    this.contact = this.ua.contact.toString({outbound: true});

    request = new JsSIP.OutgoingRequest(JsSIP.C.REFER, target, this.ua,
        {from_tag: this.local_tag}, extraHeaders, options.body);
    this.request = request;
    this.id = request.call_id + this.local_tag;

    this.ua.refers[this.id] = this;

    request.setHeader('contact', this.contact);
    request.setHeader('refer-to', refer_uri);

    if (options.targetDialog) {
      this.targetDialog = options.targetDialog;
      request.setHeader('require', JsSIP.C.SIP_EXTENSIONS.TARGET_DIALOG);
      request.setHeader('target-dialog', options.targetDialog.id.toTargetDialogHeader());
    }

    if(options.body) {
      request.setHeader('content-type', contentType);
    }

    request_sender = new JsSIP.RequestSender(this, this.ua);

    this.ua.emit('newRefer', this.ua, {
      originator: 'local',
      refer: this,
      request: this.request
    });

    if (failCause) {
      this.emit('failed', this, {
        originator: 'local',
        cause: failCause
      });
    } else {
      request_sender.send();
      console.log(LOG_PREFIX + this.id + ' sent');
      this.notify_timer = setTimeout(
          this.onNotifyTimeout.bind(this),
          JsSIP.Timers.TIMER_F);
    }
  };

  /**
  * @private
  */
  Refer.prototype.receiveResponse = function(response) {
    var cause;

    if(this.closed) {
      return;
    }
    switch(true) {
      case /^1[0-9]{2}$/.test(response.status_code):
        // Ignore provisional responses.
        break;

      case /^2[0-9]{2}$/.test(response.status_code):
        // The initial NOTIFY creates the dialog, not the 2xx response
        console.log(LOG_PREFIX + this.id + ' accepted');
        this.emit('accepted', this, {
          originator: 'remote',
          response: response
        });
        break;

      default:
        console.log(LOG_PREFIX + this.id + ' rejected (early)');
        this.close();
        cause = JsSIP.Utils.sipErrorCause(response.status_code);
        this.emit('failed', this, {
          originator: 'remote',
          message: response,
          cause: cause
        });
        break;
    }
  };

  /**
   * @private
   */
  Refer.prototype.onRequestTimeout = function() {
    if(this.closed) {
      return;
    }
    console.log(LOG_PREFIX + this.id + ' request timeout');
    this.close();
    this.emit('failed', this, {
      originator: 'system',
      cause: JsSIP.C.causes.REQUEST_TIMEOUT
    });
  };

  /**
   * @private
   */
  Refer.prototype.onTransportError = function() {
    if(this.closed) {
      return;
    }
    console.log(LOG_PREFIX + this.id + ' transport error');
    this.close();
    this.emit('failed', this, {
      originator: 'system',
      cause: JsSIP.C.causes.CONNECTION_ERROR
    });
  };

  /**
   * @private
   */
  Refer.prototype.onNotifyTimeout = function() {
    if (this.closed || this.subscription_state !== 'pending') {
      return;
    }
    console.log(LOG_PREFIX + this.id + ' notify timeout');
    this.emitFinalNotify();
    this.close();
  };

  /**
   * Re-emit the last notify, or a 100 Trying if we never received one.
   * @private
   */
  Refer.prototype.emitFinalNotify = function() {
    var sessionEvent,
      parsed = this.last_notify_body;

    if (!parsed) {
      parsed = JsSIP.Parser.parseMessage('SIP/2.0 100 Trying\r\n', true);
    }
  
    if (parsed.status_code < 200) {
      sessionEvent = 'progress';
    } else if (parsed.status_code < 300) {
      sessionEvent = 'started';
    } else {
      sessionEvent = 'failed';
    }
  
    this.emit('notify', this, {
      originator: 'system',
      request: null,
      sipFrag: parsed,
      sessionEvent: sessionEvent,
      finalNotify: true
    });
  };

  /**
   * @private
   */
  Refer.prototype.close = function() {
    if (this.subscription_state === 'active') {
      console.warn(LOG_PREFIX + this.id + ' closed with active subscription');

      if (this.direction === 'incoming') {
        // Send a NOTIFY that terminates the subscription
        this.notify({
          body: this.last_notify_body,
          finalNotify: true
        });
      } else {
        this.emitFinalNotify();
      }
    }

    if (this.expire_timer !== null) {
      clearTimeout(this.expire_timer);
      this.expire_timer = null;
    }

    if (this.notify_timer !== null) {
      clearTimeout(this.notify_timer);
      this.notify_timer = null;
    }

    // Terminate confirmed dialog
    if (this.dialog) {
      this.dialog.terminate();
      delete this.dialog;
    }

    this.closed = true;
    delete this.ua.refers[this];
    console.log(LOG_PREFIX + this.id + ' closed');
  };

  /**
   * @private
   */
  Refer.prototype.subscriptionExpired = function() {
    if (this.subscription_state === 'terminated') {
      return;
    }

    this.notify({
      body: this.last_notify_body,
      finalNotify: true,
      terminateReason: 'timeout'
    });
    // Don't close the refer in case they re-subscribe as a result of this notify
    this.expire_timer = null;
    console.log(LOG_PREFIX + this.id + ' subscription expired');
  };

  /**
   * @private
   * @param {IncomingRequest} request
   */
  Refer.prototype.init_incoming = function(request) {
    var session = null;

    this.direction = 'incoming';
    this.request = request;
    this.remote_tag = request.from_tag;
    this.id = request.call_id + request.from_tag;
    this.contact = this.ua.contact.toString();
    this.local_identity = request.to.uri;
    this.remote_identity = request.from.uri;

    // Check Refer-To header
    if (!request.hasHeader('refer-to')) {
      request.reply(400, 'Missing Refer-To header field');
      return;
    }
    if (request.countHeader('refer-to') > 1) {
      request.reply(400, 'Too many Refer-To header fields');
      return;
    }
    this.refer_uri = request.parseHeader('refer-to').uri;

    // Process Target-Dialog header (if present)
    if (request.hasHeader('target-dialog')) {
      var td = request.parseHeader('target-dialog');
      // Local/remote labels should be from recipient's perspective
      var did = new JsSIP.DialogId(td.call_id, td.local_tag, td.remote_tag);
      this.targetDialog = this.ua.dialogs[did.toString()] || null;
    }

    if (this.targetDialog && this.targetDialog.isConfirmed()) {
      session = this.targetDialog.owner;
      // Sanity check
      if (session.dialog !== this.targetDialog ||
          !session instanceof JsSIP.RTCSession) {
        session = null;
      }
    }

    // Set the to_tag before replying with a response code that will create a dialog.
    this.local_tag = request.to_tag = JsSIP.Utils.newTag();
    this.dialog = new JsSIP.Dialog(this, request, 'UAS');
    if(!this.dialog.id) {
      request.reply(500, 'Missing Contact header field');
      return;
    }

    this.ua.refers[this.id] = this;

    console.log(LOG_PREFIX + this.id + ' received');
    this.ua.emit('newRefer', this.ua, {
      originator: 'remote',
      refer: this,
      request: request,
      session: session
    });

    if (!this.accepted && !this.rejected) {
      this.accept();
    }
  };

  /**
   * Call the refer URI. The referrer will be notified of the progress and
   * result of the call establishment process.
   *
   * @param {Object} [options]
   * Call options as used with the <code>UA.call</code> method.
   * @returns {JsSIP.RTCSession}
   *
   * @throws {TypeError}
   * @throws {JsSIP.Exceptions.InvalidTargetError}
   */
  Refer.prototype.call = function(options) {
    var session,
      uri = this.refer_uri;

    if (uri.scheme !== JsSIP.C.SIP) {
      throw new JsSIP.Exceptions.InvalidTargetError(uri);
    }

    if (!this.accepted) {
      this.accept();
    }

    session = new JsSIP.RTCSession(this.ua);
    session.connect(uri, options);
    this.addSessionNotifyHandlers(session);

    return session;
  };

  /**
   * Adds handlers to the provided session to send appropriate NOTIFY
   * messages to the referrer.
   * @param {JsSIP.RTCSession} session
   */
  Refer.prototype.addSessionNotifyHandlers = function(session) {
    var self = this;

    session.on('progress', function(event) {
      var response = event.data.response;
      self.notify({
        status_code: response.status_code,
        reason_phrase: response.reason_phrase
      });
    });

    session.once('started', function(event) {
      var response = event.data.response;
      self.notify({
        status_code: response.status_code,
        reason_phrase: response.reason_phrase
      });
      self.close();
    });

    session.once('failed', function(event) {
      var status_code = 500,
        reason_phrase = null,
        message = event.data.message;

      if (message && message instanceof JsSIP.IncomingResponse) {
        status_code = message.status_code;
        reason_phrase = message.reason_phrase;
      }

      self.notify({
        status_code: status_code,
        reason_phrase: reason_phrase
      });
      self.close();
    });
  };

  /**
   * Accept the incoming Refer. Use this for non-SIP refer URIs; for SIP URIs
   * use the <code>call</code> method instead.
   * <p>
   * After calling this method, the application should call the
   * <code>notify</code> method to inform the referrer of the progress/result
   * of the refer. This is handled automatically if the <code>call</code>
   * method is used instead.
   * 
   * @param {Object} [options]
   * @param {String[]} [options.extraHeaders]
   * Extra headers to add to the response.
   * @param {String} [options.body]
   * A message body to include in the response.
   */
  Refer.prototype.accept = function(options) {
    options = options || {};

    var
      extraHeaders = options.extraHeaders || [],
      body = options.body;

    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "accept" for an outgoing refer');
    }

    if (this.closed) {
      return;
    }

    // Set the subscription state and expiry
    this.subscription_state = 'active';
    this.subscription_expires = Date.now() + DEFAULT_EXPIRES;
    this.expire_timer = setTimeout(this.subscriptionExpired.bind(this),
        DEFAULT_EXPIRES);

    extraHeaders.push('Contact: ' + this.contact);

    this.request.reply(202, null, extraHeaders, body);
    // Send initial notify
    this.notify();
    this.accepted = true;
    console.log(LOG_PREFIX + this.id + ' accepted');
  };

  /**
   * Reject the incoming Refer.
   *
   * @param {Object} [options]
   * @param {Number} [options.status_code]
   * @param {String} [options.reason_phrase]
   * @param {String[]} [options.extraHeaders]
   * @param {String} [options.body]
   */
  Refer.prototype.reject = function(options) {
    options = options || {};

    var
      status_code = options.status_code || 603,
      reason_phrase = options.reason_phrase,
      extraHeaders = options.extraHeaders || [],
      body = options.body;

    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "reject" for an outgoing refer');
    }

    if (status_code < 300 || status_code >= 700) {
      throw new TypeError('Invalid status_code: '+ status_code);
    }

    if (this.closed) {
      return;
    }

    if (this.accepted) {
      // Delayed reject (required user input)
      console.log(LOG_PREFIX + this.id + ' rejected (late)');
      this.notify({
        status_code: status_code,
        reason_phrase: reason_phrase
      });
    } else {
      // Immediate reject (policy)
      console.log(LOG_PREFIX + this.id + ' rejected (early)');
      this.request.reply(status_code, reason_phrase, extraHeaders, body);
      this.rejected = true;
    }

    this.close();
  };

  /**
   * Notify the referrer of the current refer progress, or final result.
   * <p>
   * The application should either provide a SIP status code, or a message body
   * of type <code>message/sipfrag</code>. If neither is provided, a
   * <code>100 Trying</code> message will be constructed. If a message body is
   * provided, the <code>finalNotify</code> flag should also be set to indicate
   * whether this is the final NOTIFY message.
   *
   * @param {Object} [options]
   * @param {Number} [options.status_code]
   * @param {String} [options.reason_phrase]
   * @param {String} [options.body]
   * @param {Boolean} [options.finalNotify]
   * @param {String} [options.terminateReason]
   * @param {String[]} [options.extraHeaders]
   */
  Refer.prototype.notify = function(options) {
    var status_code, reason_phrase, finalNotify, newState, reason, stateHeader,
      body, notify,
      self = this;

    if (this.direction !== 'incoming') {
      throw new TypeError('Invalid method "notify" for an outgoing refer');
    }

    options = options || {};
    if (options.body && typeof options.finalNotify === 'undefined') {
      throw new TypeError('Must specify finalNotify when providing notify body');
    }

    if (this.subscription_state !== 'active') {
      // Ignore
      return;
    }

    status_code = options.status_code || 100;
    reason_phrase = options.reason_phrase || JsSIP.C.REASON_PHRASE[status_code] || '';
    finalNotify = options.finalNotify || status_code >= 200;

    if (finalNotify) {
      newState = 'terminated';
      reason = options.terminateReason || 'noresource';
      stateHeader = newState + ';reason=' + reason;
    } else {
      newState = 'active';
      stateHeader = newState + ';expires=' +
          Math.round((this.subscription_expires - Date.now()) / 1000);
    }

    body = options.body || 'SIP/2.0 ' + status_code + ' ' + reason_phrase + '\r\n';
    this.last_notify_body = body;

    notify = new JsSIP.Notify(this);
    notify.send('refer', stateHeader, {
      extraHeaders: options.extraHeaders,
      eventHandlers: options.eventHandlers,
      content_type: 'message/sipfrag',
      body: body
    });

    this.subscription_state = newState;
    if (!finalNotify) {
      // If the notify fails, terminate the subscription
      notify.on('failed', function(){
        self.subscription_state = 'terminated';
        console.log(LOG_PREFIX + self.id + ' unsubscribed (rejected notify)');
        self.close();
      });
    }
  };

  /**
   * Receives further messages on the Refer dialog (i.e. NOTIFYs for outgoing
   * refers, and possibly SUBSCRIBEs for incoming refers).
   * @private
   * @param {IncomingRequest} request
   */
  Refer.prototype.receiveRequest = function(request) {
    switch (request.method) {
    case JsSIP.C.NOTIFY:
      this.receiveNotify(request);
      return;
    case JsSIP.C.SUBSCRIBE:
      this.receiveSubscribe(request);
      return;
    }

    request.reply(405, null, ['Allow: '+ JsSIP.Utils.getAllowedMethods(this.ua)]);
  };

  /**
   * Receives NOTIFY messages on the Refer dialog.
   * @private
   * @param {IncomingRequest} request
   */
  Refer.prototype.receiveNotify = function(request) {
    var eventHeader, stateHeader, typeHeader, parsed, sessionEvent,
      extraHeaders, sipfrag,
      finalNotify = false;

    if (this.direction !== 'outgoing' ||
        (this.subscription_state !== 'active' &&
            this.subscription_state !== 'pending')) {
      request.reply(481, 'Subscription Does Not Exist');
      return;
    }

    eventHeader = request.parseHeader('event');
    if (!eventHeader || eventHeader.event !== 'refer') {
      request.reply(489);
      this.close();
      return;
    }

    stateHeader = request.parseHeader('subscription-state');
    if (!stateHeader) {
      request.reply(400, 'Missing Subscription-State Header');
      this.close();
      return;
    }

    typeHeader = request.getHeader('content-type');
    if (typeHeader && typeHeader.indexOf('message/sipfrag') < 0) {
      request.reply(415);
      this.close();
      return;
    }

    sipfrag = request.body;
    if (!/\r\n$/.test(sipfrag)) {
      // Strictly this is an invalid sipfrag, but fudge it by appending the
      // expected end-line characters.
      sipfrag += '\r\n';
    }

    parsed = JsSIP.Parser.parseMessage(sipfrag, true);
    if (!parsed || !parsed instanceof JsSIP.IncomingResponse) {
      request.reply(400, 'Bad Message Body');
      this.close();
      return;
    }

    if (this.listeners('notify').length === 0) {
      console.log(LOG_PREFIX + this.id + ' no notify listeners; unsubscribing');
      request.reply(603);
      this.subscription_state = 'terminated';
      this.close();
      return;
    }

    if (!this.dialog) {
      // Form a dialog based on this request
      this.remote_tag = request.from_tag;
      this.dialog = new JsSIP.Dialog(this, request, 'UAS');

      if (!this.dialog.id) {
        // Probably missing the Contact header
        console.warn(LOG_PREFIX + this.id + ' dialog creation failed');
        this.close();

        this.emit('failed', this, {
          originator: 'remote',
          message: request,
          cause: JsSIP.C.causes.INTERNAL_ERROR
        });
        return;
      }
    }

    this.subscription_state = stateHeader.state;
    this.subscription_expires = Date.now() + stateHeader.expires * 1000;
    this.last_notify_body = parsed;
    if (this.notify_timer !== null) {
      clearTimeout(this.notify_timer);
      this.notify_timer = null;
    }
    if (this.expire_timer !== null) {
      clearTimeout(this.expire_timer);
      this.expire_timer = null;
    }

    extraHeaders = ['Contact: ' + this.contact];
    request.reply(200, null, extraHeaders);

    if (parsed.status_code < 200) {
      sessionEvent = 'progress';
    } else if (parsed.status_code < 300) {
      sessionEvent = 'started';
    } else {
      sessionEvent = 'failed';
    }

    console.log(LOG_PREFIX + this.id + ' notify: ' + sessionEvent);

    if (this.subscription_state === 'terminated') {
      finalNotify = true;
      this.close();
    } else {
      this.expire_timer = setTimeout(this.close.bind(this),
          (stateHeader.expires + JsSIP.Timers.T4) * 1000);
    }

    this.emit('notify', this, {
      originator: 'remote',
      request: request,
      sipFrag: parsed,
      sessionEvent: sessionEvent,
      finalNotify: finalNotify
    });
  };

  /**
   * Receives SUBSCRIBE messages on the Refer dialog.
   * @private
   * @param {IncomingRequest} request
   */
  Refer.prototype.receiveSubscribe = function(request) {
    var eventHeader, expires, extraHeaders;

    if (this.direction !== 'incoming') {
      request.reply(481);
      return;
    }

    if (this.subscription_state !== 'active' &&
        this.subscription_state !== 'terminated') {
      request.reply(403);
      return;
    }

    eventHeader = request.parseHeader('event');
    if (!eventHeader || eventHeader.event !== 'refer') {
      request.reply(489);
      return;
    }

    expires = request.parseHeader('expires');
    if (expires === 0) {
      console.log(LOG_PREFIX + this.id + ' unsubscribed (expires=0)');
      // Remote party is unsubscribing, send a final notify
      this.notify({
        body: this.last_notify_body,
        finalNotify: true
      });
      extraHeaders = [
        'Contact: ' + this.contact
      ];
      request.reply(200, null, extraHeaders);
      this.close();
      return;
    }

    if (expires > 0) {
      expires = expires * 1000;
    } else {
      expires = DEFAULT_EXPIRES;
    }

    this.subscription_state = 'active';
    this.subscription_expires = Date.now() + expires;
    if (this.expire_timer !== null) {
      clearTimeout(this.expire_timer);
    }
    this.expire_timer = setTimeout(this.subscriptionExpired.bind(this), expires);

    extraHeaders = [
      'Contact: ' + this.contact,
      'Expires: ' + expires / 1000
    ];
    request.reply(200, null, extraHeaders);
    console.log(LOG_PREFIX + this.id + ' subscription extended');
  };

  JsSIP.Refer = Refer;
}(JsSIP));



/**
 * @fileoverview Notify
 */

/**
 * @param {JsSIP} JsSIP - The JsSIP namespace
 */
(function(JsSIP) {
  
  var Notify;
  
  /**
   * @class Notify
   * @alias JsSIP.Notify
   * @param {JsSIP.Refer} session
   */
  Notify = function(session) {
    var events = [
    'succeeded',
    'failed'
    ];
  
    // Not a session, actually a REFER or SUBSCRIBE, but kept this name to avoid
    // breaking InDialogRequestSender.
    this.session = session;
    this.direction = null;
    this.request = null;
  
    this.initEvents(events);
  };
  Notify.prototype = new JsSIP.EventEmitter();
  
  
  Notify.prototype.send = function(event, state, options) {
    var request_sender, handled_event, eventHandlers, extraHeaders, request;
  
    this.direction = 'outgoing';
  
    // Check subscription state
    if (this.session.subscription_state !== 'active' &&
        this.session.subscription_state !== 'pending') {
      throw new JsSIP.Exceptions.InvalidStateError(this.session.subscription_state);
    }
  
    // Get Notify options
    options = options || {};
    extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
    eventHandlers = options.eventHandlers || {};
  
    // Set event handlers
    for (handled_event in eventHandlers) {
      this.on(handled_event, eventHandlers[handled_event]);
    }
  
    request = this.session.dialog.createRequest(JsSIP.C.NOTIFY, extraHeaders);
    this.request = request;
  
    request.setHeader('contact', this.session.contact);
    request.setHeader('event', event);
    request.setHeader('subscription-state', state);

    if (options.content_type) {
      request.setHeader('content-type', options.content_type);
    }
    if (options.body) {
      request.body = options.body;
    }
  
    // Don't use InDialogRequestSender, as we don't need the special 408/481
    // response handling - any error terminates the subscribe dialog.
    request_sender = new JsSIP.RequestSender(this, this.session.ua);
  
    this.session.emit('notify', this.session, {
      originator: 'local',
      notify: this,
      request: request
    });
  
    request_sender.send();
  };
  
  /**
   * @private
   */
  Notify.prototype.receiveResponse = function(response) {
    var cause;
  
    // Double-check that the session has not been terminated
    if (this.session.subscription_state === 'terminated') {
      return;
    }

    switch(true) {
      case /^1[0-9]{2}$/.test(response.status_code):
        // Ignore provisional responses.
        break;
  
      case /^2[0-9]{2}$/.test(response.status_code):
        this.emit('succeeded', this, {
          originator: 'remote',
          response: response
        });
        break;
  
      default:
        cause = JsSIP.Utils.sipErrorCause(response.status_code);
        this.emit('failed', this, {
          originator: 'remote',
          response: response,
          cause: cause
        });
        break;
    }
  };
  
  /**
   * @private
   */
  Notify.prototype.onRequestTimeout = function() {
    this.emit('failed', this, {
      originator: 'system',
      cause: JsSIP.C.causes.REQUEST_TIMEOUT
    });
  };
  
  /**
   * @private
   */
  Notify.prototype.onTransportError = function() {
    this.emit('failed', this, {
      originator: 'system',
      cause: JsSIP.C.causes.CONNECTION_ERROR
    });
  };
  
  JsSIP.Notify = Notify;
}(JsSIP));



window.JsSIP = JsSIP;
}(window));


JsSIP.Grammar = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "CRLF": parse_CRLF,
        "DIGIT": parse_DIGIT,
        "ALPHA": parse_ALPHA,
        "HEXDIG": parse_HEXDIG,
        "WSP": parse_WSP,
        "OCTET": parse_OCTET,
        "DQUOTE": parse_DQUOTE,
        "SP": parse_SP,
        "HTAB": parse_HTAB,
        "alphanum": parse_alphanum,
        "reserved": parse_reserved,
        "unreserved": parse_unreserved,
        "mark": parse_mark,
        "escaped": parse_escaped,
        "LWS": parse_LWS,
        "SWS": parse_SWS,
        "HCOLON": parse_HCOLON,
        "TEXT_UTF8_TRIM": parse_TEXT_UTF8_TRIM,
        "TEXT_UTF8char": parse_TEXT_UTF8char,
        "UTF8_NONASCII": parse_UTF8_NONASCII,
        "UTF8_CONT": parse_UTF8_CONT,
        "LHEX": parse_LHEX,
        "token": parse_token,
        "token_nodot": parse_token_nodot,
        "separators": parse_separators,
        "word": parse_word,
        "STAR": parse_STAR,
        "SLASH": parse_SLASH,
        "EQUAL": parse_EQUAL,
        "LPAREN": parse_LPAREN,
        "RPAREN": parse_RPAREN,
        "RAQUOT": parse_RAQUOT,
        "LAQUOT": parse_LAQUOT,
        "COMMA": parse_COMMA,
        "SEMI": parse_SEMI,
        "COLON": parse_COLON,
        "LDQUOT": parse_LDQUOT,
        "RDQUOT": parse_RDQUOT,
        "comment": parse_comment,
        "ctext": parse_ctext,
        "quoted_string": parse_quoted_string,
        "quoted_string_clean": parse_quoted_string_clean,
        "qdtext": parse_qdtext,
        "quoted_pair": parse_quoted_pair,
        "SIP_URI_noparams": parse_SIP_URI_noparams,
        "SIP_URI": parse_SIP_URI,
        "uri_scheme": parse_uri_scheme,
        "userinfo": parse_userinfo,
        "user": parse_user,
        "user_unreserved": parse_user_unreserved,
        "password": parse_password,
        "hostport": parse_hostport,
        "host": parse_host,
        "hostname": parse_hostname,
        "domainlabel": parse_domainlabel,
        "toplabel": parse_toplabel,
        "IPv6reference": parse_IPv6reference,
        "IPv6address": parse_IPv6address,
        "h16": parse_h16,
        "ls32": parse_ls32,
        "IPv4address": parse_IPv4address,
        "dec_octet": parse_dec_octet,
        "port": parse_port,
        "uri_parameters": parse_uri_parameters,
        "uri_parameter": parse_uri_parameter,
        "transport_param": parse_transport_param,
        "user_param": parse_user_param,
        "method_param": parse_method_param,
        "ttl_param": parse_ttl_param,
        "maddr_param": parse_maddr_param,
        "lr_param": parse_lr_param,
        "other_param": parse_other_param,
        "pname": parse_pname,
        "pvalue": parse_pvalue,
        "paramchar": parse_paramchar,
        "param_unreserved": parse_param_unreserved,
        "headers": parse_headers,
        "header": parse_header,
        "hname": parse_hname,
        "hvalue": parse_hvalue,
        "hnv_unreserved": parse_hnv_unreserved,
        "Request_Response": parse_Request_Response,
        "Request_Line": parse_Request_Line,
        "Request_URI": parse_Request_URI,
        "absoluteURI": parse_absoluteURI,
        "hier_part": parse_hier_part,
        "net_path": parse_net_path,
        "abs_path": parse_abs_path,
        "opaque_part": parse_opaque_part,
        "uric": parse_uric,
        "uric_no_slash": parse_uric_no_slash,
        "path_segments": parse_path_segments,
        "segment": parse_segment,
        "param": parse_param,
        "pchar": parse_pchar,
        "scheme": parse_scheme,
        "authority": parse_authority,
        "srvr": parse_srvr,
        "reg_name": parse_reg_name,
        "query": parse_query,
        "SIP_Version": parse_SIP_Version,
        "INVITEm": parse_INVITEm,
        "ACKm": parse_ACKm,
        "OPTIONSm": parse_OPTIONSm,
        "BYEm": parse_BYEm,
        "CANCELm": parse_CANCELm,
        "REGISTERm": parse_REGISTERm,
        "SUBSCRIBEm": parse_SUBSCRIBEm,
        "NOTIFYm": parse_NOTIFYm,
        "Method": parse_Method,
        "Status_Line": parse_Status_Line,
        "Status_Code": parse_Status_Code,
        "extension_code": parse_extension_code,
        "Reason_Phrase": parse_Reason_Phrase,
        "Allow": parse_Allow,
        "allow_method": parse_allow_method,
        "Allow_Events": parse_Allow_Events,
        "Call_ID": parse_Call_ID,
        "call_id": parse_call_id,
        "Contact": parse_Contact,
        "contact_param": parse_contact_param,
        "name_addr": parse_name_addr,
        "display_name": parse_display_name,
        "contact_params": parse_contact_params,
        "c_p_q": parse_c_p_q,
        "c_p_expires": parse_c_p_expires,
        "delta_seconds": parse_delta_seconds,
        "qvalue": parse_qvalue,
        "generic_param": parse_generic_param,
        "gen_value": parse_gen_value,
        "Content_Disposition": parse_Content_Disposition,
        "disp_type": parse_disp_type,
        "disp_param": parse_disp_param,
        "handling_param": parse_handling_param,
        "Content_Encoding": parse_Content_Encoding,
        "Content_Length": parse_Content_Length,
        "Content_Type": parse_Content_Type,
        "media_type": parse_media_type,
        "m_type": parse_m_type,
        "discrete_type": parse_discrete_type,
        "composite_type": parse_composite_type,
        "extension_token": parse_extension_token,
        "x_token": parse_x_token,
        "m_subtype": parse_m_subtype,
        "m_parameter": parse_m_parameter,
        "m_value": parse_m_value,
        "CSeq": parse_CSeq,
        "CSeq_value": parse_CSeq_value,
        "Expires": parse_Expires,
        "Event": parse_Event,
        "event_type": parse_event_type,
        "From": parse_From,
        "from_param": parse_from_param,
        "tag_param": parse_tag_param,
        "Max_Forwards": parse_Max_Forwards,
        "Min_Expires": parse_Min_Expires,
        "Min_SE": parse_Min_SE,
        "Name_Addr_Header": parse_Name_Addr_Header,
        "Proxy_Authenticate": parse_Proxy_Authenticate,
        "challenge": parse_challenge,
        "other_challenge": parse_other_challenge,
        "auth_param": parse_auth_param,
        "digest_cln": parse_digest_cln,
        "realm": parse_realm,
        "realm_value": parse_realm_value,
        "domain": parse_domain,
        "URI": parse_URI,
        "nonce": parse_nonce,
        "nonce_value": parse_nonce_value,
        "opaque": parse_opaque,
        "stale": parse_stale,
        "algorithm": parse_algorithm,
        "qop_options": parse_qop_options,
        "qop_value": parse_qop_value,
        "Proxy_Require": parse_Proxy_Require,
        "option_tag": parse_option_tag,
        "Record_Route": parse_Record_Route,
        "rec_route": parse_rec_route,
        "Refer_To": parse_Refer_To,
        "Require": parse_Require,
        "Route": parse_Route,
        "route_param": parse_route_param,
        "Session_Expires": parse_Session_Expires,
        "se_param": parse_se_param,
        "refresher_param": parse_refresher_param,
        "Subscription_State": parse_Subscription_State,
        "substate_value": parse_substate_value,
        "subexp_params": parse_subexp_params,
        "event_reason_value": parse_event_reason_value,
        "Subject": parse_Subject,
        "Supported": parse_Supported,
        "Target_Dialog": parse_Target_Dialog,
        "td_param": parse_td_param,
        "remote_param": parse_remote_param,
        "local_param": parse_local_param,
        "To": parse_To,
        "to_param": parse_to_param,
        "Via": parse_Via,
        "via_parm": parse_via_parm,
        "via_params": parse_via_params,
        "via_ttl": parse_via_ttl,
        "via_maddr": parse_via_maddr,
        "via_received": parse_via_received,
        "via_branch": parse_via_branch,
        "response_port": parse_response_port,
        "sent_protocol": parse_sent_protocol,
        "protocol_name": parse_protocol_name,
        "transport": parse_transport,
        "sent_by": parse_sent_by,
        "via_host": parse_via_host,
        "via_port": parse_via_port,
        "ttl": parse_ttl,
        "WWW_Authenticate": parse_WWW_Authenticate,
        "extension_header": parse_extension_header,
        "header_value": parse_header_value,
        "message_body": parse_message_body,
        "stun_URI": parse_stun_URI,
        "stun_scheme": parse_stun_scheme,
        "stun_host_port": parse_stun_host_port,
        "stun_host": parse_stun_host,
        "reg_name": parse_reg_name,
        "stun_unreserved": parse_stun_unreserved,
        "sub_delims": parse_sub_delims,
        "turn_URI": parse_turn_URI,
        "turn_scheme": parse_turn_scheme,
        "turn_transport": parse_turn_transport,
        "uuid_URI": parse_uuid_URI,
        "uuid": parse_uuid,
        "hex4": parse_hex4,
        "hex8": parse_hex8,
        "hex12": parse_hex12
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "CRLF";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_CRLF() {
        var result0;
        
        if (input.substr(pos, 2) === "\r\n") {
          result0 = "\r\n";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\r\\n\"");
          }
        }
        return result0;
      }
      
      function parse_DIGIT() {
        var result0;
        
        if (/^[0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        return result0;
      }
      
      function parse_ALPHA() {
        var result0;
        
        if (/^[a-zA-Z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z]");
          }
        }
        return result0;
      }
      
      function parse_HEXDIG() {
        var result0;
        
        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9a-fA-F]");
          }
        }
        return result0;
      }
      
      function parse_WSP() {
        var result0;
        
        result0 = parse_SP();
        if (result0 === null) {
          result0 = parse_HTAB();
        }
        return result0;
      }
      
      function parse_OCTET() {
        var result0;
        
        if (/^[\0-\xFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\0-\\xFF]");
          }
        }
        return result0;
      }
      
      function parse_DQUOTE() {
        var result0;
        
        if (/^["]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\"]");
          }
        }
        return result0;
      }
      
      function parse_SP() {
        var result0;
        
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        return result0;
      }
      
      function parse_HTAB() {
        var result0;
        
        if (input.charCodeAt(pos) === 9) {
          result0 = "\t";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\t\"");
          }
        }
        return result0;
      }
      
      function parse_alphanum() {
        var result0;
        
        if (/^[a-zA-Z0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9]");
          }
        }
        return result0;
      }
      
      function parse_reserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 47) {
            result0 = "/";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 63) {
              result0 = "?";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 58) {
                result0 = ":";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 64) {
                  result0 = "@";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"@\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 38) {
                    result0 = "&";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"&\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 61) {
                      result0 = "=";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"=\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result0 = "+";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 36) {
                          result0 = "$";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"$\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 44) {
                            result0 = ",";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\",\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_unreserved() {
        var result0;
        
        result0 = parse_alphanum();
        if (result0 === null) {
          result0 = parse_mark();
        }
        return result0;
      }
      
      function parse_mark() {
        var result0;
        
        if (input.charCodeAt(pos) === 45) {
          result0 = "-";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"-\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 95) {
            result0 = "_";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"_\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 46) {
              result0 = ".";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 33) {
                result0 = "!";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 126) {
                  result0 = "~";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"~\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result0 = "*";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 39) {
                      result0 = "'";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"'\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 40) {
                        result0 = "(";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"(\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 41) {
                          result0 = ")";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\")\"");
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_escaped() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 37) {
          result0 = "%";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"%\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LWS() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        result0 = [];
        result1 = parse_WSP();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WSP();
        }
        if (result0 !== null) {
          result1 = parse_CRLF();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos2;
          }
        } else {
          result0 = null;
          pos = pos2;
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_WSP();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_WSP();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return " "; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SWS() {
        var result0;
        
        result0 = parse_LWS();
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_HCOLON() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_SP();
        if (result1 === null) {
          result1 = parse_HTAB();
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_SP();
          if (result1 === null) {
            result1 = parse_HTAB();
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ':'; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_TEXT_UTF8_TRIM() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_TEXT_UTF8char();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_TEXT_UTF8char();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = [];
          result3 = parse_LWS();
          while (result3 !== null) {
            result2.push(result3);
            result3 = parse_LWS();
          }
          if (result2 !== null) {
            result3 = parse_TEXT_UTF8char();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = [];
            result3 = parse_LWS();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_LWS();
            }
            if (result2 !== null) {
              result3 = parse_TEXT_UTF8char();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_TEXT_UTF8char() {
        var result0;
        
        if (/^[!-~]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[!-~]");
          }
        }
        if (result0 === null) {
          result0 = parse_UTF8_NONASCII();
        }
        return result0;
      }
      
      function parse_UTF8_NONASCII() {
        var result0;
        
        if (/^[\x80-\uFFFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\x80-\\uFFFF]");
          }
        }
        return result0;
      }
      
      function parse_UTF8_CONT() {
        var result0;
        
        if (/^[\x80-\xBF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\x80-\\xBF]");
          }
        }
        return result0;
      }
      
      function parse_LHEX() {
        var result0;
        
        result0 = parse_DIGIT();
        if (result0 === null) {
          if (/^[a-f]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[a-f]");
            }
          }
        }
        return result0;
      }
      
      function parse_token() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 46) {
              result1 = ".";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 33) {
                result1 = "!";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 37) {
                  result1 = "%";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"%\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result1 = "*";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 95) {
                      result1 = "_";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"_\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result1 = "+";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 96) {
                          result1 = "`";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"`\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 39) {
                            result1 = "'";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"'\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 126) {
                              result1 = "~";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"~\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 46) {
                  result1 = ".";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\".\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 33) {
                    result1 = "!";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"!\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 37) {
                      result1 = "%";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"%\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 42) {
                        result1 = "*";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"*\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 95) {
                          result1 = "_";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"_\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 96) {
                              result1 = "`";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"`\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 39) {
                                result1 = "'";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"'\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 126) {
                                  result1 = "~";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"~\"");
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_token_nodot() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 33) {
              result1 = "!";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"!\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 37) {
                result1 = "%";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"%\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 42) {
                  result1 = "*";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"*\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 95) {
                    result1 = "_";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"_\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 43) {
                      result1 = "+";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"+\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 96) {
                        result1 = "`";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"`\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 39) {
                          result1 = "'";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"'\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 126) {
                            result1 = "~";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"~\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 33) {
                  result1 = "!";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"!\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 37) {
                    result1 = "%";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"%\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 42) {
                      result1 = "*";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"*\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 95) {
                        result1 = "_";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"_\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 43) {
                          result1 = "+";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"+\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 96) {
                            result1 = "`";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"`\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 39) {
                              result1 = "'";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"'\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 126) {
                                result1 = "~";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"~\"");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_separators() {
        var result0;
        
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 41) {
            result0 = ")";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 60) {
              result0 = "<";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"<\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 62) {
                result0 = ">";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\">\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 64) {
                  result0 = "@";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"@\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 44) {
                    result0 = ",";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 59) {
                      result0 = ";";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\";\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 58) {
                        result0 = ":";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 92) {
                          result0 = "\\";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\\\\"");
                          }
                        }
                        if (result0 === null) {
                          result0 = parse_DQUOTE();
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 47) {
                              result0 = "/";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"/\"");
                              }
                            }
                            if (result0 === null) {
                              if (input.charCodeAt(pos) === 91) {
                                result0 = "[";
                                pos++;
                              } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"[\"");
                                }
                              }
                              if (result0 === null) {
                                if (input.charCodeAt(pos) === 93) {
                                  result0 = "]";
                                  pos++;
                                } else {
                                  result0 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"]\"");
                                  }
                                }
                                if (result0 === null) {
                                  if (input.charCodeAt(pos) === 63) {
                                    result0 = "?";
                                    pos++;
                                  } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"?\"");
                                    }
                                  }
                                  if (result0 === null) {
                                    if (input.charCodeAt(pos) === 61) {
                                      result0 = "=";
                                      pos++;
                                    } else {
                                      result0 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"=\"");
                                      }
                                    }
                                    if (result0 === null) {
                                      if (input.charCodeAt(pos) === 123) {
                                        result0 = "{";
                                        pos++;
                                      } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"{\"");
                                        }
                                      }
                                      if (result0 === null) {
                                        if (input.charCodeAt(pos) === 125) {
                                          result0 = "}";
                                          pos++;
                                        } else {
                                          result0 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"}\"");
                                          }
                                        }
                                        if (result0 === null) {
                                          result0 = parse_SP();
                                          if (result0 === null) {
                                            result0 = parse_HTAB();
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_word() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 46) {
              result1 = ".";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 33) {
                result1 = "!";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 37) {
                  result1 = "%";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"%\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result1 = "*";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 95) {
                      result1 = "_";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"_\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result1 = "+";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 96) {
                          result1 = "`";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"`\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 39) {
                            result1 = "'";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"'\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 126) {
                              result1 = "~";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"~\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 40) {
                                result1 = "(";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"(\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 41) {
                                  result1 = ")";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\")\"");
                                  }
                                }
                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 60) {
                                    result1 = "<";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"<\"");
                                    }
                                  }
                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 62) {
                                      result1 = ">";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\">\"");
                                      }
                                    }
                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result1 = ":";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result1 === null) {
                                        if (input.charCodeAt(pos) === 92) {
                                          result1 = "\\";
                                          pos++;
                                        } else {
                                          result1 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"\\\\\"");
                                          }
                                        }
                                        if (result1 === null) {
                                          result1 = parse_DQUOTE();
                                          if (result1 === null) {
                                            if (input.charCodeAt(pos) === 47) {
                                              result1 = "/";
                                              pos++;
                                            } else {
                                              result1 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"/\"");
                                              }
                                            }
                                            if (result1 === null) {
                                              if (input.charCodeAt(pos) === 91) {
                                                result1 = "[";
                                                pos++;
                                              } else {
                                                result1 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"[\"");
                                                }
                                              }
                                              if (result1 === null) {
                                                if (input.charCodeAt(pos) === 93) {
                                                  result1 = "]";
                                                  pos++;
                                                } else {
                                                  result1 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\"]\"");
                                                  }
                                                }
                                                if (result1 === null) {
                                                  if (input.charCodeAt(pos) === 63) {
                                                    result1 = "?";
                                                    pos++;
                                                  } else {
                                                    result1 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"?\"");
                                                    }
                                                  }
                                                  if (result1 === null) {
                                                    if (input.charCodeAt(pos) === 123) {
                                                      result1 = "{";
                                                      pos++;
                                                    } else {
                                                      result1 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\"{\"");
                                                      }
                                                    }
                                                    if (result1 === null) {
                                                      if (input.charCodeAt(pos) === 125) {
                                                        result1 = "}";
                                                        pos++;
                                                      } else {
                                                        result1 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed("\"}\"");
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 46) {
                  result1 = ".";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\".\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 33) {
                    result1 = "!";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"!\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 37) {
                      result1 = "%";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"%\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 42) {
                        result1 = "*";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"*\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 95) {
                          result1 = "_";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"_\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 96) {
                              result1 = "`";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"`\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 39) {
                                result1 = "'";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"'\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 126) {
                                  result1 = "~";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"~\"");
                                  }
                                }
                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 40) {
                                    result1 = "(";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"(\"");
                                    }
                                  }
                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 41) {
                                      result1 = ")";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\")\"");
                                      }
                                    }
                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 60) {
                                        result1 = "<";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"<\"");
                                        }
                                      }
                                      if (result1 === null) {
                                        if (input.charCodeAt(pos) === 62) {
                                          result1 = ">";
                                          pos++;
                                        } else {
                                          result1 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\">\"");
                                          }
                                        }
                                        if (result1 === null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result1 = ":";
                                            pos++;
                                          } else {
                                            result1 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result1 === null) {
                                            if (input.charCodeAt(pos) === 92) {
                                              result1 = "\\";
                                              pos++;
                                            } else {
                                              result1 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"\\\\\"");
                                              }
                                            }
                                            if (result1 === null) {
                                              result1 = parse_DQUOTE();
                                              if (result1 === null) {
                                                if (input.charCodeAt(pos) === 47) {
                                                  result1 = "/";
                                                  pos++;
                                                } else {
                                                  result1 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\"/\"");
                                                  }
                                                }
                                                if (result1 === null) {
                                                  if (input.charCodeAt(pos) === 91) {
                                                    result1 = "[";
                                                    pos++;
                                                  } else {
                                                    result1 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"[\"");
                                                    }
                                                  }
                                                  if (result1 === null) {
                                                    if (input.charCodeAt(pos) === 93) {
                                                      result1 = "]";
                                                      pos++;
                                                    } else {
                                                      result1 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\"]\"");
                                                      }
                                                    }
                                                    if (result1 === null) {
                                                      if (input.charCodeAt(pos) === 63) {
                                                        result1 = "?";
                                                        pos++;
                                                      } else {
                                                        result1 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed("\"?\"");
                                                        }
                                                      }
                                                      if (result1 === null) {
                                                        if (input.charCodeAt(pos) === 123) {
                                                          result1 = "{";
                                                          pos++;
                                                        } else {
                                                          result1 = null;
                                                          if (reportFailures === 0) {
                                                            matchFailed("\"{\"");
                                                          }
                                                        }
                                                        if (result1 === null) {
                                                          if (input.charCodeAt(pos) === 125) {
                                                            result1 = "}";
                                                            pos++;
                                                          } else {
                                                            result1 = null;
                                                            if (reportFailures === 0) {
                                                              matchFailed("\"}\"");
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_STAR() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 42) {
            result1 = "*";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"*\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "*"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SLASH() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 47) {
            result1 = "/";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "/"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_EQUAL() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LPAREN() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 40) {
            result1 = "(";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "("; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RPAREN() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 41) {
            result1 = ")";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ")"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RAQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 62) {
          result0 = ">";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\">\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_SWS();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ">"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LAQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 60) {
            result1 = "<";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"<\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "<"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_COMMA() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ","; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SEMI() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_COLON() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ":"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LDQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "\""; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RDQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DQUOTE();
        if (result0 !== null) {
          result1 = parse_SWS();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "\""; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comment() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_LPAREN();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_ctext();
          if (result2 === null) {
            result2 = parse_quoted_pair();
            if (result2 === null) {
              result2 = parse_comment();
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ctext();
            if (result2 === null) {
              result2 = parse_quoted_pair();
              if (result2 === null) {
                result2 = parse_comment();
              }
            }
          }
          if (result1 !== null) {
            result2 = parse_RPAREN();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ctext() {
        var result0;
        
        if (/^[!-']/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[!-']");
          }
        }
        if (result0 === null) {
          if (/^[*-[]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[*-[]");
            }
          }
          if (result0 === null) {
            if (/^[\]-~]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[\\]-~]");
              }
            }
            if (result0 === null) {
              result0 = parse_UTF8_NONASCII();
              if (result0 === null) {
                result0 = parse_LWS();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_quoted_string() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_qdtext();
            if (result3 === null) {
              result3 = parse_quoted_pair();
            }
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_qdtext();
              if (result3 === null) {
                result3 = parse_quoted_pair();
              }
            }
            if (result2 !== null) {
              result3 = parse_DQUOTE();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_quoted_string_clean() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_qdtext();
            if (result3 === null) {
              result3 = parse_quoted_pair();
            }
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_qdtext();
              if (result3 === null) {
                result3 = parse_quoted_pair();
              }
            }
            if (result2 !== null) {
              result3 = parse_DQUOTE();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                return input.substring(pos-1, offset+1); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qdtext() {
        var result0;
        
        result0 = parse_LWS();
        if (result0 === null) {
          if (input.charCodeAt(pos) === 33) {
            result0 = "!";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"!\"");
            }
          }
          if (result0 === null) {
            if (/^[#-[]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[#-[]");
              }
            }
            if (result0 === null) {
              if (/^[\]-~]/.test(input.charAt(pos))) {
                result0 = input.charAt(pos);
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\]-~]");
                }
              }
              if (result0 === null) {
                result0 = parse_UTF8_NONASCII();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_quoted_pair() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 92) {
          result0 = "\\";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\\"");
          }
        }
        if (result0 !== null) {
          if (/^[\0-\t]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[\\0-\\t]");
            }
          }
          if (result1 === null) {
            if (/^[\x0B-\f]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[\\x0B-\\f]");
              }
            }
            if (result1 === null) {
              if (/^[\x0E-]/.test(input.charAt(pos))) {
                result1 = input.charAt(pos);
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\x0E-]");
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SIP_URI_noparams() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_uri_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_userinfo();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_hostport();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            try {
                                data.uri = new JsSIP.URI(data.scheme, data.user, data.host, data.port);
                                delete data.scheme;
                                delete data.user;
                                delete data.host;
                                delete data.host_type;
                                delete data.port;
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SIP_URI() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_uri_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_userinfo();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_hostport();
              if (result3 !== null) {
                result4 = parse_uri_parameters();
                if (result4 !== null) {
                  result5 = parse_headers();
                  result5 = result5 !== null ? result5 : "";
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            var header;
                            try {
                                data.uri = new JsSIP.URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);
                                delete data.scheme;
                                delete data.user;
                                delete data.host;
                                delete data.host_type;
                                delete data.port;
                                delete data.uri_params;
        
                                if (startRule === 'SIP_URI') { data = data.uri;}
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uri_scheme() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"sip\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, uri_scheme) {
                            data.scheme = uri_scheme.toLowerCase(); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_userinfo() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_user();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_password();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 64) {
              result2 = "@";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"@\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.user = window.decodeURIComponent(input.substring(pos-1, offset));})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_user() {
        var result0, result1;
        
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            result1 = parse_user_unreserved();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                result1 = parse_user_unreserved();
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_user_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 38) {
          result0 = "&";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"&\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 61) {
            result0 = "=";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 43) {
              result0 = "+";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"+\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 36) {
                result0 = "$";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"$\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 44) {
                  result0 = ",";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 59) {
                    result0 = ";";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\";\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 63) {
                      result0 = "?";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"?\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 47) {
                        result0 = "/";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"/\"");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_password() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            if (input.charCodeAt(pos) === 38) {
              result1 = "&";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 61) {
                result1 = "=";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 43) {
                  result1 = "+";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"+\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 36) {
                    result1 = "$";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"$\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 44) {
                      result1 = ",";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\",\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 38) {
                result1 = "&";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"&\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 61) {
                  result1 = "=";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result1 = "+";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result1 = "$";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 44) {
                        result1 = ",";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\",\"");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.password = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hostport() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_host();
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_hostname();
        if (result0 === null) {
          result0 = parse_IPv4address();
          if (result0 === null) {
            result0 = parse_IPv6reference();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host = input.substring(pos, offset).toLowerCase();
                            return data.host; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hostname() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        pos2 = pos;
        result1 = parse_domainlabel();
        if (result1 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result2 = ".";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result2 !== null) {
            result1 = [result1, result2];
          } else {
            result1 = null;
            pos = pos2;
          }
        } else {
          result1 = null;
          pos = pos2;
        }
        while (result1 !== null) {
          result0.push(result1);
          pos2 = pos;
          result1 = parse_domainlabel();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
        }
        if (result0 !== null) {
          result1 = parse_toplabel();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.host_type = 'domain';
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_domainlabel() {
        var result0, result1;
        
        if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9_\\-]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z0-9_\\-]");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_toplabel() {
        var result0, result1;
        
        if (/^[a-zA-Z_\-]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z_\\-]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z_\-]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z_\\-]");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_IPv6reference() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_IPv6address();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 93) {
              result2 = "]";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"]\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host_type = 'IPv6';
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_IPv6address() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_h16();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_h16();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 58) {
                result3 = ":";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_h16();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result5 = ":";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_h16();
                    if (result6 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result7 = ":";
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result7 !== null) {
                        result8 = parse_h16();
                        if (result8 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result9 = ":";
                            pos++;
                          } else {
                            result9 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result9 !== null) {
                            result10 = parse_h16();
                            if (result10 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result11 = ":";
                                pos++;
                              } else {
                                result11 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result11 !== null) {
                                result12 = parse_ls32();
                                if (result12 !== null) {
                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12];
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          pos1 = pos;
          if (input.substr(pos, 2) === "::") {
            result0 = "::";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"::\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_h16();
            if (result1 !== null) {
              if (input.charCodeAt(pos) === 58) {
                result2 = ":";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result2 !== null) {
                result3 = parse_h16();
                if (result3 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result4 = ":";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result4 !== null) {
                    result5 = parse_h16();
                    if (result5 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result6 = ":";
                        pos++;
                      } else {
                        result6 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result6 !== null) {
                        result7 = parse_h16();
                        if (result7 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result8 = ":";
                            pos++;
                          } else {
                            result8 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result8 !== null) {
                            result9 = parse_h16();
                            if (result9 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result10 = ":";
                                pos++;
                              } else {
                                result10 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result10 !== null) {
                                result11 = parse_ls32();
                                if (result11 !== null) {
                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11];
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 === null) {
            pos1 = pos;
            if (input.substr(pos, 2) === "::") {
              result0 = "::";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"::\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_h16();
              if (result1 !== null) {
                if (input.charCodeAt(pos) === 58) {
                  result2 = ":";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result2 !== null) {
                  result3 = parse_h16();
                  if (result3 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      result4 = ":";
                      pos++;
                    } else {
                      result4 = null;
                      if (reportFailures === 0) {
                        matchFailed("\":\"");
                      }
                    }
                    if (result4 !== null) {
                      result5 = parse_h16();
                      if (result5 !== null) {
                        if (input.charCodeAt(pos) === 58) {
                          result6 = ":";
                          pos++;
                        } else {
                          result6 = null;
                          if (reportFailures === 0) {
                            matchFailed("\":\"");
                          }
                        }
                        if (result6 !== null) {
                          result7 = parse_h16();
                          if (result7 !== null) {
                            if (input.charCodeAt(pos) === 58) {
                              result8 = ":";
                              pos++;
                            } else {
                              result8 = null;
                              if (reportFailures === 0) {
                                matchFailed("\":\"");
                              }
                            }
                            if (result8 !== null) {
                              result9 = parse_ls32();
                              if (result9 !== null) {
                                result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 === null) {
              pos1 = pos;
              if (input.substr(pos, 2) === "::") {
                result0 = "::";
                pos += 2;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"::\"");
                }
              }
              if (result0 !== null) {
                result1 = parse_h16();
                if (result1 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result2 = ":";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result2 !== null) {
                    result3 = parse_h16();
                    if (result3 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result4 = ":";
                        pos++;
                      } else {
                        result4 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result4 !== null) {
                        result5 = parse_h16();
                        if (result5 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result6 = ":";
                            pos++;
                          } else {
                            result6 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result6 !== null) {
                            result7 = parse_ls32();
                            if (result7 !== null) {
                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 === null) {
                pos1 = pos;
                if (input.substr(pos, 2) === "::") {
                  result0 = "::";
                  pos += 2;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"::\"");
                  }
                }
                if (result0 !== null) {
                  result1 = parse_h16();
                  if (result1 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      result2 = ":";
                      pos++;
                    } else {
                      result2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\":\"");
                      }
                    }
                    if (result2 !== null) {
                      result3 = parse_h16();
                      if (result3 !== null) {
                        if (input.charCodeAt(pos) === 58) {
                          result4 = ":";
                          pos++;
                        } else {
                          result4 = null;
                          if (reportFailures === 0) {
                            matchFailed("\":\"");
                          }
                        }
                        if (result4 !== null) {
                          result5 = parse_ls32();
                          if (result5 !== null) {
                            result0 = [result0, result1, result2, result3, result4, result5];
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 === null) {
                  pos1 = pos;
                  if (input.substr(pos, 2) === "::") {
                    result0 = "::";
                    pos += 2;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"::\"");
                    }
                  }
                  if (result0 !== null) {
                    result1 = parse_h16();
                    if (result1 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result2 = ":";
                        pos++;
                      } else {
                        result2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result2 !== null) {
                        result3 = parse_ls32();
                        if (result3 !== null) {
                          result0 = [result0, result1, result2, result3];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                  if (result0 === null) {
                    pos1 = pos;
                    if (input.substr(pos, 2) === "::") {
                      result0 = "::";
                      pos += 2;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"::\"");
                      }
                    }
                    if (result0 !== null) {
                      result1 = parse_ls32();
                      if (result1 !== null) {
                        result0 = [result0, result1];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                    if (result0 === null) {
                      pos1 = pos;
                      if (input.substr(pos, 2) === "::") {
                        result0 = "::";
                        pos += 2;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"::\"");
                        }
                      }
                      if (result0 !== null) {
                        result1 = parse_h16();
                        if (result1 !== null) {
                          result0 = [result0, result1];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                      if (result0 === null) {
                        pos1 = pos;
                        result0 = parse_h16();
                        if (result0 !== null) {
                          if (input.substr(pos, 2) === "::") {
                            result1 = "::";
                            pos += 2;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"::\"");
                            }
                          }
                          if (result1 !== null) {
                            result2 = parse_h16();
                            if (result2 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result3 = ":";
                                pos++;
                              } else {
                                result3 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result3 !== null) {
                                result4 = parse_h16();
                                if (result4 !== null) {
                                  if (input.charCodeAt(pos) === 58) {
                                    result5 = ":";
                                    pos++;
                                  } else {
                                    result5 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result5 !== null) {
                                    result6 = parse_h16();
                                    if (result6 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result7 = ":";
                                        pos++;
                                      } else {
                                        result7 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result7 !== null) {
                                        result8 = parse_h16();
                                        if (result8 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result9 = ":";
                                            pos++;
                                          } else {
                                            result9 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result9 !== null) {
                                            result10 = parse_ls32();
                                            if (result10 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                        if (result0 === null) {
                          pos1 = pos;
                          result0 = parse_h16();
                          if (result0 !== null) {
                            pos2 = pos;
                            if (input.charCodeAt(pos) === 58) {
                              result1 = ":";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\":\"");
                              }
                            }
                            if (result1 !== null) {
                              result2 = parse_h16();
                              if (result2 !== null) {
                                result1 = [result1, result2];
                              } else {
                                result1 = null;
                                pos = pos2;
                              }
                            } else {
                              result1 = null;
                              pos = pos2;
                            }
                            result1 = result1 !== null ? result1 : "";
                            if (result1 !== null) {
                              if (input.substr(pos, 2) === "::") {
                                result2 = "::";
                                pos += 2;
                              } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"::\"");
                                }
                              }
                              if (result2 !== null) {
                                result3 = parse_h16();
                                if (result3 !== null) {
                                  if (input.charCodeAt(pos) === 58) {
                                    result4 = ":";
                                    pos++;
                                  } else {
                                    result4 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result4 !== null) {
                                    result5 = parse_h16();
                                    if (result5 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result6 = ":";
                                        pos++;
                                      } else {
                                        result6 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result6 !== null) {
                                        result7 = parse_h16();
                                        if (result7 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result8 = ":";
                                            pos++;
                                          } else {
                                            result8 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result8 !== null) {
                                            result9 = parse_ls32();
                                            if (result9 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                          if (result0 === null) {
                            pos1 = pos;
                            result0 = parse_h16();
                            if (result0 !== null) {
                              pos2 = pos;
                              if (input.charCodeAt(pos) === 58) {
                                result1 = ":";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result1 !== null) {
                                result2 = parse_h16();
                                if (result2 !== null) {
                                  result1 = [result1, result2];
                                } else {
                                  result1 = null;
                                  pos = pos2;
                                }
                              } else {
                                result1 = null;
                                pos = pos2;
                              }
                              result1 = result1 !== null ? result1 : "";
                              if (result1 !== null) {
                                pos2 = pos;
                                if (input.charCodeAt(pos) === 58) {
                                  result2 = ":";
                                  pos++;
                                } else {
                                  result2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\":\"");
                                  }
                                }
                                if (result2 !== null) {
                                  result3 = parse_h16();
                                  if (result3 !== null) {
                                    result2 = [result2, result3];
                                  } else {
                                    result2 = null;
                                    pos = pos2;
                                  }
                                } else {
                                  result2 = null;
                                  pos = pos2;
                                }
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                  if (input.substr(pos, 2) === "::") {
                                    result3 = "::";
                                    pos += 2;
                                  } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"::\"");
                                    }
                                  }
                                  if (result3 !== null) {
                                    result4 = parse_h16();
                                    if (result4 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result5 = ":";
                                        pos++;
                                      } else {
                                        result5 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result5 !== null) {
                                        result6 = parse_h16();
                                        if (result6 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result7 = ":";
                                            pos++;
                                          } else {
                                            result7 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result7 !== null) {
                                            result8 = parse_ls32();
                                            if (result8 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                            if (result0 === null) {
                              pos1 = pos;
                              result0 = parse_h16();
                              if (result0 !== null) {
                                pos2 = pos;
                                if (input.charCodeAt(pos) === 58) {
                                  result1 = ":";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\":\"");
                                  }
                                }
                                if (result1 !== null) {
                                  result2 = parse_h16();
                                  if (result2 !== null) {
                                    result1 = [result1, result2];
                                  } else {
                                    result1 = null;
                                    pos = pos2;
                                  }
                                } else {
                                  result1 = null;
                                  pos = pos2;
                                }
                                result1 = result1 !== null ? result1 : "";
                                if (result1 !== null) {
                                  pos2 = pos;
                                  if (input.charCodeAt(pos) === 58) {
                                    result2 = ":";
                                    pos++;
                                  } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result2 !== null) {
                                    result3 = parse_h16();
                                    if (result3 !== null) {
                                      result2 = [result2, result3];
                                    } else {
                                      result2 = null;
                                      pos = pos2;
                                    }
                                  } else {
                                    result2 = null;
                                    pos = pos2;
                                  }
                                  result2 = result2 !== null ? result2 : "";
                                  if (result2 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result3 = ":";
                                      pos++;
                                    } else {
                                      result3 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result3 !== null) {
                                      result4 = parse_h16();
                                      if (result4 !== null) {
                                        result3 = [result3, result4];
                                      } else {
                                        result3 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result3 = null;
                                      pos = pos2;
                                    }
                                    result3 = result3 !== null ? result3 : "";
                                    if (result3 !== null) {
                                      if (input.substr(pos, 2) === "::") {
                                        result4 = "::";
                                        pos += 2;
                                      } else {
                                        result4 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"::\"");
                                        }
                                      }
                                      if (result4 !== null) {
                                        result5 = parse_h16();
                                        if (result5 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result6 = ":";
                                            pos++;
                                          } else {
                                            result6 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result6 !== null) {
                                            result7 = parse_ls32();
                                            if (result7 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                              if (result0 === null) {
                                pos1 = pos;
                                result0 = parse_h16();
                                if (result0 !== null) {
                                  pos2 = pos;
                                  if (input.charCodeAt(pos) === 58) {
                                    result1 = ":";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result1 !== null) {
                                    result2 = parse_h16();
                                    if (result2 !== null) {
                                      result1 = [result1, result2];
                                    } else {
                                      result1 = null;
                                      pos = pos2;
                                    }
                                  } else {
                                    result1 = null;
                                    pos = pos2;
                                  }
                                  result1 = result1 !== null ? result1 : "";
                                  if (result1 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result2 = ":";
                                      pos++;
                                    } else {
                                      result2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result2 !== null) {
                                      result3 = parse_h16();
                                      if (result3 !== null) {
                                        result2 = [result2, result3];
                                      } else {
                                        result2 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result2 = null;
                                      pos = pos2;
                                    }
                                    result2 = result2 !== null ? result2 : "";
                                    if (result2 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result3 = ":";
                                        pos++;
                                      } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result3 !== null) {
                                        result4 = parse_h16();
                                        if (result4 !== null) {
                                          result3 = [result3, result4];
                                        } else {
                                          result3 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result3 = null;
                                        pos = pos2;
                                      }
                                      result3 = result3 !== null ? result3 : "";
                                      if (result3 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result4 = ":";
                                          pos++;
                                        } else {
                                          result4 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result4 !== null) {
                                          result5 = parse_h16();
                                          if (result5 !== null) {
                                            result4 = [result4, result5];
                                          } else {
                                            result4 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result4 = null;
                                          pos = pos2;
                                        }
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                          if (input.substr(pos, 2) === "::") {
                                            result5 = "::";
                                            pos += 2;
                                          } else {
                                            result5 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\"::\"");
                                            }
                                          }
                                          if (result5 !== null) {
                                            result6 = parse_ls32();
                                            if (result6 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                                if (result0 === null) {
                                  pos1 = pos;
                                  result0 = parse_h16();
                                  if (result0 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result1 = ":";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result1 !== null) {
                                      result2 = parse_h16();
                                      if (result2 !== null) {
                                        result1 = [result1, result2];
                                      } else {
                                        result1 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result1 = null;
                                      pos = pos2;
                                    }
                                    result1 = result1 !== null ? result1 : "";
                                    if (result1 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result2 = ":";
                                        pos++;
                                      } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result2 !== null) {
                                        result3 = parse_h16();
                                        if (result3 !== null) {
                                          result2 = [result2, result3];
                                        } else {
                                          result2 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result2 = null;
                                        pos = pos2;
                                      }
                                      result2 = result2 !== null ? result2 : "";
                                      if (result2 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result3 = ":";
                                          pos++;
                                        } else {
                                          result3 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result3 !== null) {
                                          result4 = parse_h16();
                                          if (result4 !== null) {
                                            result3 = [result3, result4];
                                          } else {
                                            result3 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result3 = null;
                                          pos = pos2;
                                        }
                                        result3 = result3 !== null ? result3 : "";
                                        if (result3 !== null) {
                                          pos2 = pos;
                                          if (input.charCodeAt(pos) === 58) {
                                            result4 = ":";
                                            pos++;
                                          } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result4 !== null) {
                                            result5 = parse_h16();
                                            if (result5 !== null) {
                                              result4 = [result4, result5];
                                            } else {
                                              result4 = null;
                                              pos = pos2;
                                            }
                                          } else {
                                            result4 = null;
                                            pos = pos2;
                                          }
                                          result4 = result4 !== null ? result4 : "";
                                          if (result4 !== null) {
                                            pos2 = pos;
                                            if (input.charCodeAt(pos) === 58) {
                                              result5 = ":";
                                              pos++;
                                            } else {
                                              result5 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\":\"");
                                              }
                                            }
                                            if (result5 !== null) {
                                              result6 = parse_h16();
                                              if (result6 !== null) {
                                                result5 = [result5, result6];
                                              } else {
                                                result5 = null;
                                                pos = pos2;
                                              }
                                            } else {
                                              result5 = null;
                                              pos = pos2;
                                            }
                                            result5 = result5 !== null ? result5 : "";
                                            if (result5 !== null) {
                                              if (input.substr(pos, 2) === "::") {
                                                result6 = "::";
                                                pos += 2;
                                              } else {
                                                result6 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"::\"");
                                                }
                                              }
                                              if (result6 !== null) {
                                                result7 = parse_h16();
                                                if (result7 !== null) {
                                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                  if (result0 === null) {
                                    pos1 = pos;
                                    result0 = parse_h16();
                                    if (result0 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result1 = ":";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result1 !== null) {
                                        result2 = parse_h16();
                                        if (result2 !== null) {
                                          result1 = [result1, result2];
                                        } else {
                                          result1 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result1 = null;
                                        pos = pos2;
                                      }
                                      result1 = result1 !== null ? result1 : "";
                                      if (result1 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result2 = ":";
                                          pos++;
                                        } else {
                                          result2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result2 !== null) {
                                          result3 = parse_h16();
                                          if (result3 !== null) {
                                            result2 = [result2, result3];
                                          } else {
                                            result2 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result2 = null;
                                          pos = pos2;
                                        }
                                        result2 = result2 !== null ? result2 : "";
                                        if (result2 !== null) {
                                          pos2 = pos;
                                          if (input.charCodeAt(pos) === 58) {
                                            result3 = ":";
                                            pos++;
                                          } else {
                                            result3 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result3 !== null) {
                                            result4 = parse_h16();
                                            if (result4 !== null) {
                                              result3 = [result3, result4];
                                            } else {
                                              result3 = null;
                                              pos = pos2;
                                            }
                                          } else {
                                            result3 = null;
                                            pos = pos2;
                                          }
                                          result3 = result3 !== null ? result3 : "";
                                          if (result3 !== null) {
                                            pos2 = pos;
                                            if (input.charCodeAt(pos) === 58) {
                                              result4 = ":";
                                              pos++;
                                            } else {
                                              result4 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\":\"");
                                              }
                                            }
                                            if (result4 !== null) {
                                              result5 = parse_h16();
                                              if (result5 !== null) {
                                                result4 = [result4, result5];
                                              } else {
                                                result4 = null;
                                                pos = pos2;
                                              }
                                            } else {
                                              result4 = null;
                                              pos = pos2;
                                            }
                                            result4 = result4 !== null ? result4 : "";
                                            if (result4 !== null) {
                                              pos2 = pos;
                                              if (input.charCodeAt(pos) === 58) {
                                                result5 = ":";
                                                pos++;
                                              } else {
                                                result5 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\":\"");
                                                }
                                              }
                                              if (result5 !== null) {
                                                result6 = parse_h16();
                                                if (result6 !== null) {
                                                  result5 = [result5, result6];
                                                } else {
                                                  result5 = null;
                                                  pos = pos2;
                                                }
                                              } else {
                                                result5 = null;
                                                pos = pos2;
                                              }
                                              result5 = result5 !== null ? result5 : "";
                                              if (result5 !== null) {
                                                pos2 = pos;
                                                if (input.charCodeAt(pos) === 58) {
                                                  result6 = ":";
                                                  pos++;
                                                } else {
                                                  result6 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\":\"");
                                                  }
                                                }
                                                if (result6 !== null) {
                                                  result7 = parse_h16();
                                                  if (result7 !== null) {
                                                    result6 = [result6, result7];
                                                  } else {
                                                    result6 = null;
                                                    pos = pos2;
                                                  }
                                                } else {
                                                  result6 = null;
                                                  pos = pos2;
                                                }
                                                result6 = result6 !== null ? result6 : "";
                                                if (result6 !== null) {
                                                  if (input.substr(pos, 2) === "::") {
                                                    result7 = "::";
                                                    pos += 2;
                                                  } else {
                                                    result7 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"::\"");
                                                    }
                                                  }
                                                  if (result7 !== null) {
                                                    result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                                  } else {
                                                    result0 = null;
                                                    pos = pos1;
                                                  }
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.host_type = 'IPv6';
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_h16() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_HEXDIG();
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_HEXDIG();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ls32() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_h16();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_h16();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_IPv4address();
        }
        return result0;
      }
      
      function parse_IPv4address() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_dec_octet();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_dec_octet();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 46) {
                result3 = ".";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_dec_octet();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 46) {
                    result5 = ".";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_dec_octet();
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host_type = 'IPv4';
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_dec_octet() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "25") {
          result0 = "25";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"25\"");
          }
        }
        if (result0 !== null) {
          if (/^[0-5]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[0-5]");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 50) {
            result0 = "2";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"2\"");
            }
          }
          if (result0 !== null) {
            if (/^[0-4]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-4]");
              }
            }
            if (result1 !== null) {
              result2 = parse_DIGIT();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.charCodeAt(pos) === 49) {
              result0 = "1";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"1\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_DIGIT();
              if (result1 !== null) {
                result2 = parse_DIGIT();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (/^[1-9]/.test(input.charAt(pos))) {
                result0 = input.charAt(pos);
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("[1-9]");
                }
              }
              if (result0 !== null) {
                result1 = parse_DIGIT();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
              if (result0 === null) {
                result0 = parse_DIGIT();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_port() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, port) {
                            port = parseInt(port.join(''));
                            data.port = port;
                            return port; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uri_parameters() {
        var result0, result1, result2;
        var pos0;
        
        result0 = [];
        pos0 = pos;
        if (input.charCodeAt(pos) === 59) {
          result1 = ";";
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result1 !== null) {
          result2 = parse_uri_parameter();
          if (result2 !== null) {
            result1 = [result1, result2];
          } else {
            result1 = null;
            pos = pos0;
          }
        } else {
          result1 = null;
          pos = pos0;
        }
        while (result1 !== null) {
          result0.push(result1);
          pos0 = pos;
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_uri_parameter();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos0;
            }
          } else {
            result1 = null;
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_uri_parameter() {
        var result0;
        
        result0 = parse_transport_param();
        if (result0 === null) {
          result0 = parse_user_param();
          if (result0 === null) {
            result0 = parse_method_param();
            if (result0 === null) {
              result0 = parse_ttl_param();
              if (result0 === null) {
                result0 = parse_maddr_param();
                if (result0 === null) {
                  result0 = parse_lr_param();
                  if (result0 === null) {
                    result0 = parse_other_param();
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_transport_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 10).toLowerCase() === "transport=") {
          result0 = input.substr(pos, 10);
          pos += 10;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"transport=\"");
          }
        }
        if (result0 !== null) {
          if (input.substr(pos, 3).toLowerCase() === "udp") {
            result1 = input.substr(pos, 3);
            pos += 3;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"udp\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tcp") {
              result1 = input.substr(pos, 3);
              pos += 3;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"tcp\"");
              }
            }
            if (result1 === null) {
              if (input.substr(pos, 4).toLowerCase() === "sctp") {
                result1 = input.substr(pos, 4);
                pos += 4;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"sctp\"");
                }
              }
              if (result1 === null) {
                if (input.substr(pos, 3).toLowerCase() === "tls") {
                  result1 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"tls\"");
                  }
                }
                if (result1 === null) {
                  result1 = parse_token();
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, transport) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['transport'] = transport.toLowerCase(); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_user_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "user=") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"user=\"");
          }
        }
        if (result0 !== null) {
          if (input.substr(pos, 5).toLowerCase() === "phone") {
            result1 = input.substr(pos, 5);
            pos += 5;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"phone\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 2).toLowerCase() === "ip") {
              result1 = input.substr(pos, 2);
              pos += 2;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"ip\"");
              }
            }
            if (result1 === null) {
              result1 = parse_token();
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, user) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['user'] = user.toLowerCase(); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_method_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 7).toLowerCase() === "method=") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"method=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_Method();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, method) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['method'] = method; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ttl_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 4).toLowerCase() === "ttl=") {
          result0 = input.substr(pos, 4);
          pos += 4;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ttl=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_ttl();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, ttl) {
                              if(!data.params) data.params={};
                              data.params['ttl'] = ttl; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_maddr_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "maddr=") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"maddr=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_host();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, maddr) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['maddr'] = maddr; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_lr_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2).toLowerCase() === "lr") {
          result0 = input.substr(pos, 2);
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"lr\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['lr'] = undefined; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_other_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_pname();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_pvalue();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, param, value) {
                              if(!data.uri_params) data.uri_params = {};
                              if (typeof value === 'undefined'){
                                value = undefined;
                              }
                              else {
                                value = value[1];
                              }
                              data.uri_params[param.toLowerCase()] = value && value.toLowerCase();})(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_pname() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_paramchar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_paramchar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, pname) {return pname.join(''); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_pvalue() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_paramchar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_paramchar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, pvalue) {return pvalue.join(''); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_paramchar() {
        var result0;
        
        result0 = parse_param_unreserved();
        if (result0 === null) {
          result0 = parse_unreserved();
          if (result0 === null) {
            result0 = parse_escaped();
          }
        }
        return result0;
      }
      
      function parse_param_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 47) {
              result0 = "/";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 58) {
                result0 = ":";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 38) {
                  result0 = "&";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"&\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result0 = "+";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result0 = "$";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_headers() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 63) {
          result0 = "?";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"?\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_header();
          if (result1 !== null) {
            result2 = [];
            pos1 = pos;
            if (input.charCodeAt(pos) === 38) {
              result3 = "&";
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result3 !== null) {
              result4 = parse_header();
              if (result4 !== null) {
                result3 = [result3, result4];
              } else {
                result3 = null;
                pos = pos1;
              }
            } else {
              result3 = null;
              pos = pos1;
            }
            while (result3 !== null) {
              result2.push(result3);
              pos1 = pos;
              if (input.charCodeAt(pos) === 38) {
                result3 = "&";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"&\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_header();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_header() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_hname();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hvalue();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, hname, hvalue) {
                              hname = hname.join('').toLowerCase();
                              hvalue = hvalue.join('');
                              if(!data.uri_headers) data.uri_headers = {};
                              if (!data.uri_headers[hname]) {
                                data.uri_headers[hname] = [hvalue];
                              } else {
                                data.uri_headers[hname].push(hvalue);
                              }})(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hname() {
        var result0, result1;
        
        result1 = parse_hnv_unreserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_hnv_unreserved();
            if (result1 === null) {
              result1 = parse_unreserved();
              if (result1 === null) {
                result1 = parse_escaped();
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_hvalue() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_hnv_unreserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_hnv_unreserved();
          if (result1 === null) {
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
            }
          }
        }
        return result0;
      }
      
      function parse_hnv_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 47) {
              result0 = "/";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 63) {
                result0 = "?";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 58) {
                  result0 = ":";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result0 = "+";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result0 = "$";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_Request_Response() {
        var result0;
        
        result0 = parse_Status_Line();
        if (result0 === null) {
          result0 = parse_Request_Line();
        }
        return result0;
      }
      
      function parse_Request_Line() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_Method();
        if (result0 !== null) {
          result1 = parse_SP();
          if (result1 !== null) {
            result2 = parse_Request_URI();
            if (result2 !== null) {
              result3 = parse_SP();
              if (result3 !== null) {
                result4 = parse_SIP_Version();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Request_URI() {
        var result0;
        
        result0 = parse_SIP_URI();
        if (result0 === null) {
          result0 = parse_absoluteURI();
        }
        return result0;
      }
      
      function parse_absoluteURI() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hier_part();
            if (result2 === null) {
              result2 = parse_opaque_part();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hier_part() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_net_path();
        if (result0 === null) {
          result0 = parse_abs_path();
        }
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 63) {
            result1 = "?";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"?\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_query();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_net_path() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_authority();
          if (result1 !== null) {
            result2 = parse_abs_path();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_abs_path() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_path_segments();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_opaque_part() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_uric_no_slash();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_uric();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_uric();
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uric() {
        var result0;
        
        result0 = parse_reserved();
        if (result0 === null) {
          result0 = parse_unreserved();
          if (result0 === null) {
            result0 = parse_escaped();
          }
        }
        return result0;
      }
      
      function parse_uric_no_slash() {
        var result0;
        
        result0 = parse_unreserved();
        if (result0 === null) {
          result0 = parse_escaped();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 59) {
              result0 = ";";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\";\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 63) {
                result0 = "?";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 58) {
                  result0 = ":";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 64) {
                    result0 = "@";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"@\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 38) {
                      result0 = "&";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"&\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 61) {
                        result0 = "=";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"=\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 43) {
                          result0 = "+";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"+\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 36) {
                            result0 = "$";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"$\"");
                            }
                          }
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 44) {
                              result0 = ",";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\",\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_path_segments() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_segment();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 47) {
            result2 = "/";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_segment();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 47) {
              result2 = "/";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_segment();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_segment() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_pchar();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_pchar();
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 59) {
            result2 = ";";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 59) {
              result2 = ";";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\";\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_param() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_pchar();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_pchar();
        }
        return result0;
      }
      
      function parse_pchar() {
        var result0;
        
        result0 = parse_unreserved();
        if (result0 === null) {
          result0 = parse_escaped();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 58) {
              result0 = ":";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 64) {
                result0 = "@";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"@\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 38) {
                  result0 = "&";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"&\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 61) {
                    result0 = "=";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"=\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 43) {
                      result0 = "+";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"+\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 36) {
                        result0 = "$";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"$\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 44) {
                          result0 = ",";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_scheme() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ALPHA();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_ALPHA();
          if (result2 === null) {
            result2 = parse_DIGIT();
            if (result2 === null) {
              if (input.charCodeAt(pos) === 43) {
                result2 = "+";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"+\"");
                }
              }
              if (result2 === null) {
                if (input.charCodeAt(pos) === 45) {
                  result2 = "-";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"-\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 46) {
                    result2 = ".";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                }
              }
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ALPHA();
            if (result2 === null) {
              result2 = parse_DIGIT();
              if (result2 === null) {
                if (input.charCodeAt(pos) === 43) {
                  result2 = "+";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"+\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 45) {
                    result2 = "-";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }
                  if (result2 === null) {
                    if (input.charCodeAt(pos) === 46) {
                      result2 = ".";
                      pos++;
                    } else {
                      result2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\".\"");
                      }
                    }
                  }
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.scheme= input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_authority() {
        var result0;
        
        result0 = parse_srvr();
        if (result0 === null) {
          result0 = parse_reg_name();
        }
        return result0;
      }
      
      function parse_srvr() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_userinfo();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 64) {
            result1 = "@";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_hostport();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_reg_name() {
        var result0, result1;
        
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            if (input.charCodeAt(pos) === 36) {
              result1 = "$";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"$\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 44) {
                result1 = ",";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 59) {
                  result1 = ";";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\";\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 64) {
                      result1 = "@";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"@\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 38) {
                        result1 = "&";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"&\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 61) {
                          result1 = "=";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"=\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                if (input.charCodeAt(pos) === 36) {
                  result1 = "$";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"$\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 44) {
                    result1 = ",";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 59) {
                      result1 = ";";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\";\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 58) {
                        result1 = ":";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 64) {
                          result1 = "@";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"@\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 38) {
                            result1 = "&";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"&\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 61) {
                              result1 = "=";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"=\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 43) {
                                result1 = "+";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"+\"");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_query() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_uric();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_uric();
        }
        return result0;
      }
      
      function parse_SIP_Version() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SIP\"");
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 47) {
            result1 = "/";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result1 !== null) {
            result3 = parse_DIGIT();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_DIGIT();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 46) {
                result3 = ".";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result3 !== null) {
                result5 = parse_DIGIT();
                if (result5 !== null) {
                  result4 = [];
                  while (result5 !== null) {
                    result4.push(result5);
                    result5 = parse_DIGIT();
                  }
                } else {
                  result4 = null;
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.sip_version = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_INVITEm() {
        var result0;
        
        if (input.substr(pos, 6) === "INVITE") {
          result0 = "INVITE";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"INVITE\"");
          }
        }
        return result0;
      }
      
      function parse_ACKm() {
        var result0;
        
        if (input.substr(pos, 3) === "ACK") {
          result0 = "ACK";
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ACK\"");
          }
        }
        return result0;
      }
      
      function parse_OPTIONSm() {
        var result0;
        
        if (input.substr(pos, 7) === "OPTIONS") {
          result0 = "OPTIONS";
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"OPTIONS\"");
          }
        }
        return result0;
      }
      
      function parse_BYEm() {
        var result0;
        
        if (input.substr(pos, 3) === "BYE") {
          result0 = "BYE";
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"BYE\"");
          }
        }
        return result0;
      }
      
      function parse_CANCELm() {
        var result0;
        
        if (input.substr(pos, 6) === "CANCEL") {
          result0 = "CANCEL";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"CANCEL\"");
          }
        }
        return result0;
      }
      
      function parse_REGISTERm() {
        var result0;
        
        if (input.substr(pos, 8) === "REGISTER") {
          result0 = "REGISTER";
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"REGISTER\"");
          }
        }
        return result0;
      }
      
      function parse_SUBSCRIBEm() {
        var result0;
        
        if (input.substr(pos, 9) === "SUBSCRIBE") {
          result0 = "SUBSCRIBE";
          pos += 9;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SUBSCRIBE\"");
          }
        }
        return result0;
      }
      
      function parse_NOTIFYm() {
        var result0;
        
        if (input.substr(pos, 6) === "NOTIFY") {
          result0 = "NOTIFY";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"NOTIFY\"");
          }
        }
        return result0;
      }
      
      function parse_Method() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_INVITEm();
        if (result0 === null) {
          result0 = parse_ACKm();
          if (result0 === null) {
            result0 = parse_OPTIONSm();
            if (result0 === null) {
              result0 = parse_BYEm();
              if (result0 === null) {
                result0 = parse_CANCELm();
                if (result0 === null) {
                  result0 = parse_REGISTERm();
                  if (result0 === null) {
                    result0 = parse_SUBSCRIBEm();
                    if (result0 === null) {
                      result0 = parse_NOTIFYm();
                      if (result0 === null) {
                        result0 = parse_token();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.method = input.substring(pos, offset);
                            return data.method; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Status_Line() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_SIP_Version();
        if (result0 !== null) {
          result1 = parse_SP();
          if (result1 !== null) {
            result2 = parse_Status_Code();
            if (result2 !== null) {
              result3 = parse_SP();
              if (result3 !== null) {
                result4 = parse_Reason_Phrase();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Status_Code() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_extension_code();
        if (result0 !== null) {
          result0 = (function(offset, status_code) {
                          data.status_code = parseInt(status_code.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_extension_code() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_DIGIT();
        if (result0 !== null) {
          result1 = parse_DIGIT();
          if (result1 !== null) {
            result2 = parse_DIGIT();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Reason_Phrase() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_reserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              result1 = parse_UTF8_NONASCII();
              if (result1 === null) {
                result1 = parse_UTF8_CONT();
                if (result1 === null) {
                  result1 = parse_SP();
                  if (result1 === null) {
                    result1 = parse_HTAB();
                  }
                }
              }
            }
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_reserved();
          if (result1 === null) {
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                result1 = parse_UTF8_NONASCII();
                if (result1 === null) {
                  result1 = parse_UTF8_CONT();
                  if (result1 === null) {
                    result1 = parse_SP();
                    if (result1 === null) {
                      result1 = parse_HTAB();
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.reason_phrase = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Allow() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_allow_method();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_allow_method();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_allow_method();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
        				 data = data.methods; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_allow_method() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_Method();
        if (result0 !== null) {
          result0 = (function(offset, method) {
                         if (!data.methods) data.methods = [];
                         data.methods.push(method); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Allow_Events() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_event_type();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_event_type();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_event_type();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Call_ID() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_call_id();
        if (result0 !== null) {
          result0 = (function(offset, call_id) {
                      data = call_id; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_call_id() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_word();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 64) {
            result1 = "@";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_word();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                      return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Contact() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        result0 = parse_STAR();
        if (result0 === null) {
          pos1 = pos;
          result0 = parse_contact_param();
          if (result0 !== null) {
            result1 = [];
            pos2 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_contact_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            while (result2 !== null) {
              result1.push(result2);
              pos2 = pos;
              result2 = parse_COMMA();
              if (result2 !== null) {
                result3 = parse_contact_param();
                if (result3 !== null) {
                  result2 = [result2, result3];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                var idx;
                                for (idx in data.multi_header) {
                                  if (data.multi_header[idx].parsed === null) {
                                    data = null;
                                    break;
                                  }
                                }
                                if (data !== null) {
                                  data = data.multi_header;
                                } else {
                                  data = -1;
                                }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_contact_param() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_contact_params();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_contact_params();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                var header;
                                if(!data.multi_header) data.multi_header = [];
                                try {
                                  header = new JsSIP.NameAddrHeader(data.uri, data.display_name, data.params);
                                  delete data.uri;
                                  delete data.display_name;
                                  delete data.params;
                                } catch(e) {
                                  header = null;
                                }
                                data.multi_header.push( { 'possition': pos,
                                                          'offset': offset,
                                                          'parsed': header
                                                        });})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_name_addr() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_display_name();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_LAQUOT();
          if (result1 !== null) {
            result2 = parse_SIP_URI();
            if (result2 !== null) {
              result3 = parse_RAQUOT();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_display_name() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_LWS();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_LWS();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          result0 = parse_quoted_string();
        }
        if (result0 !== null) {
          result0 = (function(offset, display_name) {
                                display_name = input.substring(pos, offset).trim();
                                if (display_name[0] === '\"') {
                                  display_name = display_name.substring(1, display_name.length-1);
                                }
                                data.display_name = display_name; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_contact_params() {
        var result0;
        
        result0 = parse_c_p_q();
        if (result0 === null) {
          result0 = parse_c_p_expires();
          if (result0 === null) {
            result0 = parse_generic_param();
          }
        }
        return result0;
      }
      
      function parse_c_p_q() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 1).toLowerCase() === "q") {
          result0 = input.substr(pos, 1);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"q\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_qvalue();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, q) {
                                if(!data.params) data.params = {};
                                data.params['q'] = q; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_c_p_expires() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 7).toLowerCase() === "expires") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"expires\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_delta_seconds();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, expires) {
                                if(!data.params) data.params = {};
                                data.params['expires'] = expires; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_delta_seconds() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, delta_seconds) {
                                return parseInt(delta_seconds.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qvalue() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result1 = [result1, result2, result3, result4];
                } else {
                  result1 = null;
                  pos = pos2;
                }
              } else {
                result1 = null;
                pos = pos2;
              }
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                return parseFloat(input.substring(pos, offset)); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_generic_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          pos2 = pos;
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_gen_value();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, param, value) {
                                if(!data.params) data.params = {};
                                if (typeof value === 'undefined'){
                                  value = undefined;
                                }
                                else {
                                  value = value[1];
                                }
                                data.params[param.toLowerCase()] = value;})(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_gen_value() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_host();
          if (result0 === null) {
            result0 = parse_quoted_string();
          }
        }
        return result0;
      }
      
      function parse_Content_Disposition() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_disp_type();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_disp_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_disp_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_disp_type() {
        var result0;
        
        if (input.substr(pos, 6).toLowerCase() === "render") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"render\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7).toLowerCase() === "session") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"session\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 4).toLowerCase() === "icon") {
              result0 = input.substr(pos, 4);
              pos += 4;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"icon\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 5).toLowerCase() === "alert") {
                result0 = input.substr(pos, 5);
                pos += 5;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"alert\"");
                }
              }
              if (result0 === null) {
                result0 = parse_token();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_disp_param() {
        var result0;
        
        result0 = parse_handling_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_handling_param() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 8).toLowerCase() === "handling") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"handling\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            if (input.substr(pos, 8).toLowerCase() === "optional") {
              result2 = input.substr(pos, 8);
              pos += 8;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"optional\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8).toLowerCase() === "required") {
                result2 = input.substr(pos, 8);
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"required\"");
                }
              }
              if (result2 === null) {
                result2 = parse_token();
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Encoding() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Length() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, length) {
                                data = parseInt(length.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Type() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_media_type();
        if (result0 !== null) {
          result0 = (function(offset) {
                                data = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_media_type() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_m_type();
        if (result0 !== null) {
          result1 = parse_SLASH();
          if (result1 !== null) {
            result2 = parse_m_subtype();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_SEMI();
              if (result4 !== null) {
                result5 = parse_m_parameter();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_SEMI();
                if (result4 !== null) {
                  result5 = parse_m_parameter();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_type() {
        var result0;
        
        result0 = parse_discrete_type();
        if (result0 === null) {
          result0 = parse_composite_type();
        }
        return result0;
      }
      
      function parse_discrete_type() {
        var result0;
        
        if (input.substr(pos, 4).toLowerCase() === "text") {
          result0 = input.substr(pos, 4);
          pos += 4;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"text\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 5).toLowerCase() === "image") {
            result0 = input.substr(pos, 5);
            pos += 5;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"image\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 5).toLowerCase() === "audio") {
              result0 = input.substr(pos, 5);
              pos += 5;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"audio\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 5).toLowerCase() === "video") {
                result0 = input.substr(pos, 5);
                pos += 5;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"video\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 11).toLowerCase() === "application") {
                  result0 = input.substr(pos, 11);
                  pos += 11;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"application\"");
                  }
                }
                if (result0 === null) {
                  result0 = parse_extension_token();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_composite_type() {
        var result0;
        
        if (input.substr(pos, 7).toLowerCase() === "message") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"message\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 9).toLowerCase() === "multipart") {
            result0 = input.substr(pos, 9);
            pos += 9;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"multipart\"");
            }
          }
          if (result0 === null) {
            result0 = parse_extension_token();
          }
        }
        return result0;
      }
      
      function parse_extension_token() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_x_token();
        }
        return result0;
      }
      
      function parse_x_token() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2).toLowerCase() === "x-") {
          result0 = input.substr(pos, 2);
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"x-\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_token();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_subtype() {
        var result0;
        
        result0 = parse_extension_token();
        if (result0 === null) {
          result0 = parse_token();
        }
        return result0;
      }
      
      function parse_m_parameter() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_m_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_value() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_quoted_string();
        }
        return result0;
      }
      
      function parse_CSeq() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_CSeq_value();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_Method();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_CSeq_value() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, cseq_value) {
                          data.value=parseInt(cseq_value.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Expires() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_delta_seconds();
        if (result0 !== null) {
          result0 = (function(offset, expires) {data = expires; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Event() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_event_type();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, event_type) {
                               data.event = event_type.join('').toLowerCase(); })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_event_type() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token_nodot();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 46) {
            result2 = ".";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_token_nodot();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_token_nodot();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_From() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_from_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_from_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                        var tag = data.tag;
                        try {
                          data = new JsSIP.NameAddrHeader(data.uri, data.display_name, data.params);
                          if (tag) {data.setParam('tag',tag)}
                        } catch(e) {
                          data = -1;
                        }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_from_param() {
        var result0;
        
        result0 = parse_tag_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_tag_param() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "tag") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"tag\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, tag) {data.tag = tag; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Max_Forwards() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, forwards) {
                          data = parseInt(forwards.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Min_Expires() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_delta_seconds();
        if (result0 !== null) {
          result0 = (function(offset, min_expires) {data = min_expires; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Min_SE() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_delta_seconds();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, min_se) {
                              if (min_se >= 90) {
                              	data = min_se;
                              } else {
                              	data = -1;
                              }})(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Name_Addr_Header() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_display_name();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_display_name();
        }
        if (result0 !== null) {
          result1 = parse_LAQUOT();
          if (result1 !== null) {
            result2 = parse_SIP_URI();
            if (result2 !== null) {
              result3 = parse_RAQUOT();
              if (result3 !== null) {
                result4 = [];
                pos2 = pos;
                result5 = parse_SEMI();
                if (result5 !== null) {
                  result6 = parse_generic_param();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                } else {
                  result5 = null;
                  pos = pos2;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos2 = pos;
                  result5 = parse_SEMI();
                  if (result5 !== null) {
                    result6 = parse_generic_param();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              try {
                                data = new JsSIP.NameAddrHeader(data.uri, data.display_name, data.params);
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Proxy_Authenticate() {
        var result0;
        
        result0 = parse_challenge();
        return result0;
      }
      
      function parse_challenge() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "digest") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Digest\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_digest_cln();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_COMMA();
              if (result4 !== null) {
                result5 = parse_digest_cln();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_COMMA();
                if (result4 !== null) {
                  result5 = parse_digest_cln();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_other_challenge();
        }
        return result0;
      }
      
      function parse_other_challenge() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_auth_param();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_COMMA();
              if (result4 !== null) {
                result5 = parse_auth_param();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_COMMA();
                if (result4 !== null) {
                  result5 = parse_auth_param();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_auth_param() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 === null) {
              result2 = parse_quoted_string();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_digest_cln() {
        var result0;
        
        result0 = parse_realm();
        if (result0 === null) {
          result0 = parse_domain();
          if (result0 === null) {
            result0 = parse_nonce();
            if (result0 === null) {
              result0 = parse_opaque();
              if (result0 === null) {
                result0 = parse_stale();
                if (result0 === null) {
                  result0 = parse_algorithm();
                  if (result0 === null) {
                    result0 = parse_qop_options();
                    if (result0 === null) {
                      result0 = parse_auth_param();
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_realm() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "realm") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"realm\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_realm_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_realm_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_quoted_string_clean();
        if (result0 !== null) {
          result0 = (function(offset, realm) { data.realm = realm; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_domain() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "domain") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"domain\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_LDQUOT();
            if (result2 !== null) {
              result3 = parse_URI();
              if (result3 !== null) {
                result4 = [];
                pos1 = pos;
                result6 = parse_SP();
                if (result6 !== null) {
                  result5 = [];
                  while (result6 !== null) {
                    result5.push(result6);
                    result6 = parse_SP();
                  }
                } else {
                  result5 = null;
                }
                if (result5 !== null) {
                  result6 = parse_URI();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos1;
                  }
                } else {
                  result5 = null;
                  pos = pos1;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos1 = pos;
                  result6 = parse_SP();
                  if (result6 !== null) {
                    result5 = [];
                    while (result6 !== null) {
                      result5.push(result6);
                      result6 = parse_SP();
                    }
                  } else {
                    result5 = null;
                  }
                  if (result5 !== null) {
                    result6 = parse_URI();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos1;
                    }
                  } else {
                    result5 = null;
                    pos = pos1;
                  }
                }
                if (result4 !== null) {
                  result5 = parse_RDQUOT();
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_URI() {
        var result0;
        
        result0 = parse_absoluteURI();
        if (result0 === null) {
          result0 = parse_abs_path();
        }
        return result0;
      }
      
      function parse_nonce() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "nonce") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"nonce\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_nonce_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_nonce_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_quoted_string_clean();
        if (result0 !== null) {
          result0 = (function(offset, nonce) { data.nonce=nonce; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_opaque() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "opaque") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"opaque\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_quoted_string_clean();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, opaque) { data.opaque=opaque; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stale() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "stale") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"stale\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            pos1 = pos;
            if (input.substr(pos, 4).toLowerCase() === "true") {
              result2 = input.substr(pos, 4);
              pos += 4;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"true\"");
              }
            }
            if (result2 !== null) {
              result2 = (function(offset) { data.stale=true; })(pos1);
            }
            if (result2 === null) {
              pos = pos1;
            }
            if (result2 === null) {
              pos1 = pos;
              if (input.substr(pos, 5).toLowerCase() === "false") {
                result2 = input.substr(pos, 5);
                pos += 5;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"false\"");
                }
              }
              if (result2 !== null) {
                result2 = (function(offset) { data.stale=false; })(pos1);
              }
              if (result2 === null) {
                pos = pos1;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_algorithm() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 9).toLowerCase() === "algorithm") {
          result0 = input.substr(pos, 9);
          pos += 9;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"algorithm\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            if (input.substr(pos, 3).toLowerCase() === "md5") {
              result2 = input.substr(pos, 3);
              pos += 3;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"MD5\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8).toLowerCase() === "md5-sess") {
                result2 = input.substr(pos, 8);
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"MD5-sess\"");
                }
              }
              if (result2 === null) {
                result2 = parse_token();
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, algorithm) {
                              data.algorithm=algorithm.toUpperCase(); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qop_options() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "qop") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"qop\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_LDQUOT();
            if (result2 !== null) {
              pos1 = pos;
              result3 = parse_qop_value();
              if (result3 !== null) {
                result4 = [];
                pos2 = pos;
                if (input.charCodeAt(pos) === 44) {
                  result5 = ",";
                  pos++;
                } else {
                  result5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result5 !== null) {
                  result6 = parse_qop_value();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                } else {
                  result5 = null;
                  pos = pos2;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos2 = pos;
                  if (input.charCodeAt(pos) === 44) {
                    result5 = ",";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_qop_value();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                }
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
              if (result3 !== null) {
                result4 = parse_RDQUOT();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qop_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 8).toLowerCase() === "auth-int") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"auth-int\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "auth") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"auth\"");
            }
          }
          if (result0 === null) {
            result0 = parse_token();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, qop_value) {
                                data.qop || (data.qop=[]);
                                data.qop.push(qop_value.toLowerCase()); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Proxy_Require() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_option_tag();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_option_tag();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_option_tag();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_option_tag() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result0 = (function(offset, option) {
                           if (!data.options) data.options = [];
                           data.options.push(option); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Record_Route() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_rec_route();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_rec_route();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_rec_route();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          var idx;
                          for (idx in data.multi_header) {
                            if (data.multi_header[idx].parsed === null) {
                              data = null;
                              break;
                            }
                          }
                          if (data !== null) {
                            data = data.multi_header;
                          } else {
                            data = -1;
                          }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rec_route() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_name_addr();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          var header;
                          if(!data.multi_header) data.multi_header = [];
                          try {
                            header = new JsSIP.NameAddrHeader(data.uri, data.display_name, data.params);
                            delete data.uri;
                            delete data.display_name;
                            delete data.params;
                          } catch(e) {
                            header = null;
                          }
                          data.multi_header.push( { 'possition': pos,
                                                    'offset': offset,
                                                    'parsed': header
                                                  });})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Refer_To() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          try {
                            data = new JsSIP.NameAddrHeader(data.uri, data.display_name, data.params);
                          } catch(e) {
                            data = -1;
                          }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Require() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_option_tag();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_option_tag();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_option_tag();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data = data.options; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Route() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_route_param();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_route_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_route_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_route_param() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_name_addr();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Session_Expires() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_delta_seconds();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_se_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_se_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, interval) {
                              data.interval = interval; })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_se_param() {
        var result0;
        
        result0 = parse_refresher_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_refresher_param() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 9).toLowerCase() === "refresher") {
          result0 = input.substr(pos, 9);
          pos += 9;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"refresher\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            if (input.substr(pos, 3).toLowerCase() === "uas") {
              result2 = input.substr(pos, 3);
              pos += 3;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"uas\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 3).toLowerCase() === "uac") {
                result2 = input.substr(pos, 3);
                pos += 3;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"uac\"");
                }
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, refresher) {
                              if(!data.params) data.params = {};
                              data.params['refresher'] = refresher; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Subscription_State() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_substate_value();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_subexp_params();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_subexp_params();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_substate_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "active") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"active\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7).toLowerCase() === "pending") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"pending\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 10).toLowerCase() === "terminated") {
              result0 = input.substr(pos, 10);
              pos += 10;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"terminated\"");
              }
            }
            if (result0 === null) {
              result0 = parse_token();
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                data.state = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_subexp_params() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "reason") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"reason\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_event_reason_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, reason) {
                                if (typeof reason !== 'undefined') data.reason = reason; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.substr(pos, 7).toLowerCase() === "expires") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"expires\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_EQUAL();
            if (result1 !== null) {
              result2 = parse_delta_seconds();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expires) {
                                  if (typeof expires !== 'undefined') data.expires = expires; })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (input.substr(pos, 11).toLowerCase() === "retry_after") {
              result0 = input.substr(pos, 11);
              pos += 11;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"retry_after\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_EQUAL();
              if (result1 !== null) {
                result2 = parse_delta_seconds();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, retry_after) {
                                    if (typeof retry_after !== 'undefined') data.retry_after = retry_after; })(pos0, result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              result0 = parse_generic_param();
            }
          }
        }
        return result0;
      }
      
      function parse_event_reason_value() {
        var result0;
        
        if (input.substr(pos, 11).toLowerCase() === "deactivated") {
          result0 = input.substr(pos, 11);
          pos += 11;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"deactivated\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 9).toLowerCase() === "probation") {
            result0 = input.substr(pos, 9);
            pos += 9;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"probation\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 8).toLowerCase() === "rejected") {
              result0 = input.substr(pos, 8);
              pos += 8;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"rejected\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 7).toLowerCase() === "timeout") {
                result0 = input.substr(pos, 7);
                pos += 7;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"timeout\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 6).toLowerCase() === "giveup") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"giveup\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 10).toLowerCase() === "noresource") {
                    result0 = input.substr(pos, 10);
                    pos += 10;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"noresource\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 9).toLowerCase() === "invariant") {
                      result0 = input.substr(pos, 9);
                      pos += 9;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"invariant\"");
                      }
                    }
                    if (result0 === null) {
                      result0 = parse_token();
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_Subject() {
        var result0;
        
        result0 = parse_TEXT_UTF8_TRIM();
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_Supported() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_option_tag();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_option_tag();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_option_tag();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result0 = (function(offset) {
                       data = data.options || []; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Target_Dialog() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_call_id();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_td_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_td_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, call_id) {
                           data.call_id = call_id; })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_td_param() {
        var result0;
        
        result0 = parse_remote_param();
        if (result0 === null) {
          result0 = parse_local_param();
          if (result0 === null) {
            result0 = parse_generic_param();
          }
        }
        return result0;
      }
      
      function parse_remote_param() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 10).toLowerCase() === "remote-tag") {
          result0 = input.substr(pos, 10);
          pos += 10;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"remote-tag\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, tag) {
                           data.remote_tag = tag; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_local_param() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 9).toLowerCase() === "local-tag") {
          result0 = input.substr(pos, 9);
          pos += 9;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"local-tag\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, tag) {
                           data.local_tag = tag; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_To() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_to_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_to_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                      var tag = data.tag;
                      try {
                        data = new JsSIP.NameAddrHeader(data.uri, data.display_name, data.params);
                        if (tag) {data.setParam('tag',tag)}
                      } catch(e) {
                        data = -1;
                      }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_to_param() {
        var result0;
        
        result0 = parse_tag_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_Via() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_via_parm();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_via_parm();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_via_parm();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_parm() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_sent_protocol();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_sent_by();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_SEMI();
              if (result4 !== null) {
                result5 = parse_via_params();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_SEMI();
                if (result4 !== null) {
                  result5 = parse_via_params();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_params() {
        var result0;
        
        result0 = parse_via_ttl();
        if (result0 === null) {
          result0 = parse_via_maddr();
          if (result0 === null) {
            result0 = parse_via_received();
            if (result0 === null) {
              result0 = parse_via_branch();
              if (result0 === null) {
                result0 = parse_response_port();
                if (result0 === null) {
                  result0 = parse_generic_param();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_via_ttl() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "ttl") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ttl\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_ttl();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_ttl_value) {
                              data.ttl = via_ttl_value; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_maddr() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "maddr") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"maddr\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_host();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_maddr) {
                              data.maddr = via_maddr; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_received() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 8).toLowerCase() === "received") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"received\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_IPv4address();
            if (result2 === null) {
              result2 = parse_IPv6address();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_received) {
                              data.received = via_received; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_branch() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "branch") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"branch\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_branch) {
                              data.branch = via_branch; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_response_port() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "rport") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"rport\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_DIGIT();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_DIGIT();
            }
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              if(typeof response_port !== 'undefined')
                                data.rport = response_port.join(''); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sent_protocol() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_protocol_name();
        if (result0 !== null) {
          result1 = parse_SLASH();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result3 = parse_SLASH();
              if (result3 !== null) {
                result4 = parse_transport();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_protocol_name() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SIP\"");
          }
        }
        if (result0 === null) {
          result0 = parse_token();
        }
        if (result0 !== null) {
          result0 = (function(offset, via_protocol) {
                              data.protocol = via_protocol; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_transport() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "udp") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"UDP\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 3).toLowerCase() === "tcp") {
            result0 = input.substr(pos, 3);
            pos += 3;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"TCP\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tls") {
              result0 = input.substr(pos, 3);
              pos += 3;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"TLS\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 4).toLowerCase() === "sctp") {
                result0 = input.substr(pos, 4);
                pos += 4;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"SCTP\"");
                }
              }
              if (result0 === null) {
                result0 = parse_token();
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, via_transport) {
                              data.transport = via_transport; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sent_by() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_via_host();
        if (result0 !== null) {
          pos1 = pos;
          result1 = parse_COLON();
          if (result1 !== null) {
            result2 = parse_via_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_hostname();
        if (result0 === null) {
          result0 = parse_IPv4address();
          if (result0 === null) {
            result0 = parse_IPv6reference();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              data.host = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_port() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_sent_by_port) {
                              data.port = parseInt(via_sent_by_port.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ttl() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, ttl) {
                              return parseInt(ttl.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_WWW_Authenticate() {
        var result0;
        
        result0 = parse_challenge();
        return result0;
      }
      
      function parse_extension_header() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_HCOLON();
          if (result1 !== null) {
            result2 = parse_header_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_header_value() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_TEXT_UTF8char();
        if (result1 === null) {
          result1 = parse_UTF8_CONT();
          if (result1 === null) {
            result1 = parse_LWS();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_TEXT_UTF8char();
          if (result1 === null) {
            result1 = parse_UTF8_CONT();
            if (result1 === null) {
              result1 = parse_LWS();
            }
          }
        }
        return result0;
      }
      
      function parse_message_body() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_OCTET();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_OCTET();
        }
        return result0;
      }
      
      function parse_stun_URI() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_stun_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_stun_host_port();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_scheme() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "stuns") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"stuns\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "stun") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"stun\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, scheme) {
                              data.scheme = scheme; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_host_port() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_stun_host();
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_IPv4address();
        if (result0 === null) {
          result0 = parse_IPv6reference();
          if (result0 === null) {
            result0 = parse_reg_name();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, host) {
                              data.host = host; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_reg_name() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_stun_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            result1 = parse_sub_delims();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_stun_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              result1 = parse_sub_delims();
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_unreserved() {
        var result0;
        
        result0 = parse_ALPHA();
        if (result0 === null) {
          result0 = parse_DIGIT();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 45) {
              result0 = "-";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"-\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 46) {
                result0 = ".";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result0 = "_";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 126) {
                    result0 = "~";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"~\"");
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_sub_delims() {
        var result0;
        
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 36) {
            result0 = "$";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"$\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 38) {
              result0 = "&";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 39) {
                result0 = "'";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"'\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 40) {
                  result0 = "(";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"(\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 41) {
                    result0 = ")";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 42) {
                      result0 = "*";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"*\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result0 = "+";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 44) {
                          result0 = ",";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 59) {
                            result0 = ";";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\";\"");
                            }
                          }
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 61) {
                              result0 = "=";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"=\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_turn_URI() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_turn_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_stun_host_port();
            if (result2 !== null) {
              pos1 = pos;
              if (input.substr(pos, 11) === "?transport=") {
                result3 = "?transport=";
                pos += 11;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?transport=\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_transport();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_turn_scheme() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "turns") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"turns\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "turn") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"turn\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, scheme) {
                              data.scheme = scheme; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_turn_transport() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_transport();
        if (result0 !== null) {
          if (input.substr(pos, 3).toLowerCase() === "udp") {
            result1 = input.substr(pos, 3);
            pos += 3;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"udp\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tcp") {
              result1 = input.substr(pos, 3);
              pos += 3;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"tcp\"");
              }
            }
            if (result1 === null) {
              result1 = [];
              result2 = parse_unreserved();
              while (result2 !== null) {
                result1.push(result2);
                result2 = parse_unreserved();
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              data.transport = transport; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uuid_URI() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5) === "uuid:") {
          result0 = "uuid:";
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"uuid:\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_uuid();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uuid() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_hex8();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hex4();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 45) {
                result3 = "-";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_hex4();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 45) {
                    result5 = "-";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_hex4();
                    if (result6 !== null) {
                      if (input.charCodeAt(pos) === 45) {
                        result7 = "-";
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"-\"");
                        }
                      }
                      if (result7 !== null) {
                        result8 = parse_hex12();
                        if (result8 !== null) {
                          result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, uuid) {
                          data = input.substring(pos+5, offset); })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex4() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_HEXDIG();
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            if (result2 !== null) {
              result3 = parse_HEXDIG();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex8() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = parse_hex4();
        if (result0 !== null) {
          result1 = parse_hex4();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex12() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_hex4();
        if (result0 !== null) {
          result1 = parse_hex4();
          if (result1 !== null) {
            result2 = parse_hex4();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
       var data = {}; 
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
        return -1;
      }
      
      return data;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();

/*! Crocodile MSRP - v0.9.0 - 2013-04-30
* http://code.google.com/p/crocodile-msrp/
* Copyright (c) 2013 Crocodile RCS Ltd; Licensed MIT */
var CrocMSRP = (function(CrocMSRP) {

	/**
	 * Creates a new ChunkReceiver object to handle an incoming chunked message.
	 * @class Tracks and combines the received components of a chunked message.
	 * @param {CrocMSRP.Message.Request} firstChunk The first received chunk:
	 * this must contain the first byte of the incoming message. Later chunks
	 * may arrive out-of-order.
	 * @param {Number} bufferSize The threshold of data to cache in memory
	 * writing the chunks out to a Blob (which will generally get stored to
	 * disk).
	 * @private
	 */
	CrocMSRP.ChunkReceiver = function(firstChunk, bufferSize) {
		if (!firstChunk || !firstChunk instanceof CrocMSRP.Message.Request) {
			throw new TypeError('Missing or unexpected parameter');
		}
		
		this.firstChunk = firstChunk;
		
		// totalBytes may be -1 if we don't know the size
		this.totalBytes = firstChunk.byteRange.total;
		this.bufferedChunks = [];
		this.bufferedBytes = 0;
		this.bufferSize = bufferSize;
		// blob contains all the contiguous message bodies we have received
		this.blob = new Blob();
		// Current blob size; cached since blob.size seems to be slow
		this.size = 0;
		// receivedBytes may be > totalBytes if we've had duplicate chunks
		this.receivedBytes = 0;
		this.aborted = false;  // true if the transfer has been aborted
		this.remoteAbort = false;  // true if the remote end aborted
		this.incontiguousChunks = {};
		this.isFile = firstChunk.contentDisposition &&
			(firstChunk.contentDisposition.type === 'attachment' ||
				firstChunk.contentDisposition.type === 'render');
		this.processChunk(firstChunk);
	};

	/**
	 * Processes subsequent chunks of the message as they arrive.
	 * @param {CrocMSRP.Message.Request} chunk The received chunk. This must be
	 * a chunk of the same message (i.e. the Message-ID must match that of the
	 * first chunk).
	 * @returns {Boolean} True if the chunk was successfully handled, false
	 * if the transfer should be aborted.
	 * @private
	 */
	CrocMSRP.ChunkReceiver.prototype.processChunk = function(chunk) {
		var chunkBody, chunkSize,
			nextStart = this.size + this.bufferedBytes + 1;
		
		if (this.aborted) {
			// The message has been aborted locally, or we've received another
			// chunk of a remote-aborted message; return error.
			return false;
		}
		
		if (chunk.messageId !== this.firstChunk.messageId) {
			console.error('Chunk has wrong message ID!');
			return false;
		}
		
		this.lastReceive = new Date().getTime();
		
		if (chunk.body instanceof ArrayBuffer) {
			// Yay! Binary frame, everything is straightforward.
			// Convert to ArrayBufferView to avoid Chrome Blob constructor warning
			// This should not be necessary: https://bugs.webkit.org/show_bug.cgi?id=88389
			chunkBody = new Uint8Array(chunk.body);
			chunkSize = chunkBody.byteLength;
		} else {
			// Boo. Text frame: turn it back into UTF-8 and cross your fingers
			// that the resulting bytes are what they should be.
			chunkBody = new Blob([chunk.body]);
			chunkSize = chunkBody.size;
		}
		this.receivedBytes += chunkSize;

		switch (chunk.continuationFlag) {
		case CrocMSRP.Message.Flag.continued:
			break;
		case CrocMSRP.Message.Flag.end:
			this.totalBytes = chunk.byteRange.start + chunkSize - 1;
			break;
		case CrocMSRP.Message.Flag.abort:
			this.abort();
			this.remoteAbort = true;
			return false;
		}
		
		if (chunk.byteRange.start === nextStart) {
			// This is the expected result; append to the write buffer
			this.bufferedChunks.push(chunkBody);
			this.bufferedBytes += chunkSize;
			nextStart += chunkSize;
			
			// Check whether there are any incontiguous chunks we can now append
			while (!CrocMSRP.util.isEmpty(this.incontiguousChunks)) {
				var nextChunk = this.incontiguousChunks[nextStart];
				if (!nextChunk) {
					// There's a gap: stop appending
					break;
				}
				delete this.incontiguousChunks[nextStart];
				
				// Add it to the disk buffer
				this.bufferedChunks.push(nextChunk);
				if (nextChunk instanceof ArrayBuffer) {
					chunkSize = nextChunk.byteLength;
				} else {
					chunkSize = nextChunk.size;
				}
				this.bufferedBytes += chunkSize;
				nextStart += chunkSize;
			}
			
			// Write out to the blob if we've exceeded the buffer size, or the
			// transfer is complete
			if (this.bufferedBytes >= this.bufferSize ||
					this.size + this.bufferedBytes === this.totalBytes) {
				writeToBlob(this);
			}
		} else if (chunk.byteRange.start > nextStart) {
			// Add this chunk to the map of incontiguous chunks
			this.incontiguousChunks[chunk.byteRange.start] = chunkBody;
		} else {
			// Duplicate chunk: RFC 4975 section 7.3.1 paragraph 3 suggests
			// that the last chunk received SHOULD take precedence.
			var array = [];
			
			// Write out the buffer in case the new chunk overlaps
			writeToBlob(this);
			
			// Construct a new blob from this chunk plus appropriate slices
			// of the existing blob.
			if (chunk.byteRange.start > 1) {
				array.push(this.blob.slice(0, chunk.byteRange.start - 1));
			}
			array.push(chunkBody);
			if (chunk.byteRange.start + chunkSize <= this.size) {
				array.push(this.blob.slice(chunk.byteRange.start + chunkSize - 1));
			}
			
			this.blob = new Blob(array, {type: this.firstChunk.contentType});
			this.size = this.blob.size;
		}
		
		return true;
	};

	/**
	 * Checks whether all expected chunks have been received.
	 * @returns {Boolean} True if all chunks have been received, or if the
	 * message has been aborted. False if we still expect further chunks.
	 * @private
	 */
	CrocMSRP.ChunkReceiver.prototype.isComplete = function() {
		return this.aborted || (this.size === this.totalBytes);
	};
	
	/**
	 * Requests that we abort this incoming chunked message. An appropriate
	 * error will be returned when we receive the next chunk.
	 * @private
	 */
	CrocMSRP.ChunkReceiver.prototype.abort = function() {
		this.aborted = true;
	};
	
	function writeToBlob(receiver) {
		if (receiver.size > 0) {
			receiver.bufferedChunks.unshift(receiver.blob);
		}
		receiver.blob = new Blob(receiver.bufferedChunks, {type: receiver.firstChunk.contentType});
		receiver.size = receiver.blob.size;
		receiver.bufferedChunks = [];
		receiver.bufferedBytes = 0;
	}
	
	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP = (function(CrocMSRP) {

	/**
	 * Creates a new ChunkSender object to handle an outgoing message.
	 * @class Manages the sending of a message, dividing it into chunks
	 * if required.
	 * @param {CrocMSRP.Session} session The session sending the message.
	 * @param {String|ArrayBuffer|ArrayBufferView|Blob|File} [body] The body of
	 * the message to send. If this is null or undefined then an empty SEND
	 * message will be sent.
	 * @param {String} [contentType] The MIME type of the message.
	 * @param {String} [disposition] The disposition of the message (defaults to
	 * 'inline' if not provided, or 'attachment' if the body is a File object).
	 * @param {String} [description] The description of the message. This would
	 * normally only be used when sending a file.
	 * @private
	 */
	CrocMSRP.ChunkSender = function(session, body, contentType, disposition, description) {
		if (!session) {
			throw new TypeError('Missing mandatory parameter');
		}
		
		if (!body) {
			this.blob = new Blob();
			this.contentType = null;
			this.disposition = null;
		} else if (body instanceof File) {
			this.blob = body;
			this.contentType = contentType || body.type;
			this.disposition = disposition || 'attachment; filename=' + body.name;
		} else if (body instanceof Blob) {
			this.blob = body;
			this.contentType = contentType || body.type;
			this.disposition = disposition;
		} else if (body instanceof String || typeof body === 'string') {
			this.blob = new Blob([body]);
			this.contentType = contentType || 'text/plain';
			this.disposition = disposition;
		} else if (body instanceof ArrayBuffer) {
			// Stop Chrome complaining about ArrayBuffer in Blob constructor
			this.blob = new Blob([new Uint8Array(body)]);
			this.contentType = contentType || 'application/octet-stream';
			this.disposition = disposition;
		} else if (body instanceof ArrayBufferView) {
			this.blob = new Blob([body]);
			this.contentType = contentType || 'application/octet-stream';
			this.disposition = disposition;
		} else {
			throw new TypeError('Body has unexpected type:', body);
		}
		
		this.session = session;
		this.config = session.config;
		this.messageId = CrocMSRP.util.newMID();
		
		if (this.contentType === '') {
			// We have to put something here...
			this.contentType = 'application/octet-stream';
		}
		this.description = description;
		
		this.size = this.blob.size;
		// The highest byte index sent so far
		this.sentBytes = 0;
		// The number of contiguous acked bytes
		this.ackedBytes = 0;
		// Map containing REPORT acks that arrive out-of-order (indexed by range start)
		this.incontiguousReports = {};
		this.incontiguousReportCount = 0;
		// Report timer reference
		this.reportTimer = null;
		// Optional report timeout callback
		this.onReportTimeout = null;
		this.aborted = false;
		this.remoteAbort = false;
	};

	CrocMSRP.ChunkSender.prototype.getNextChunk = function() {
		var chunk;
		
		chunk = new CrocMSRP.Message.OutgoingRequest(this.session, 'SEND');
		chunk.sender = this;
		chunk.addHeader('message-id', this.messageId);
		chunk.addHeader('success-report', 'yes');
		chunk.addHeader('failure-report', 'yes');
		
		if (this.aborted) {
			chunk.continuationFlag = CrocMSRP.Message.Flag.abort;
		} else {
			var start = this.sentBytes + 1,
				end = Math.min(this.sentBytes + this.config.chunkSize, this.size);
			chunk.byteRange = {'start': start, 'end': end, 'total': this.size};
			
			if (this.size > 0) {
				if (this.sentBytes === 0) {
					// Include extra MIME headers on first chunk
					if (this.disposition) {
						chunk.addHeader('content-disposition', this.disposition);
					} else {
						chunk.addHeader('content-disposition', 'inline');
					}
					if (this.description) {
						chunk.addHeader('content-description', this.description);
					}
				}
				
				chunk.contentType = this.contentType;
				chunk.body = this.blob.slice(this.sentBytes, end);
			}
			
			if (end < this.size) {
				chunk.continuationFlag = CrocMSRP.Message.Flag.continued;
			} else if (this.onReportTimeout) {
				var sender = this;
				this.reportTimer = setTimeout(function() {
					sender.onReportTimeout();
					sender.reportTimer = null;
				}, this.config.reportTimeout);
			}
			this.sentBytes = end;
		}

		return chunk;
	};

	/**
	 * Processes report(s) for the message as they arrive.
	 * @param {CrocMSRP.Message.Request} report The received report.  This must
	 * be a report for a message sent by this object (i.e. the Message-ID must
	 * match).
	 * @private
	 */
	CrocMSRP.ChunkSender.prototype.processReport = function(report) {
		var start, appended = true;
		
		if (report.messageId !== this.messageId) {
			console.error('REPORT has wrong message ID!');
			return;
		}
		
		if (report.status !== CrocMSRP.Status.OK) {
			this.abort();
			this.remoteAbort = true;
		} else {
			// Success report; check the byte range
			if (report.byteRange.start <= this.ackedBytes + 1) {
				if (report.byteRange.end > this.ackedBytes) {
					this.ackedBytes = report.byteRange.end;
				}
			} else if (this.incontiguousReportCount > 16) {
				// Start resending from the last acked position
				this.resume();
				return;
			} else {
				// Add this report to the map of incontiguous reports
				this.incontiguousReports[report.byteRange.start] = report.byteRange.end;
				this.incontiguousReportCount++;
				return;
			}
			
			// Check whether any previous reports are now contiguous
			while (appended) {
				appended = false;
				for (start in this.incontiguousReports) {
					if (start <= this.ackedBytes + 1) {
						if (this.incontiguousReports[start] > this.ackedBytes) {
							this.ackedBytes = this.incontiguousReports[start];
						}
						delete this.incontiguousReports[start];
						this.incontiguousReportCount--;
						appended = true;
					}
				}
			}
		}
		
		if (this.isComplete() && this.reportTimer) {
			clearTimeout(this.reportTimer);
			this.reportTimer = null;
		}
		
		return;
	};

	/**
	 * Checks whether all chunks have been sent.
	 * @returns {Boolean} True if all chunks have been sent, or if the
	 * message has been aborted. False if there are further chunks to be sent.
	 * @private
	 */
	CrocMSRP.ChunkSender.prototype.isSendComplete = function() {
		return this.aborted || (this.sentBytes >= this.size);
	};
	
	/**
	 * Checks whether all chunks have been sent and acked.
	 * @returns {Boolean} True if all chunks have been sent and acked, or if the
	 * message has been aborted. False if there are further chunks to be sent,
	 * or if there are acks outstanding.
	 * @private
	 */
	CrocMSRP.ChunkSender.prototype.isComplete = function() {
		return this.aborted || (this.ackedBytes >= this.size);
	};
	
	/**
	 * Resumes a transfer after the connection has been lost. Rewind the sent
	 * bytes to match the acknowledged position (according to received REPORTs).
	 * @private
	 */
	CrocMSRP.ChunkSender.prototype.resume = function() {
		this.sentBytes = this.ackedBytes;
		this.incontiguousReports = {};
		this.incontiguousReportCount = 0;
		console.log('Resuming at offset ' + this.sentBytes);
	};
	
	/**
	 * Requests that we abort this outgoing chunked message. The next chunk will
	 * include the abort flag.
	 * @private
	 */
	CrocMSRP.ChunkSender.prototype.abort = function() {
		this.aborted = true;

		if (this.reportTimer) {
			// Treat this as an immediate report timeout
			clearTimeout(this.reportTimer);

			var sender = this;
			this.reportTimer = setTimeout(function() {
				sender.onReportTimeout();
				sender.reportTimer = null;
			}, 0);
		}
	};
	
	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP = (function(CrocMSRP) {
	var reconnectTimeout = 10000;
	
	/**
	 * Creates a new connection.
	 * A single connection can support multiple sessions. The
	 * websocket connection is not actually opened until the first session
	 * is created.
	 * @class Represents a single connection to a websocket MSRP relay.
	 */
	CrocMSRP.Connection = function(relayWsUri, relayMsrpUri, config) {
		var option, defaultConfig = new CrocMSRP.ConnectionConfig();

		// Process any optional configuration options
		if (config) {
			// Copy in defaults for any missing options
			for (option in defaultConfig) {
				if (config[option] === undefined) {
					config[option] = defaultConfig[option];
				}
			}
		} else {
			// Use the defaults
			config = defaultConfig;
		}
		// Add required configuration options
		config.relayWsUri = relayWsUri;
		config.relayMsrpUri = relayMsrpUri;
		this.config = config;
		
		this.ws = null;
		this.localSessionIds = {};
		this.reconnectTimer = null;
		
		// An array of active message senders
		this.activeSenders = [];
		// The count of outstanding sends
		this.outstandingSends = 0;
	};

	/**
	 * Connects to the websocket server.
	 * @private
	 */
	CrocMSRP.Connection.prototype.connect = function() {
		if (!this.ws) {
			this.ws = new CrocMSRP.WSWrapper(this, this.config.relayWsUri);
		}
	};

	/**
	 * Creates a new session that uses this connection.  Sessions created using
	 * this method can be used to create an outgoing chat SDP offer, or accept
	 * incoming chat or file transfer SDP offers.  To create an outgoing file
	 * transfer SDP offer, use
	 * {@link CrocMSRP.Connection#createFileTransferSession} instead.
	 * Note: The websocket connection is only opened after the first session has
	 * been created.
	 * @param {CrocMSRP.Events} eventObj An object containing event callbacks
	 * to use for the new session.
	 */
	CrocMSRP.Connection.prototype.createSession = function(eventObj) {
		var sessionId, localUri;
		
		do {
			sessionId = CrocMSRP.util.newSID();
		} while (this.localSessionIds[sessionId]);
		
		localUri = new CrocMSRP.Uri();
		localUri.secure = (this.config.relayWsUri.substr(0, 3) === 'wss');
		localUri.authority = this.config.authority;
		localUri.port = 2855;
		localUri.sessionId = sessionId;
		localUri.transport = 'ws';
		this.localSessionIds[sessionId] = new CrocMSRP.Session(this, sessionId, localUri, eventObj);
		
		if (!this.ws) {
			this.connect();
		} else if (this.ws.isConnected()) {
			// Immediately start the authentication process
			this.localSessionIds[sessionId].onWsConnect();
		}
		
		return this.localSessionIds[sessionId];
	};
	
	/**
	 * Creates a new session that uses this connection.  Sessions created using
	 * this method can be used to create an outgoing file transfer SDP offer (as
	 * per RFC 5547).  For other sessions, use
	 * {@link CrocMSRP.Connection#createSession} instead.
	 * Note: The websocket connection is only opened after the first session has
	 * been created.
	 * @param {CrocMSRP.Events} eventObj An object containing event callbacks
	 * to use for the new session.
	 * @param {File} file The file that will be sent using this session.
	 * @param {CrocMSRP.FileParams} [params] Optional file parameters that may
	 * influence the construction of the SDP offer.
	 */
	CrocMSRP.Connection.prototype.createFileTransferSession = function(eventObj, file, params) {
		var session = this.createSession(eventObj);
		session.file = file;
		session.fileParams = params || {};
		return session;
	};

	/**
	 * Closes all sessions associated with this connection and  closes the
	 * websocket connection.
	 */
	CrocMSRP.Connection.prototype.disconnect = function() {
		var sessionId;
		for (sessionId in this.localSessionIds) {
			this.localSessionIds[sessionId].close();
		}
		// Socket will be closed when the last session notifies us of closure
	};

	// Internal Events
	CrocMSRP.Connection.prototype.onWsConnect = function() {
		var sessionId;
		// Notify sessions to kick off authentication process
		for (sessionId in this.localSessionIds) {
			this.localSessionIds[sessionId].onWsConnect();
		}
	};

	CrocMSRP.Connection.prototype.onWsError = function() {
		var sessionId;
		// Ungraceful disconnect
		console.log('WS Error');
		if (this.ws && !CrocMSRP.util.isEmpty(this.localSessionIds)) {
			// If there are sessions present, start a timer to reconnect
			var con = this;
			this.reconnectTimer = setTimeout(
				function() {
					con.connect();
				}, reconnectTimeout);
		}
		this.ws = null;
		this.outstandingSends = 0;
		for (sessionId in this.localSessionIds) {
			this.localSessionIds[sessionId].onWsError();
		}
	};

	CrocMSRP.Connection.prototype.onWsDisconnect = function() {
		// Graceful disconnect (on request)
		console.log('WS Disconnected');
		this.ws = null;
		this.outstandingSends = 0;
	};

	CrocMSRP.Connection.prototype.removeSession = function(sessionId) {
		delete this.localSessionIds[sessionId];
		if (CrocMSRP.util.isEmpty(this.localSessionIds)) {
			// No more sessions; close the connection
			if (this.ws) {
				this.ws.disconnect();
			}
		}
	};

	CrocMSRP.Connection.prototype.onMsrpRequest = function(req) {
		var toUri, session;
		
		// The request's To-Path should have only one URI, and that URI should
		// correspond to one of our sessions.
		if (req.toPath.length !== 1) {
			sendResponse(req, this, req.toPath[0], CrocMSRP.Status.SESSION_DOES_NOT_EXIST);
			return;
		}
		// Decode the URI
		toUri = new CrocMSRP.Uri(req.toPath[0]);
		if (!toUri) {
			sendResponse(req, this, req.toPath[0], CrocMSRP.Status.BAD_REQUEST);
			return;
		}
		// Lookup the appropriate session
		session = this.localSessionIds[toUri.sessionId];
		if (!session || !session.localUri.equals(toUri)) {
			sendResponse(req, this, req.toPath[0], CrocMSRP.Status.SESSION_DOES_NOT_EXIST);
			return;
		}

		// Check the request method
		switch (req.method) {
		case 'SEND':
			session.onIncomingSend(req);
			break;
		case 'REPORT':
			session.onIncomingReport(req);
			break;
		default:
			// Unknown method; return 501 as specified in RFC 4975 section 12
			sendResponse(req, this, req.toPath[0], CrocMSRP.Status.NOT_IMPLEMENTED);
			return;
		}
	};
	
	CrocMSRP.Connection.prototype.addSender = function(sender) {
		this.activeSenders.push(sender);
		sendRequests(this);
	};
	
	CrocMSRP.Connection.prototype.onMsrpResponse = function(res) {
		if (res.request.method === 'SEND') {
			this.outstandingSends--;
		}
		
		// Let the sending session handle the response
		res.request.session.onIncomingResponse(res);
		
		// Then send out any pending requests
		sendRequests(this);
	};
	
	function sendResponse(req, con, uri, status) {
		if (status === CrocMSRP.Status.OK) {
			if (!req.responseOn.success) {
				return;
			}
		} else {
			if (!req.responseOn.failure) {
				return;
			}
		}
		
		con.ws.send(new CrocMSRP.Message.OutgoingResponse(req, uri, status));
	}

	function sendRequests(con) {
		var sent = 0, sender;
		
		// If there are outstanding transfers, send up to two further requests.
		// This lets us ramp up the outstanding requests without locking up the
		// application.
		while (con.activeSenders.length > 0 &&
				con.outstandingSends < con.config.maxOutstandingSends &&
				sent < 2) {
			sender = con.activeSenders[0];
			if (sender.aborted && sender.remoteAbort) {
				// Don't send any more chunks; remove sender from list
				con.activeSenders.shift();
			}
			
			var msg = sender.getNextChunk();
			con.ws.send(msg);
			con.outstandingSends++;
			sent++;
			
			// Check whether this sender has now completed
			if (sender.isSendComplete()) {
				// Remove this sender from the active list
				con.activeSenders.shift();
			} else if (con.activeSenders.length > 1) {
				// For fairness, move this sender to the end of the queue
				con.activeSenders.push(con.activeSenders.shift());
			}
		}
	}
	
	return CrocMSRP;
}(CrocMSRP || {}));


/*jshint unused:vars */

var CrocMSRP = (function(CrocMSRP) {

	/**
	 * Creates a new ConnectionConfig object, with sensible defaults.
	 * @class A ConnectionConfig object contains optional configuration settings
	 * that can be passed to the constructor {@link CrocMSRP.Connection}.
	 */
	CrocMSRP.ConnectionConfig = function() {
		/**
		 * The authority (hostname) used in local MSRP URIs. This will
		 * default to a randomly-generated hostname in the 'invalid'
		 * domain.
		 * @type String
		 */
		this.authority = CrocMSRP.util.newUriAuthority();
		/**
		 * The username to use for authentication (in the MSRP AUTH request).
		 * @type String
		 */
		this.username = 'anonymous';
		/**
		 * The password to use for authentication (in the MSRP AUTH request).
		 * @type String
		 */
		this.password = '';
		/**
		 * The method name to use for authentication. This defaults to the
		 * MSRP method being challenged (i.e. 'AUTH'), but is configurable
		 * in case the server implementation expects something else (such as
		 * 'MSRP').
		 * @type String
		 */
		this.digestMethod = null;
		/**
		 * The MSRP AUTH request can include a suggested expiry time for the
		 * authentication, after which the authentication (and its associated
		 * relay URI) become invalid.  However, the server is not obliged
		 * to use the suggested time; if it falls outside of the server's
		 * minimum or maximum allowed values, the AUTH will be automatically
		 * retried with the the closest allowed value.
		 * @type Number
		 */
		this.authExpires = null;
		/**
		 * The MSRP REPORT timeout, in seconds.
		 * MSRP REPORTs are enabled by default. Any sucessfully sent message
		 * that does not receive a REPORT within this number of seconds will
		 * be reported as a failure.
		 * @type Number
		 * @see CrocMSRP.Events#onMessageFailed
		 * @see CrocMSRP.Events#onFileSendFailed
		 */
		this.reportTimeout = 120000;
		/**
		 * The list of MIME types understood by the application.
		 * Including an '*' in this list indicates that any MIME type may
		 * be sent by the far end; any received messages with MIME types
		 * that are not understood should be rejected with an
		 * {@link CrocMSRP.Exceptions.UnsupportedMedia} exception.
		 * Note that the MSRP specification (RFC 4975) mandates the support
		 * of certain types, such as 'message/cpim'.
		 * @type String[]
		 * @see CrocMSRP.Events#onMessageReceived
		 */
		this.acceptTypes = ['*'];
		/**
		 * The list of MIME types understood by the application, when wrapped
		 * within a supported container type.  By only listing supported
		 * container types in acceptTypes, an endpoint can mandate that all
		 * messages use containers whilst still having control over the
		 * encapsulated types.
		 * @type String[]
		 */
		this.acceptWrappedTypes = null;
		/**
		 * The MSRP chunk size, in bytes.
		 * Messages larger than the configured chunk size will be split into
		 * chunks for sending.  The selected chunk size has an impact on
		 * bandwidth efficiency and performance; larger chunks are more
		 * efficient, but may increase latency for other messages. It is
		 * not advisable to increase this beyond 16KB.
		 * @type Number
		 */
		this.chunkSize = 2048;
		/**
		 * The maximum number of outstanding SEND requests allowed.
		 * Increasing this number may improve performance if the connection
		 * has available bandwidth, but high latency.  However, increasing
		 * it also risks overflowing the TCP send buffer, which will cause
		 * the connection to drop.
		 * @type Number
		 */
		this.maxOutstandingSends = (32 * 1024 / this.chunkSize);
		/**
		 * The timeout for receiving a new chunk of an incoming message, in
		 * seconds.
		 * If the next chunk of an incoming message is not received within
		 * this time, an error event is raised, and the incomplete data is
		 * discarded.
		 * @type Number
		 * @see CrocMSRP.Events#onFileReceiveTimeout
		 */
		this.chunkTimeout = 30 * 1000;
		/**
		 * The receive buffer for incoming message chunks, in bytes.
		 * When receiving a message, up to this many bytes will be cached
		 * in memory before being cached in a Blob.  A larger buffer reduces
		 * disk I/O, and generally increases performance, but requires more
		 * memory.
		 * @type Number
		 */
		this.recvBuffer = 1024 * 1024;
	};
	
	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP = (function(CrocMSRP) {

	/**
	 * Creates a new ContentType object.
	 * @class Generic representation of a MIME type, along with optional
	 * parameters. Provides methods to convert to and from different
	 * representations.
	 */
	CrocMSRP.ContentType = function() {
		/**
		 * The MIME type.
		 * @type String
		 */
		this.type = '';
		/**
		 * The MIME sub type.
		 * @type String
		 */
		this.subtype = '';
		/**
		 * Zero or more content type parameters.
		 * @type Object
		 */
		this.params = {};
	};
	
	/**
	 * Parses an SDP type selector, as defined in RFC 5547.
	 * @param {String} selector The selector value to parse.
	 */
	CrocMSRP.ContentType.prototype.parseSdpTypeSelector = function(selector) {
		var position = 0, endIndex, param, value;
		
		// Type
		endIndex = selector.indexOf('/', position);
		if (endIndex === -1) {
			// Unexpected input
			return;
		}
		this.type = selector.slice(position, endIndex);
		position = endIndex + 1;
		
		// Subtype
		endIndex = position;
		while (endIndex < selector.length) {
			if (selector.charAt(endIndex) === ';') {
				break;
			}
			endIndex++;
		}
		this.subtype = selector.slice(position, endIndex);
		position = endIndex + 1;
		
		// Parameters
		this.params = {};
		while (selector.charAt(endIndex) === ';') {
			// Parse content type parameter
			endIndex = selector.indexOf('=', position);
			if (endIndex === -1) {
				// Unexpected input
				position = selector.length;
				return;
			}
			param = selector.slice(position, endIndex);
			position = endIndex + 1;
			
			if (selector.charAt(position) !== '"') {
				// Unexpected input
				position = selector.length;
				return;
			}
			position++;
			endIndex = selector.indexOf('"', position);
			if (endIndex === -1) {
				// Unexpected input
				position = selector.length;
				return;
			}
			value = selector.slice(position, endIndex);
			position = endIndex + 1;
			
			this.params[param] = CrocMSRP.util.decodeSdpFileName(value);
		}
	};
	
	/**
	 * Encodes the content type as an SDP type selector, as defined in RFC 5547.
	 * @returns {String} The encoded selector value.
	 */
	CrocMSRP.ContentType.prototype.toSdpTypeSelector = function() {
		var selector = '', param;
		
		selector = selector.concat(this.type, '/', this.subtype);
		for (param in this.params) {
			selector = selector.concat(';', param, '="',
				CrocMSRP.util.encodeSdpFileName(this.params[param]), '"');
		}
		
		return selector;
	};
	
	/**
	 * Parses a Content-Type header, as defined in RFC 2045.
	 * Note: Does not allow for unquoted white space.
	 * @param {String} header The header value to parse.
	 */
	CrocMSRP.ContentType.prototype.parseContentTypeHeader = function(header) {
		var position = 0, endIndex, param, value;
		
		// Type
		endIndex = header.indexOf('/', position);
		if (endIndex === -1) {
			// Unexpected input
			return;
		}
		this.type = header.slice(position, endIndex);
		position = endIndex + 1;
		
		// Subtype
		endIndex = position;
		while (endIndex < header.length) {
			if (header.charAt(endIndex) === ';') {
				break;
			}
			endIndex++;
		}
		this.subtype = header.slice(position, endIndex);
		position = endIndex + 1;
		
		// Parameters
		this.params = {};
		while (header.charAt(endIndex) === ';') {
			// Parse content type parameter
			endIndex = header.indexOf('=', position);
			if (endIndex === -1) {
				// Unexpected input
				position = header.length;
				return;
			}
			param = header.slice(position, endIndex);
			position = endIndex + 1;
			
			if (header.charAt(position) === '"') {
				position++;
				endIndex = header.indexOf('"', position);
				if (endIndex === -1) {
					// Unexpected input
					position = header.length;
					return;
				}
				while (header.charAt(endIndex - 1) === '\\') {
					endIndex = header.indexOf('"', endIndex + 1);
					if (endIndex === -1) {
						// Unexpected input
						position = header.length;
						return;
					}
				}
			} else {
				endIndex = header.indexOf(' ', position);
				if (endIndex === -1) {
					endIndex = header.length;
				}
			}
			value = header.slice(position, endIndex);
			position = endIndex + 1;
			
			this.params[param] = CrocMSRP.util.decodeQuotedString(value);
		}
	};
	
	/**
	 * Encodes the content type as an Content-Type header, as defined in RFC 2045.
	 * @returns {String} The encoded header value.
	 */
	CrocMSRP.ContentType.prototype.toContentTypeHeader = function() {
		var header = '', param;
		
		header = header.concat(this.type, '/', this.subtype);
		for (param in this.params) {
			header = header.concat(';', param, '="',
				CrocMSRP.util.encodeQuotedString(this.params[param]), '"');
		}
		
		return header;
	};
	
	return CrocMSRP;
}(CrocMSRP || {}));


/*jshint unused:vars */

var CrocMSRP = (function(CrocMSRP) {

	/**
	 * Creates an events callback object used with a {@link CrocMSRP.Session}.
	 * The methods defined here should be overrided as appropriate to your
	 * application.
	 * 
	 * @class The Session event callback object.
	 */
	CrocMSRP.Events = function() {
	};
	
	/**
	 * Event callback indicating that the session has authenticated with the
	 * MSRP websocket relay, and is ready for SDP exchange.
	 */
	CrocMSRP.Events.prototype.onAuthenticated = function() {
	};
	
	/**
	 * Event callback indicating that the provided username/password has been
	 * rejected by the MSRP websocket relay.  The session has been abandoned and
	 * will not retry.
	 */
	CrocMSRP.Events.prototype.onAuthFailed = function() {
	};
	
	/**
	 * Event callback indicating that an unexpected error has occurred, and
	 * that the session has been abandoned as a result.
	 */
	CrocMSRP.Events.prototype.onError = function() {
	};
	
	/**
	 * Event callback indicating that a message has been received for the
	 * session.
	 * 
	 * @param {String} id The Message ID of the received message.
	 * @param {String} contentType The MIME type of the received message.
	 * @param {String|ArrayBuffer|Blob} body The body of the received message.
	 * Text data will be presented as a String. Binary data may be presented
	 * as an ArrayBuffer or a Blob, depending on whether the data fit into a
	 * single chunk. Blob data can be accessed using a FileReader object
	 * (http://www.w3.org/TR/FileAPI/), or used within the page DOM by turning
	 * it into a URL: <code>var url = URL.createObjectURL(blob);</code>.
	 * @throws {CrocMSRP.Exceptions.UnsupportedMedia} If the received MIME type
	 * is not recognised/supported by the application. An appropriate error will
	 * be returned to the relay in this case.
	 */
	CrocMSRP.Events.prototype.onMessageReceived = function(id, contentType, body) {
	};
	
	/**
	 * Event callback indicating that a sent message has been acknowledged by
	 * the MSRP relay.
	 * 
	 * @param {String} id The Message ID of the sent message (as returned
	 * by the {@link CrocMSRP.Session#send} function).
	 */
	CrocMSRP.Events.prototype.onMessageSent = function(id) {
	};
	
	/**
	 * Event callback indicating that a sent message has been delivered
	 * successfully (i.e. a REPORT message has been received from the far end).
	 * 
	 * @param {String} id The Message ID of the delivered message (as
	 * returned by the {@link CrocMSRP.Session#send} function).
	 */
	CrocMSRP.Events.prototype.onMessageDelivered = function(id) {
	};

	/**
	 * Event callback indicating that an outgoing message failed. Possible
	 * reasons include an error response from the relay, an abort from the
	 * receiving party, or a timeout waiting for a REPORT from the receiving
	 * party.
	 * 
	 * @param {String} id The Message ID of the failed message (as returned
	 * by the {@link CrocMSRP.Session#send} function).
	 * @param {String} status The error status returned. If we timed out locally,
	 * this will be set to 408.
	 * @param {String} comment The error comment returned (if present). If we
	 * timed out locally, this will be set to "Report Timeout".
	 */
	CrocMSRP.Events.prototype.onMessageSendFailed = function(id, status, comment) {
	};
	
	/**
	 * Event callback indicating that the first chunk of a message has been
	 * received.  If this message only consists of a single chunk, the
	 * {@link #onChunkReceived} and {@link #onMessageReceived} events will be
	 * fired immediately after this one.
	 * To abort an unfinished transfer, call {@link CrocMSRP.Session#abortFileReceive}.
	 * 
	 * @param {String} id The Message ID of the received chunk.
	 * @param {String} contentType The MIME type of the incoming message.
	 * @param {String} filename The file name, if provided by the far end;
	 * otherwise null.
	 * @param {Number} size The file size in bytes, if provided by the far end;
	 * otherwise -1.
	 * @param {String} description The file description, if provided by the far
	 * end; otherwise null.
	 * @throws {CrocMSRP.Exceptions.UnsupportedMedia} If the received MIME type
	 * is not recognised/supported by the application. An appropriate error will
	 * be returned to the relay in this case.
	 */
	CrocMSRP.Events.prototype.onFirstChunkReceived = function(id, contentType, filename, size, description) {
	};
	
	/**
	 * Event callback indicating that an incoming message chunk has been
	 * received. This is intended to allow the transfer progress to be monitored.
	 * 
	 * @param {String} id The Message ID of the received chunk.
	 * @param {Number} receivedBytes The total bytes received so far. Note that
	 * this may become greater than the reported file size if any chunks have
	 * been resent during the transfer.
	 */
	CrocMSRP.Events.prototype.onChunkReceived = function(id, receivedBytes) {
	};
	
	/**
	 * Event callback indicating that an incoming message has been aborted.
	 * The abort may have been requested by the local or remote party.
	 * 
	 * @param {String} id The Message ID of the aborted message.
	 * @param {Blob} partialBody The partially-received message body.
	 */
	CrocMSRP.Events.prototype.onMessageReceiveAborted = function(id, partialBody) {
	};
	
	/**
	 * Event callback indicating that an incoming message has timed out.
	 * 
	 * @param {String} id The Message ID of the timed-out message.
	 * @param {Blob} partialBody The partially-received message body.
	 */
	CrocMSRP.Events.prototype.onMessageReceiveTimeout = function(id, partialBody) {
	};
	
	/**
	 * Event callback indicating that an outgoing message chunk has been
	 * sent. This is intended to allow the transfer progress to be monitored.
	 * 
	 * @param {String} id The Message ID of the sent chunk (as returned
	 * by the {@link CrocMSRP.Session#send} function).
	 * @param {Number} sentBytes The total bytes sent so far.
	 */
	CrocMSRP.Events.prototype.onChunkSent = function(id, sentBytes) {
	};
	
	CrocMSRP.mandatoryEvents = [
		'onAuthenticated',
		'onAuthFailed',
		'onError',
		'onMessageReceived',
		'onMessageSendFailed',
		'onFirstChunkReceived',
		'onMessageReceiveAborted',
		'onMessageReceiveTimeout',
		'onMessageDelivered'
	];

	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP = (function(CrocMSRP) {

	/**
	 * Encapsulates CrocMSRP exceptions.
	 * @namespace
	 */
	CrocMSRP.Exceptions = {};
	
	/**
	 * Creates an UnsupportedMedia exception.
	 * @class Exception thrown by the application's onMessageReceived callback
	 * if it cannot understand the MIME type of a received SEND request.
	 */
	CrocMSRP.Exceptions.UnsupportedMedia = function() {};
	CrocMSRP.Exceptions.UnsupportedMedia.prototype = new Error();
	CrocMSRP.Exceptions.UnsupportedMedia.prototype.constructor = CrocMSRP.Exceptions.UnsupportedMedia;

	/**
	 * Creates an AbortTransfer exception.
	 * @class Internal exception used to trigger a 413 response to file transfer
	 * chunks.
	 * @private
	 */
	CrocMSRP.Exceptions.AbortTransfer = function() {};
	CrocMSRP.Exceptions.AbortTransfer.prototype = new Error();
	CrocMSRP.Exceptions.AbortTransfer.prototype.constructor = CrocMSRP.Exceptions.AbortTransfer;

	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP = (function(CrocMSRP) {

	/**
	 * Creates a new FileParams object.
	 * @class A FileParams object contains various properties of a file that can
	 * be included in SDP (see RFC 5547). It can be passed to
	 * {@link CrocMSRP.Connection#createFileTransferSession} when creating a
	 * Session to define various properties of the file to be sent. If one is not
	 * provided, some of the details may be determined through other means.
	 * For incoming files, this object is available as
	 * {@link CrocMSRP.Session#fileParams} after having processed the incoming
	 * SDP offer.
	 */
	CrocMSRP.FileParams = function() {
		/**
		 * The file selector, as defined in RFC 5547.  At least one of the
		 * selector properties MUST be defined; in RCS-e it is recommended
		 * that both size and type are included.
		 * @type Object
		 */
		this.selector = {};
		/**
		 * The file name.  Should not include any file path elements, or
		 * characters that may be "meaningful to the local operating system".
		 * @type String
		 * @fieldOf CrocMSRP.FileParams#
		 */
		this.selector.name = '';
		/**
		 * The file size in octets.
		 * @type Number
		 * @fieldOf CrocMSRP.FileParams#
		 */
		this.selector.size = 0;
		/**
		 * The MIME type of the file.  If parameters are present, the object
		 * form is preferred; they may need to be encoded differently depending
		 * on the context.
		 * @type String|CrocMSRP.ContentType
		 * @fieldOf CrocMSRP.FileParams#
		 */
		this.selector.type = '';
		/**
		 * Zero or more hashes of the file contents.  Hashes are added to
		 * this object as properties with the hash algorithm as the property
		 * name (currently only sha1 is supported under RFC 5547), and the
		 * calculated hash as the value (pairs of upper case hex, separated
		 * by colons).
		 * @type Object
		 * @fieldOf CrocMSRP.FileParams#
		 */
		this.selector.hash = {};
		/**
		 * The file-transfer-id, which should uniquely identify the file transfer.
		 * @type String
		 */
		this.id = '';
		/**
		 * The optional file-disposition. Expected values are 'render' (the
		 * default), or 'attachment', though any IANA-registered disposition is
		 * allowed.
		 * @type String
		 */
		this.disposition = '';
		/**
		 * The optional description of the file.
		 * @type String
		 */
		this.description = '';
		/**
		 * The optional cid-url referencing a Content-ID containing a preview of
		 * the file (normally used for image thumbnails).
		 * @type String
		 */
		this.icon = '';
	};
	
	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP = (function(CrocMSRP) {
	var lineEnd = '\r\n';
	
	/**
	 * @namespace Encapsulates all of the MSRP message classes.
	 * @private
	 */
	CrocMSRP.Message = {};
	
	CrocMSRP.Message.Flag = {
		continued: '+',
		end: '$',
		abort: '#'
	};
	
	/**
	 * Creates a new Message object.
	 * @class Parent class for all MSRP messages.
	 * @private
	 */
	CrocMSRP.Message.Message = function() {};
	CrocMSRP.Message.Message.prototype.initMessage = function() {
		this.tid = null;
		this.toPath = [];
		this.fromPath = [];
		this.headers = {};
		this.continuationFlag = CrocMSRP.Message.Flag.end;
	};
	CrocMSRP.Message.Message.prototype.addHeader = function(name, value) {
		name = CrocMSRP.util.normaliseHeader(name);

		// Standard headers are stored in their own properties
		switch (name) {
		case 'To-Path':
			this.toPath = value.split(' ');
			return;
		case 'From-Path':
			this.fromPath = value.split(' ');
			return;
		case 'Content-Type':
			this.contentType = value;
			return;
		default:
			break;
		}
		
		if (this.headers[name]) {
			this.headers[name].push(value);
		} else {
			this.headers[name] = [value];
		}
	};
	CrocMSRP.Message.Message.prototype.getHeader = function(name) {
		name = CrocMSRP.util.normaliseHeader(name);
		if (name in this.headers) {
			if (this.headers[name].length > 1) {
				return this.headers[name];
			}
			return this.headers[name][0];
		}
		return null;
	};
	CrocMSRP.Message.Message.prototype.getEndLineNoFlag = function() {
		return '-------' + this.tid;
	};
	CrocMSRP.Message.Message.prototype.getEndLine = function() {
		return this.getEndLineNoFlag().concat(this.continuationFlag, lineEnd);
	};

	/**
	 * Creates a new Request object.
	 * @class Parent class for all MSRP requests.
	 * @extends CrocMSRP.Message.Message
	 * @private
	 */
	CrocMSRP.Message.Request = function() {};
	CrocMSRP.Message.Request.prototype = new CrocMSRP.Message.Message();
	CrocMSRP.Message.Request.prototype.constructor = CrocMSRP.Message.Request;
	CrocMSRP.Message.Request.prototype.initRequest = function() {
		this.initMessage();
		this.method = null;
		this.contentType = null;
		this.body = null;
	};
	CrocMSRP.Message.Request.prototype.addBody = function(type, body) {
		this.contentType = type;
		this.body = body;
	};
	CrocMSRP.Message.Request.prototype.addTextBody = function(text) {
		this.addBody('text/plain', text);
	};

	/**
	 * Creates a new Response object.
	 * @class Parent class for all MSRP responses.
	 * @extends CrocMSRP.Message.Message
	 * @private
	 */
	CrocMSRP.Message.Response = function() {};
	CrocMSRP.Message.Response.prototype = new CrocMSRP.Message.Message();
	CrocMSRP.Message.Response.prototype.constructor = CrocMSRP.Message.Response;
	CrocMSRP.Message.Response.prototype.initResponse = function() {
		this.initMessage();
		this.status = null;
		this.comment = null;
	};

	/**
	 * Creates a new outgoing MSRP request.
	 * @class Class representing an outgoing MSRP request.
	 * @extends CrocMSRP.Message.Request
	 * @private
	 */
	CrocMSRP.Message.OutgoingRequest = function(session, method) {
		if(!session || !method) {
			throw new TypeError('Required parameter is missing');
		}

		this.initRequest();
		this.tid = CrocMSRP.util.newTID();
		this.method = method;

		this.toPath = session.toPath;
		this.fromPath = [session.localUri];
		this.session = session;
		
		this.byteRange = null;
	};
	CrocMSRP.Message.OutgoingRequest.prototype = new CrocMSRP.Message.Request();
	CrocMSRP.Message.OutgoingRequest.prototype.constructor = CrocMSRP.Message.OutgoingRequest;
	CrocMSRP.Message.OutgoingRequest.prototype.encode = function() {
		var msg = '', name, type = this.contentType,
			end = this.getEndLine();
		
		if (this.body && (this.body instanceof String || typeof this.body === 'string')) {
			// If the body contains the end-line, change the transaction ID
			while (this.body.indexOf(end) !== -1) {
				this.tid = CrocMSRP.util.newTID();
				end = this.getEndLine();
			}
		}
		
		msg = msg.concat('MSRP ', this.tid, ' ', this.method, lineEnd);
		msg = msg.concat('To-Path: ', this.toPath.join(' '), lineEnd);
		msg = msg.concat('From-Path: ', this.fromPath.join(' '), lineEnd);
		
		if (this.byteRange) {
			var r = this.byteRange,
				total = (r.total < 0 ? '*' : r.total);
			this.addHeader('byte-range', r.start + '-' + r.end + '/' + total);
		}
		
		for (name in this.headers) {
			msg = msg.concat(name, ': ', this.headers[name].join(' '), lineEnd);
		}
		
		if (type && this.body) {
			// Content-Type is the last header, and a blank line separates the
			// headers from the message body.
			if (type instanceof CrocMSRP.ContentType) {
				type = type.toContentTypeHeader();
			}
			msg = msg.concat('Content-Type: ', type, lineEnd, lineEnd);
			
			if (this.body instanceof String || typeof this.body === 'string') {
				msg = msg.concat(this.body, lineEnd, end);
			} else {
				// Turn the entire message into a blob, encapsulating the body
				msg = new Blob([msg, this.body, lineEnd, end]);
			}
		} else {
			msg += end;
		}
				
		return msg;
	};

	/**
	 * Creates a new incoming MSRP request.
	 * @class Class representing an incoming MSRP request.
	 * @extends CrocMSRP.Message.Request
	 * @private
	 */
	CrocMSRP.Message.IncomingRequest = function(tid, method) {
		if(!tid || !method) {
			return null;
		}

		this.initRequest();
		this.tid = tid;
		this.method = method;

		switch (method) {
		case 'SEND':
			// Start by assuming responses are required
			// Can be overriden by request headers
			this.responseOn = {success: true, failure: true};
			break;
		case 'REPORT':
			// Never send responses
			this.responseOn = {success: false, failure: false};
			break;
		}
		
		this.byteRange = {start: 1, end: -1, total: -1};
	};
	CrocMSRP.Message.IncomingRequest.prototype = new CrocMSRP.Message.Request();
	CrocMSRP.Message.IncomingRequest.prototype.constructor = CrocMSRP.Message.IncomingRequest;

	/**
	 * Creates a new outgoing MSRP response.
	 * @class Class representing an outgoing MSRP response.
	 * @extends CrocMSRP.Message.Response
	 * @private
	 */
	CrocMSRP.Message.OutgoingResponse = function(request, localUri, status) {
		if(!request || !localUri) {
			return null;
		}

		this.initResponse();
		this.tid = request.tid;
		this.status = status || CrocMSRP.Status.OK;
		this.comment = CrocMSRP.StatusComment[this.status];
		
		if (request.method === 'SEND') {
			// Response is only sent to the previous hop
			this.toPath = request.fromPath.slice(0, 1);
		} else {
			this.toPath = request.fromPath;
		}
		this.fromPath = [localUri.toString()];
	};
	CrocMSRP.Message.OutgoingResponse.prototype = new CrocMSRP.Message.Response();
	CrocMSRP.Message.OutgoingResponse.prototype.constructor = CrocMSRP.Message.OutgoingResponse;
	CrocMSRP.Message.OutgoingResponse.prototype.encode = function() {
		var msg = '', name;
		
		msg = msg.concat('MSRP ', this.tid, ' ', this.status);
		if (this.comment) {
			msg = msg.concat(' ', this.comment);
		}
		msg += lineEnd;
		
		msg = msg.concat('To-Path: ', this.toPath.join(' '), lineEnd);
		msg = msg.concat('From-Path: ', this.fromPath.join(' '), lineEnd);
		
		for (name in this.headers) {
			msg = msg.concat(name, ': ', this.headers[name].join(' '), lineEnd);
		}
		
		return msg + this.getEndLine();
	};

	/**
	 * Creates a new incoming MSRP response.
	 * @class Class representing an incoming MSRP response.
	 * @extends CrocMSRP.Message.Response
	 * @private
	 */
	CrocMSRP.Message.IncomingResponse = function(tid, status, comment) {
		if(!tid || !status) {
			return null;
		}

		this.initResponse();
		this.tid = tid;
		this.status = status;
		this.comment = comment;
		this.request = null;
		this.authenticate = [];
	};
	CrocMSRP.Message.IncomingResponse.prototype = new CrocMSRP.Message.Response();
	CrocMSRP.Message.IncomingResponse.prototype.constructor = CrocMSRP.Message.IncomingResponse;

	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP = (function(CrocMSRP) {
	var lineEnd = '\r\n';
	
	/**
	 * @namespace Encapsulates all of the SDP classes.
	 * @private
	 */
	CrocMSRP.Sdp = {};
	
	CrocMSRP.Sdp.Session = function(sdp) {
		if (sdp) {
			// Parse the provided SDP
			if (!this.parse(sdp)) {
				return null;
			}
		} else {
			// Set some sensible defaults
			this.reset();
		}
	};
	CrocMSRP.Sdp.Session.prototype.reset = function() {
		this.version = 0;
		this.origin = new CrocMSRP.Sdp.Origin();
		this.sessionName = ' ';
		this.sessionInfo = null;
		this.uri = null;
		this.email = null;
		this.phone = null;
		this.connection = new CrocMSRP.Sdp.Connection();
		this.bandwidth = [];
		this.timing = [new CrocMSRP.Sdp.Timing()];
		this.timezone = null;
		this.key = null;
		this.resetAttributes();
		this.media = [];
	};
	CrocMSRP.Sdp.Session.prototype.addAttribute = function(name, value) {
		if (!this.attributes[name]) {
			this.attributes[name] = [];
			this.attributeNameOrder.push(name);
		}
		this.attributes[name].push(value);
	};
	CrocMSRP.Sdp.Session.prototype.removeAttribute = function(name) {
		if (this.attributes[name]) {
			delete this.attributes[name];
			this.attributeNameOrder.splice(
					this.attributeNameOrder.indexOf(name), 1);
		}
	};
	CrocMSRP.Sdp.Session.prototype.replaceAttribute = function(oldName, newName, newValue) {
		if (this.attributes[oldName]) {
			delete this.attributes[oldName];
			this.addAttribute(newName, newValue);
			this.attributeNameOrder.splice(this.attributeNameOrder.lastIndexOf(newName), 1);
			this.attributeNameOrder.splice(
					this.attributeNameOrder.indexOf(oldName), 1, newName);
		}
	};
	CrocMSRP.Sdp.Session.prototype.resetAttributes = function() {
		this.attributeNameOrder = [];
		this.attributes = {};
	};
	CrocMSRP.Sdp.Session.prototype.parse = function(sdp) {
		var line, lines = sdp.split(lineEnd), value, colonIndex, aName;
		
		this.reset();
		
		if (lines[lines.length - 1] === '') {
			// SDP ends in CRLF; remove final array index
			lines.pop();
		}
		
		if (lines.length < 4) {
			console.log('Unexpected SDP length: ' + lines.length);
			return false;
		}
		
		line = lines.shift();
		if (line !== 'v=0') {
			console.log('Unexpected SDP version: ' + line);
			return false;
		}
		
		line = lines.shift();
		if (line.substr(0, 2) !== 'o=' ||
				!(this.origin = new CrocMSRP.Sdp.Origin(line.substr(2)))) {
			console.log('Unexpected SDP origin: ' + line);
			return false;
		}
		
		line = lines.shift();
		if (line.substr(0, 2) === 's=') {
			this.sessionName = line.substr(2);
		} else {
			console.log('Unexpected SDP session name: ' + line);
			return false;
		}
		
		// Process any other optional pre-timing lines
		while (lines.length > 0 && lines[0].charAt(0) !== 't') {
			line = lines.shift();
			value = line.substr(2);
			
			switch (line.substr(0, 2)) {
			case 'i=':
				this.sessionInfo = value;
				break;
			case 'u=':
				this.uri = value;
				break;
			case 'e=':
				this.email = value;
				break;
			case 'p=':
				this.phone = value;
				break;
			case 'c=':
				value = new CrocMSRP.Sdp.Connection(value);
				if (!value) {
					return false;
				}
				this.connection = value;
				break;
			case 'b=':
				this.bandwidth.push(value);
				break;
			default:
				console.log('Unexpected SDP line (pre-timing): ' + line);
				return false;
			}
		}
		
		if (lines.length === 0) {
			console.log('Unexpected end of SDP (pre-timing)');
			return false;
		}
		
		this.timing = [];
		while (lines.length > 0 && lines[0].charAt(0) === 't') {
			line = lines.shift().substr(2);
			// Append any following r-lines
			while (lines.length > 0 && lines[0].charAt(0) === 'r') {
				line += lineEnd + lines.shift();
			}
			
			value = new CrocMSRP.Sdp.Timing(line);
			if (!value) {
				return false;
			}
			this.timing.push(value);
		}

		if (this.timing.length === 0) {
			console.log('No timing line found');
			return false;
		}
		
		// Process any optional pre-media lines
		while (lines.length > 0 && lines[0].charAt(0) !== 'm') {
			line = lines.shift();
			value = line.substr(2);
			
			switch (line.substr(0, 2)) {
			case 'z=':
				this.timezone = value;
				break;
			case 'k=':
				this.key = value;
				break;
			case 'a=':
				colonIndex = value.indexOf(':');
				if (colonIndex === -1) {
					aName = value;
					value = null;
				} else {
					aName = value.substr(0, colonIndex);
					value = value.substr(colonIndex + 1);
				}
				this.addAttribute(aName, value);
				break;
			default:
				console.log('Unexpected SDP line (pre-media): ' + line);
				return false;
			}
		}
		
		while (lines.length > 0 && lines[0].charAt(0) === 'm') {
			line = lines.shift().substr(2);
			// Append any following lines up to the next m-line
			while (lines.length > 0 && lines[0].charAt(0) !== 'm') {
				line += lineEnd + lines.shift();
			}

			value = new CrocMSRP.Sdp.Media(line);
			if (!value) {
				return false;
			}
			this.media.push(value);
		}

		return true;
	};
	CrocMSRP.Sdp.Session.prototype.toString = function() {
		var sdp = '', index, aName, aValues;
		
		sdp += 'v=' + this.version + lineEnd;
		sdp += 'o=' + this.origin + lineEnd;
		sdp += 's=' + this.sessionName + lineEnd;
		if (this.sessionInfo) {
			sdp += 'i=' + this.sessionInfo + lineEnd;
		}
		if (this.uri) {
			sdp += 'u=' + this.uri + lineEnd;
		}
		if (this.email) {
			sdp += 'e=' + this.email + lineEnd;
		}
		if (this.phone) {
			sdp += 'p=' + this.phone + lineEnd;
		}
		if (this.connection) {
			sdp += 'c=' + this.connection + lineEnd;
		}
		for (index in this.bandwidth) {
			sdp += 'b=' + this.bandwidth[index] + lineEnd;
		}
		for (index in this.timing) {
			sdp += 't=' + this.timing[index] + lineEnd;
		}
		if (this.timezone) {
			sdp += 'z=' + this.timezone + lineEnd;
		}
		if (this.key) {
			sdp += 'k=' + this.key + lineEnd;
		}
		for (var i = 0, len = this.attributeNameOrder.length; i < len; i++) {
			aName = this.attributeNameOrder[i];
			aValues = this.attributes[aName];

			for (index in aValues) {
				sdp += 'a=' + aName;
				if (aValues[index]) {
					sdp += ':' + aValues[index];
				}
				sdp += lineEnd;
			}
		}
		for (index in this.media) {
			sdp += 'm=' + this.media[index] + lineEnd;
		}
		
		return sdp;
	};

	CrocMSRP.Sdp.Origin = function(origin) {
		if (origin) {
			// Parse the provided origin line
			if (!this.parse(origin)) {
				return null;
			}
		} else {
			// Set some sensible defaults
			this.reset();
		}
	};
	CrocMSRP.Sdp.Origin.prototype.reset = function() {
		this.username = '-';
		this.id = CrocMSRP.util.dateToNtpTime(new Date());
		this.version = this.sessId;
		this.netType = 'IN';
		this.addrType = 'IP4';
		this.address = 'address.invalid';
	};
	CrocMSRP.Sdp.Origin.prototype.parse = function(origin) {
		var split;
		
		split = origin.split(' ');
		if (split.length !== 6) {
			console.log('Unexpected origin line: ' + origin);
			return false;
		}

		this.username = split[0];
		this.id = split[1];
		this.version = split[2];
		this.netType = split[3];
		this.addrType = split[4];
		this.address = split[5];
		
		return true;
	};
	CrocMSRP.Sdp.Origin.prototype.toString = function() {
		var o = '';
		
		o += this.username + ' ';
		o += this.id + ' ';
		o += this.version + ' ';
		o += this.netType + ' ';
		o += this.addrType + ' ';
		o += this.address;
		
		return o;
	};

	CrocMSRP.Sdp.Connection = function(con) {
		if (con) {
			// Parse the provided connection line
			if (!this.parse(con)) {
				return null;
			}
		} else {
			// Set some sensible defaults
			this.reset();
		}
	};
	CrocMSRP.Sdp.Connection.prototype.reset = function() {
		this.netType = 'IN';
		this.addrType = 'IP4';
		this.address = 'address.invalid';
	};
	CrocMSRP.Sdp.Connection.prototype.parse = function(con) {
		var split;
		
		split = con.split(' ');
		if (split.length !== 3) {
			console.log('Unexpected connection line: ' + con);
			return false;
		}

		this.netType = split[0];
		this.addrType = split[1];
		this.address = split[2];
		
		return true;
	};
	CrocMSRP.Sdp.Connection.prototype.toString = function() {
		var c = '';
		
		c += this.netType + ' ';
		c += this.addrType + ' ';
		c += this.address;
		
		return c;
	};

	CrocMSRP.Sdp.Timing = function(timing) {
		if (timing) {
			// Parse the provided timing line
			if (!this.parse(timing)) {
				return null;
			}
		} else {
			// Set some sensible defaults
			this.reset();
		}
	};
	CrocMSRP.Sdp.Timing.prototype.reset = function() {
		this.start = null;
		this.stop = null;
		this.repeat = [];
	};
	// Parse expects to be passed the full t-line, plus any following r-lines
	CrocMSRP.Sdp.Timing.prototype.parse = function(timing) {
		var lines, tLine, tokens;
		
		lines = timing.split(lineEnd);
		tLine = lines.shift();
		
		tokens = tLine.split(' ');
		if (tokens.length !== 2) {
			console.log('Unexpected timing line: ' + tLine);
			return false;
		}

		if (tokens[0] === '0') {
			this.start = null;
		} else {
			this.start = CrocMSRP.util.ntpTimeToDate(tokens[0]);
		}
		
		if (tokens[1] === '0') {
			this.stop = null;
		} else {
			this.stop =  CrocMSRP.util.ntpTimeToDate(tokens[1]);
		}
		
		// Don't care about repeat lines at the moment
		this.repeat = lines;
		
		return true;
	};
	CrocMSRP.Sdp.Timing.prototype.toString = function() {
		var t = '', index;
		
		if (this.start) {
			t +=  CrocMSRP.util.dateToNtpTime(this.start);
		} else {
			t += '0';
		}
		t += ' ';
		if (this.stop) {
			t +=  CrocMSRP.util.dateToNtpTime(this.stop);
		} else {
			t += '0';
		}
		
		for (index in this.repeat) {
			t += lineEnd + this.repeat[index];
		}
		
		return t;
	};

	CrocMSRP.Sdp.Media = function(media) {
		if (media) {
			// Parse the provided connection line
			if (!this.parse(media)) {
				return null;
			}
		} else {
			// Set some sensible defaults
			this.reset();
		}
	};
	CrocMSRP.Sdp.Media.prototype.reset = function() {
		this.media = 'message';
		this.port = 2855;
		this.proto = 'TCP/MSRP';
		this.format = '*';
		this.title = null;
		this.connection = null;
		this.bandwidth = [];
		this.key = null;
		this.resetAttributes();
	};
	CrocMSRP.Sdp.Media.prototype.addAttribute = function(name, value) {
		if (!this.attributes[name]) {
			this.attributes[name] = [];
			this.attributeNameOrder.push(name);
		}
		this.attributes[name].push(value);
	};
	CrocMSRP.Sdp.Media.prototype.removeAttribute = function(name) {
		if (this.attributes[name]) {
			delete this.attributes[name];
			this.attributeNameOrder.splice(
					this.attributeNameOrder.indexOf(name), 1);
		}
	};
	CrocMSRP.Sdp.Media.prototype.resetAttributes = function() {
		this.attributeNameOrder = [];
		this.attributes = {};
	};
	CrocMSRP.Sdp.Media.prototype.replaceAttribute = function(oldName, newName, newValue) {
		if (this.attributes[oldName]) {
			delete this.attributes[oldName];
			this.addAttribute(newName, newValue);
			this.attributeNameOrder.splice(this.attributeNameOrder.lastIndexOf(newName), 1);
			this.attributeNameOrder.splice(
					this.attributeNameOrder.indexOf(oldName), 1, newName);
		}
	};
	CrocMSRP.Sdp.Media.prototype.parse = function(media) {
		var lines, mLine, tokens, index, aName;
		
		this.reset();
		
		lines = media.split(lineEnd);
		mLine = lines.shift();
		
		tokens = mLine.split(' ');
		if (tokens.length < 4) {
			console.log('Unexpected media line: ' + mLine);
			return false;
		}

		this.media = tokens.shift();
		this.port = parseInt(tokens.shift(), 10);
		this.proto = tokens.shift();
		this.format = tokens.join(' ');
		
		for (index in lines) {
			var value = lines[index].substr(2), colonIndex;
			
			switch (lines[index].substr(0, 2)) {
			case 'i=':
				this.title = value;
				break;
			case 'c=':
				this.connection = new CrocMSRP.Sdp.Connection(value);
				if (!this.connection) {
					return false;
				}
				break;
			case 'b=':
				this.bandwidth.push(value);
				break;
			case 'k=':
				this.key = value;
				break;
			case 'a=':
				colonIndex = value.indexOf(':');
				if (colonIndex === -1) {
					aName = value;
					value = null;
				} else {
					aName = value.substr(0, colonIndex);
					value = value.substr(colonIndex + 1);
				}
				this.addAttribute(aName, value);
				break;
			default:
				console.log('Unexpected type (within media): ' + lines[index]);
				return false;
			}
		}
		
		return true;
	};
	CrocMSRP.Sdp.Media.prototype.toString = function() {
		var m = '', index, aName, aValues;
		
		m += this.media + ' ';
		m += this.port + ' ';
		m += this.proto + ' ';
		m += this.format;
		
		if (this.title) {
			m += lineEnd + 'i=' + this.title;
		}
		if (this.connection) {
			m += lineEnd + 'c=' + this.connection;
		}
		for (index in this.bandwidth) {
			m += lineEnd + 'b=' + this.bandwidth[index];
		}
		if (this.key) {
			m += lineEnd + 'k=' + this.key;
		}
		for (var i = 0, len = this.attributeNameOrder.length; i < len; i++) {
			aName = this.attributeNameOrder[i];
			aValues = this.attributes[aName];

			for (index in aValues) {
				m += lineEnd + 'a=' + aName;
				if (aValues[index]) {
					m += ':' + aValues[index];
				}
			}
		}
		
		return m;
	};

	CrocMSRP.Sdp.parseFileAttributes = function (media) {
		var fileParams = {}, position = 0, selector = {},
			colonIndex, name, value, endIndex,
			fileSelectorString = media.attributes['file-selector'][0];
		
		// Separate the file-selector components
		while (position < fileSelectorString.length) {
			if (fileSelectorString.charAt(position) === ' ') {
				position++;
				continue;
			}
			
			colonIndex = fileSelectorString.indexOf(':', position);
			if (colonIndex === -1) {
				break;
			}

			name = fileSelectorString.slice(position, colonIndex);
			position = colonIndex + 1;
			
			if (fileSelectorString.charAt(position) === '"') {
				// Grab everything within the quotes (possibly including spaces)
				position++;
				endIndex = fileSelectorString.indexOf('"', position);
				if (endIndex === -1) {
					break;
				}
				value = fileSelectorString.slice(position, endIndex);
				position = endIndex + 1;
			} else if (name === 'type') {
				var quoted = false;
				// Further parsing needed; find the next unquoted space
				endIndex = position;
				while (endIndex < fileSelectorString.length &&
						(quoted || fileSelectorString.charAt(endIndex) !== ' ')) {
					if (fileSelectorString.charAt(endIndex) === '"') {
						quoted = !quoted;
					}
					endIndex++;
				}
				value = new CrocMSRP.ContentType();
				value.parseSdpTypeSelector(fileSelectorString.slice(position, endIndex));
				position = endIndex + 1;
			} else {
				// Grab everything until the next space
				endIndex = fileSelectorString.indexOf(' ', position);
				if (endIndex === -1) {
					endIndex = fileSelectorString.length;
				}
				value = fileSelectorString.slice(position, endIndex);
				position = endIndex + 1;
			}
		
			switch (name) {
			case 'name':
				selector.name = CrocMSRP.util.decodeSdpFileName(value);
				break;
			case 'size':
				selector.size = parseInt(value, 10);
				break;
			case 'type':
				selector.type = value;
				break;
			case 'hash':
				if (!selector.hash) {
					selector.hash = {};
				}
				colonIndex = value.indexOf(':');
				selector.hash[value.substring(0, colonIndex)] =
					value.substring(colonIndex + 1);
				break;
			default:
				continue;
			}
		}
		fileParams.selector = selector;
		
		fileParams.id = media.attributes['file-transfer-id'][0];
		fileParams.disposition = media.attributes['file-disposition'][0] || 'render';
		if (media.title) {
			fileParams.description = media.title;
		}
		if (media.attributes['file-icon']) {
			fileParams.icon = media.attributes['file-icon'][0];
		}
		
		return fileParams;
	};
	
	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP = (function(CrocMSRP) {
	var states;

	// Private stuff
	states = {
		AWAIT_CONNECT: 0,
		AWAIT_CHALLENGE: 1,
		AWAIT_AUTH_RES: 2,
		AWAIT_SDP: 3,
		ESTABLISHED: 4,
		ERROR: 5,            // Final state: unrecoverable errors only
		CLOSED: 6
	};
	
	/**
	 * Creates a new Session object.
	 * Note: Session objects should not be created directly. To create a new
	 * session, use {@link CrocMSRP.Connection#createSession}.
	 * @class Represents an MSRP session with a single endpoint via the websocket relay.
	 * A single connection can host many simultaneous sessions.
	 */
	CrocMSRP.Session = function(con, sessionId, localUri, eventObj) {
		var index;
		
		// Check for mandatory methods on the event object
		if (!eventObj) {
			throw 'Event object required';
		}
		for (index in CrocMSRP.mandatoryEvents) {
			if (!eventObj[CrocMSRP.mandatoryEvents[index]]) {
				throw 'Event object missing mandatory event: ' +
					CrocMSRP.mandatoryEvents[index];
			}
		}
		
		// The connection used by this session
		this.con = con;
		// Local reference to the config object
		this.config = con.config;
		// The session ID (as used in the local URI)
		this.sessionId = sessionId;
		// The local endpoint URI for this session
		this.localUri = localUri;
		// The To-Path header for outgoing requests (set later)
		this.toPath = [];
		// The event notification object provided by the parent application
		this.eventObj = eventObj;
		
		initAuth(this);
		
		// Stuff for the SDP
		this.sdpSessId = CrocMSRP.util.dateToNtpTime(new Date());
		this.sdpSessVer = this.sdpSessId;
		// The following are negotiated in the SDP offer/answer
		/**
		 * The primary payload types accepted/understood by the far end.
		 * See RFC 4975 section 8.6.
		 * @type String[]
		 */
		this.acceptTypes = [];
		/**
		 * The payload types accepted/understood by the far end when used within
		 * an allowed container type.
		 * See RFC 4975 section 8.6.
		 * @type String[]
		 */
		this.acceptWrappedTypes = [];
		
		// A map of in-progress incoming chunked messages (indexed on message ID)
		this.chunkReceivers = {};
		this.receiverCheckInterval = null;
		// A map of in-progress outgoing messages (indexed on message ID)
		this.chunkSenders = {};

		// Initialise the session state - after this, everything should use
		// the changeState() function instead.
		this.state = states.AWAIT_CONNECT;
		this.established = false;
		/**
		 * The FileParams object describing the file being transferred in this
		 * session. For outgoing file transfers, this can be provided as a
		 * parameter when creating the session. For incoming transfers, this
		 * is populated when the incoming SDP offer is parsed.
		 * @type CrocMSRP.FileParams
		 * @see CrocMSRP.Connection#createFileTransferSession
		 * @see CrocMSRP.Session#getSdpAnswer
		 */
		this.fileParams = null;
	};

	// Public functions
	/**
	 * Creates an SDP offer for this session.
	 * @returns {String} The SDP offer. If an error is encountered, the return
	 * value will be null.
	 */
	CrocMSRP.Session.prototype.getSdpOffer = function() {
		var sdp, media;

		// Make sure we're in an appropriate state to construct the SDP
		switch (this.state) {
		case states.AWAIT_SDP:
		case states.ESTABLISHED:
			break;
		default:
			return null;
		}
		
		// Prepare the SDP media 'line' for the MSRP session
		media = new CrocMSRP.Sdp.Media();
		media.port = this.localUri.port;
		media.proto = (this.localUri.secure) ? 'TCP/TLS/MSRP' : 'TCP/MSRP';
		media.addAttribute('accept-types', this.config.acceptTypes.join(' '));
		if (this.config.acceptWrappedTypes && this.config.acceptWrappedTypes.length > 0) {
			media.addAttribute('accept-wrapped-types', this.config.acceptWrappedTypes.join(' '));
		}
		media.addAttribute('path', this.relayPath.slice().reverse().join(' ') + ' ' + this.localUri);
		
		if (this.file) {
			// This is an outgoing file transfer session; add extra SDP
			// attributes as per RFC 5547.
			var params = this.fileParams,
				selector = '',
				hash;
			
			params.selector = params.selector || {};
			// One of the following MUST be present for the file-selector
			params.selector.name = params.selector.name || this.file.name;
			params.selector.size = params.selector.size || this.file.size;
			params.selector.type = params.selector.type || this.file.type;
			params.selector.hash = params.selector.hash || {};
			
			params.id = params.id || CrocMSRP.util.newFileTransferId();
			params.disposition = params.disposition || 'render';
			
			if (params.description) {
				media.title = params.description;
			}
			if (params.selector.name) {
				selector = selector.concat('name:"',
					CrocMSRP.util.encodeSdpFileName(params.selector.name), '"');
			}
			if (params.selector.size) {
				if (selector) {
					selector += ' ';
				}
				selector = selector.concat('size:', params.selector.size);
			}
			if (params.selector.type) {
				var type;
				if (selector) {
					selector += ' ';
				}
				if (params.selector.type instanceof CrocMSRP.ContentType) {
					type = params.selector.type.toSdpTypeSelector();
				} else {
					type = params.selector.type;
				}
				selector = selector.concat('type:', type);
			}
			for (hash in params.selector.hash) {
				if (selector) {
					selector += ' ';
				}
				selector = selector.concat('hash:', hash, ':', params.selector.hash[hash]);
			}
			media.addAttribute('file-selector', selector);
			media.addAttribute('file-transfer-id', params.id);
			media.addAttribute('file-disposition', params.disposition);
			if (params.icon) {
				media.addAttribute('file-icon', params.icon);
			}
			media.addAttribute('sendonly', null);
		}
		
		// Construct the entire SDP message, appending the media 'line'
		sdp = new CrocMSRP.Sdp.Session();
		sdp.origin.username = this.config.username;
		sdp.origin.id = this.sdpSessId;
		sdp.origin.version = this.sdpSessVer;
		sdp.origin.address = this.config.authority;
		sdp.connection.address = this.config.authority;
		sdp.media.push(media);
		
		// No state change: we need the answer to finish establishing the session
		return sdp.toString();
	};
	
	/**
	 * Processes an SDP answer for this session.
	 * @param {String} answer The raw SDP answer received from the far end.
	 * @returns {String} The Message-ID of the initial session establishment
	 * message (an empty "ping" message, unless a message or file was provided
	 * when the session was created).  If an error was encountered, the return
	 * value will be null.
	 */
	CrocMSRP.Session.prototype.processSdpAnswer = function(answer) {
		var index, media, sender, msgId;
		
		switch (this.state) {
		case states.AWAIT_SDP:
		case states.ESTABLISHED:
			break;
		default:
			return null;
		}
		
		answer = new CrocMSRP.Sdp.Session(answer);
		if (!answer) {
			return null;
		}
		
		for (index in answer.media) {
			media = answer.media[index];
			
			if (media.media === 'message' && media.port !== 0 &&
					media.attributes['path'] && media.attributes['accept-types']) {
				this.farEndPath = media.attributes['path'][0].split(' ');
				this.toPath = this.relayPath.concat(this.farEndPath);
				this.acceptTypes = media.attributes['accept-types'][0].split(' ');
				if (media.attributes['accept-wrapped-types']) {
					this.acceptWrappedTypes = media.attributes['accept-wrapped-types'][0].split(' ');
				} else {
					this.acceptWrappedTypes = [];
				}
				changeState(this, states.ESTABLISHED);

				if (CrocMSRP.util.isEmpty(this.chunkSenders)) {
					// Complete the session establishment by sending a message
					var session = this;
					if (this.file) {
						// This is a file transfer session; start sending the file
						var params = this.fileParams;
						sender = new CrocMSRP.ChunkSender(this, this.file,
							params.selector.type, params.disposition,
							params.description);
					} else {
						// Empty SEND (see RFC 4975 section 5.4 paragraph 3)
						sender = new CrocMSRP.ChunkSender(this, null);
					}
				
					sender.onReportTimeout = makeTimeoutHandler(session, sender.messageId);
					this.con.addSender(sender);
					this.chunkSenders[sender.messageId] = sender;
					return sender.messageId;
				}

				// Return message ID of the first existing ongoing message sender
				for (msgId in this.chunkSenders) {
					return msgId;
				}
			}
		}
		
		return null;
	};
	
	/**
	 * Creates an SDP answer for this session, given an appropriate offer.
	 * Note: before returning the answer, the application should confirm that
	 * it understands at least one of the MIME types offered by the far end;
	 * otherwise it should return a suitable error response (e.g. SIP 488).
	 * If the incoming SDP offer is for an incoming file transfer, the
	 * {@link CrocMSRP.Session.fileParams} property will be populated. The
	 * application should confirm that it wishes to receive the described
	 * file; otherwise a suitable error response should be returned.
	 * @param {String} offer The raw SDP offer received from the far end.
	 * @returns {String} The SDP answer. If an error is encountered, the return
	 * value will be null.
	 */
	CrocMSRP.Session.prototype.getSdpAnswer = function(offer) {
		var answer, index, media, suitableMediaFound = false;
		
		switch (this.state) {
		case states.AWAIT_SDP:
		case states.ESTABLISHED:
			break;
		default:
			return null;
		}

		// Start with the offer
		answer = new CrocMSRP.Sdp.Session(offer);
		if (!answer) {
			return null;
		}
		
		// Update the origin
		answer.origin.username = this.config.username;
		answer.origin.id = this.sdpSessId;
		answer.origin.version = this.sdpSessVer;
		answer.origin.address = this.config.authority;
		
		// If connection is present, update it
		if (answer.connection) {
			answer.connection.address = this.config.authority;
		}
		
		// Find and process the first MSRP media we recognise; reject everything else
		for (index in answer.media) {
			media = answer.media[index];
			
			if (!suitableMediaFound && media.media === 'message' && media.port !== 0 &&
					(media.proto === 'TCP/MSRP' || media.proto === 'TCP/TLS/MSRP') &&
					media.attributes['path'] && media.attributes['accept-types']) {
				// Process the SDP attributes we need
				this.farEndPath = media.attributes['path'][0].split(' ');
				this.toPath = this.relayPath.concat(this.farEndPath);
				this.acceptTypes = media.attributes['accept-types'][0].split(' ');
				if (media.attributes['accept-wrapped-types']) {
					this.acceptWrappedTypes = media.attributes['accept-wrapped-types'][0].split(' ');
				} else {
					this.acceptWrappedTypes = [];
				}
				if (media.attributes['file-selector']) {
					// Incoming file transfer: extract provided info so the
					// application/user can make an informed decision on
					// whether or not to accept the file.
					this.fileParams = CrocMSRP.Sdp.parseFileAttributes(media);
					media.replaceAttribute('sendonly', 'recvonly', null);
				}
				changeState(this, states.ESTABLISHED);
				suitableMediaFound = true;
				
				// Now set the media answer values
				media.resetAttributes();
				media.port = this.localUri.port;
				media.proto = (this.localUri.secure) ? 'TCP/TLS/MSRP' : 'TCP/MSRP';
				media.addAttribute('accept-types', this.config.acceptTypes.join(' '));
				if (this.config.acceptWrappedTypes &&
						this.config.acceptWrappedTypes.length > 0) {
					media.addAttribute('accept-wrapped-types',
						this.config.acceptWrappedTypes.join(' '));
				}
				media.addAttribute('path', this.relayPath.slice().reverse().join(' ') + ' ' + this.localUri);
			} else {
				media.port = 0;
			}
		}
		
		return answer.toString();
	};
	
	/**
	 * Sends a message (or file) over an established session.
	 * @param {String|ArrayBuffer|ArrayBufferView|Blob|File} body The message
	 * body to send (may be binary data/file).
	 * @param {String} [contentType] The MIME type of the provided body.
	 * @returns {String} The Message-ID of the sent message. This can be used
	 * to correlate notifications with the appropriate message.
	 */
	CrocMSRP.Session.prototype.send = function(body, contentType) {
		var type, sender, session = this;
		if (!this.established) {
			throw 'Unable to send, session not yet established';
		}
		
		// Determine content type & size
		if (body instanceof String || typeof body === 'string') {
			type = contentType || 'text/plain';
		} else if (body instanceof Blob) {
			type = contentType || body.type || 'application/octet-stream';
		} else { // ArrayBuffer or view
			type = contentType || 'application/octet-stream';
		}
		
		sender = new CrocMSRP.ChunkSender(this, body, type);
		sender.onReportTimeout = makeTimeoutHandler(session, sender.messageId);
		this.con.addSender(sender);
		this.chunkSenders[sender.messageId] = sender;

		return sender.messageId;
	};
	
	/**
	 * Aborts an ongoing message receive.
	 * @param {String} [id] The ID of the message to abort.  If this is
	 * not specified then all incoming messages will be aborted.
	 */
	CrocMSRP.Session.prototype.abortReceive = function(id) {
		if (id) {
			var receiver = this.chunkReceivers[id];
			if (!receiver) {
				throw new RangeError('Invalid message id');
			}
			
			receiver.abort();
		} else {
			for (id in this.chunkReceivers) {
				this.chunkReceivers[id].abort();
			}
		}
		// Cleanup will happen when the next chunk is received
	};

	/**
	 * Aborts an ongoing message send.
	 * @param {String} [id] The ID of the message to abort.  If this is
	 * not specified then all outgoing sends will be aborted.
	 */
	CrocMSRP.Session.prototype.abortSend = function(id) {
		if (id) {
			var sender = this.chunkSenders[id];
			if (!sender) {
				throw new RangeError('Invalid message id');
			}
			
			sender.abort();
		} else {
			for (id in this.chunkSenders) {
				this.chunkSenders[id].abort();
			}
		}
		// Cleanup will happen when the next chunk is sent/report is received
	};

	/**
	 * Closes the session. Further messages received for this session will be
	 * rejected.
	 */
	CrocMSRP.Session.prototype.close = function() {
		this.abortReceive();
		this.abortSend();
		changeState(this, states.CLOSED);
	};

	// Internal events
	CrocMSRP.Session.prototype.onWsConnect = function() {
		sendAuth(this);
	};
	
	CrocMSRP.Session.prototype.onWsError = function() {
		// Wait for a new connection
		changeState(this, states.AWAIT_CONNECT);
	};
	
	CrocMSRP.Session.prototype.onIncomingSend = function(req) {
		var msgId, description = null, filename = null, size = -1, chunkReceiver;
		
		try {
			if (req.byteRange.start === 1 &&
					req.continuationFlag === CrocMSRP.Message.Flag.end) {
				// Non chunked message, but check whether it is an empty 'ping'
				if (req.body) {
					// Complete non-chunked, non-empty message

					// These are not required to have a Message-ID; create
					// one if it is not provided.
					msgId = req.messageId || CrocMSRP.util.newMID();
					size = req.byteRange.total;

					if (req.contentDisposition &&
							(req.contentDisposition.type === 'attachment' ||
							req.contentDisposition.type === 'render')) {
						// File transfer, extract any extra details
						description = req.getHeader('content-description');
						filename = req.contentDisposition.param.filename;
					}

					// Fire the appropriate event handlers
					this.eventObj.onFirstChunkReceived(msgId, req.contentType,
							filename, size, description);
					if (this.eventObj.onChunkReceived) {
						this.eventObj.onChunkReceived(msgId, size);
					}
					this.eventObj.onMessageReceived(msgId, req.contentType,
							req.body);
				}
			} else {
				// Chunk of a multiple-chunk message
				msgId = req.messageId;
				if (!msgId || !(msgId instanceof String || typeof msgId === 'string')) {
					sendResponse(req, this.con, this.localUri, CrocMSRP.Status.BAD_REQUEST);
					return;
				}
				
				if (req.byteRange.start === 1 &&
						req.continuationFlag === CrocMSRP.Message.Flag.continued) {
					// First chunk
					chunkReceiver = new CrocMSRP.ChunkReceiver(req, this.config.recvBuffer);
					description = req.getHeader('content-description') || null;
					filename = req.contentDisposition.param.filename || null;

					// The following may throw an UnsupportedMedia exception
					this.eventObj.onFirstChunkReceived(msgId, req.contentType,
						filename, req.byteRange.total, description);

					// The application has not rejected it, so add it to the list of
					// current receivers.
					this.chunkReceivers[msgId] = chunkReceiver;
					
					// Kick off the chunk receiver poll if it's not already running
					if (!this.receiverCheckInterval) {
						var session = this;
						this.receiverCheckInterval = setInterval(
							function() {
								checkReceivers(session);
							}, 1000
						);
					}
				} else {
					// Subsequent chunk
					chunkReceiver = this.chunkReceivers[msgId];
					if (!chunkReceiver) {
						// We assume we will receive chunk one first
						// We could allow out-of-order, but probably not worthwhile
						sendResponse(req, this.con, this.localUri, CrocMSRP.Status.STOP_SENDING);
						return;
					}
					
					if (!chunkReceiver.processChunk(req)) {
						// Message receive has been aborted
						delete this.chunkReceivers[msgId];

						if (chunkReceiver.remoteAbort) {
							// TODO: what's the appropriate response to an abort?
							sendResponse(req, this.con, this.localUri, CrocMSRP.Status.STOP_SENDING);
						} else {
							// Notify the far end of the abort
							sendResponse(req, this.con, this.localUri, CrocMSRP.Status.STOP_SENDING);
						}

						// Notify the application of the abort
						try {
							this.eventObj.onMessageReceiveAborted(msgId, chunkReceiver.blob);
						} catch (e) {
							console.warn('Unexpected application exception: ' + e.stack);
						}

						return;
					}
				}
					
				if (chunkReceiver.isComplete()) {
					delete this.chunkReceivers[msgId];
					var blob = chunkReceiver.blob;
					this.eventObj.onMessageReceived(msgId, blob.type, blob);
				} else {
					// Receive ongoing
					if (this.eventObj.onChunkReceived) {
						this.eventObj.onChunkReceived(msgId, chunkReceiver.receivedBytes);
					}
				}
			}
		} catch (e) {
			// Send an error response, but check which status to return
			var status = CrocMSRP.Status.INTERNAL_SERVER_ERROR;
			if (e instanceof CrocMSRP.Exceptions.UnsupportedMedia) {
				status = CrocMSRP.Status.UNSUPPORTED_MEDIA;
			} else {
				console.warn('Unexpected application exception: ' + e.stack);
			}
			sendResponse(req, this.con, this.localUri, status);
			return;
		}

		// Send success response
		sendResponse(req, this.con, this.localUri, CrocMSRP.Status.OK);
		
		// Send REPORT if requested
		if (req.getHeader('success-report') === 'yes') {
			sendReport(this, req);
		}
	};
	
	CrocMSRP.Session.prototype.onIncomingReport = function(report) {
		var msgId, sender;

		msgId = report.messageId;
		if (!msgId) {
			console.log('Invalid REPORT: no message id');
			return;
		}
		
		// Check whether this is for a chunk sender first
		sender = this.chunkSenders[msgId];
		if (!sender) {
			console.log('Invalid REPORT: unknown message id');
			// Silently ignore, as suggested in 4975 section 7.1.2
			return;
		}

		// Let the chunk sender handle the report
		sender.processReport(report);
		if (!sender.isComplete()) {
			// Still expecting more reports, no notification yet
			return;
		}
		
		// All chunks have been acknowledged; clean up
		delete this.chunkSenders[msgId];

		// Don't notify for locally aborted messages
		if (sender.aborted && !sender.remoteAbort) {
			return;
		}
		
		// Notify the application
		try {
			if (report.status === CrocMSRP.Status.OK) {
				if (this.eventObj.onMessageDelivered) {
					this.eventObj.onMessageDelivered(msgId);
				}
			} else {
				this.eventObj.onMessageSendFailed(msgId, report.status, report.comment);
			}
		} catch (e) {
			console.warn('Unexpected application exception: ' + e.stack);
		}
	};
	
	CrocMSRP.Session.prototype.onIncomingResponse = function(resp) {
		var msgId;

		if (resp.request.method === 'AUTH') {
			switch (resp.status) {
			case CrocMSRP.Status.UNAUTHORIZED:
				if (this.state === states.AWAIT_AUTH_RES) {
					// Another challenge - treat as a failure
					changeState(this, states.AUTH_FAILED);
				} else {
					sendAuth(this, resp);
				}
				break;
			case CrocMSRP.Status.OK:
				processAuthRes(this, resp);
				break;
			case CrocMSRP.Status.INTERVAL_OUT_OF_BOUNDS:
				// Expires header out-of-bounds, set to the min/max
				this.config.authExpires = resp.expires;
				// Try again
				sendAuth(this);
				break;
			default:
				changeState(this, states.AUTH_FAILED);
				break;
			}
			return;
		}
		
		// Otherwise it's a SEND response
		msgId = resp.request.getHeader('message-id');
		if (!msgId) {
			console.log('Can\'t retrieve SEND message id');
			return;
		}

		var sender = resp.request.sender;
		if (resp.status === CrocMSRP.Status.OK) {
			try {
				if (!sender.aborted && this.eventObj.onChunkSent) {
					this.eventObj.onChunkSent(msgId, resp.request.byteRange.end);
				}

				if (resp.request.continuationFlag === CrocMSRP.Message.Flag.end &&
						this.eventObj.onMessageSent) {
					// Notify the application
					this.eventObj.onMessageSent(msgId);
				}
			} catch (e) {
				console.warn('Unexpected application exception: ' + e.stack);
			}
		} else {
			// Failure response
			sender.abort();
			sender.remoteAbort = true;
			// Don't expect any more REPORTs
			delete this.chunkSenders[msgId];
			// Sender will be removed from Connection.activeSenders later

			// Notify the application
			try {
				this.eventObj.onMessageSendFailed(msgId, resp.status, resp.comment);
			} catch (e) {
				console.warn('Unexpected application exception: ' + e.stack);
			}
		}
	};
	
	// Private functions
	function makeTimeoutHandler(session, msgId) {
		return function() {
			delete session.chunkSenders[msgId];
			// Notify the application
			try {
				session.eventObj.onMessageSendFailed(msgId, CrocMSRP.Status.REQUEST_TIMEOUT, 'Report Timeout');
			} catch (e) {
				console.warn('Unexpected application exception: ' + e.stack);
			}
		};
	}

	function changeState(session, state) {
		console.log('Change session state: sessionId=' + session.sessionId + ', old=' + session.state + ', new=' + state);
		session.state = state;

		switch (state) {
		case states.AWAIT_CONNECT:
			session.established = false;
			initAuth(session);
			break;
		case states.AWAIT_CHALLENGE:
		case states.AWAIT_AUTH_RES:
			// May remain established whilst reauthenticating
			break;
		case states.AWAIT_SDP:
			// May remain established whilst reauthenticating
			session.sdpSessVer = CrocMSRP.util.dateToNtpTime(new Date());
			try {
				session.eventObj.onAuthenticated();
			} catch (e) {
				console.warn('Unexpected application exception: ' + e.stack);
			}
			break;
		case states.ESTABLISHED:
			if (!session.established && !CrocMSRP.util.isEmpty(this.chunkSenders)) {
				// Resume outgoing transfers from the acknowledged position
				var msgId;
				for (msgId in this.chunkSenders) {
					this.chunkSenders[msgId].resume();
				}
			}
			session.established = true;
			// Nothing to do here
			break;
		case states.AUTH_FAILED:
			session.established = false;
			initAuth(session);
			try {
				session.eventObj.onAuthFailed();
			} catch (e) {
				console.warn('Unexpected application exception: ' + e.stack);
			}
			session.con.removeSession(session.sessionId);
			break;
		case states.ERROR:
			session.established = false;
			initAuth(session);
			try {
				session.eventObj.onError();
			} catch (e) {
				console.warn('Unexpected application exception: ' + e.stack);
			}
			session.con.removeSession(session.sessionId);
			break;
		case states.CLOSED:
			session.established = false;
			initAuth(session);
			session.con.removeSession(session.sessionId);
			break;
		default:
			console.error('Invalid state: ' + state);
			changeState(session, states.ERROR);
			break;
		}
	}
	
	function initAuth(session) {
		// (re)Initialise any properties used by the authentication process

		// Clear the auth timer if it's running
		if (session.authTimer) {
			clearTimeout(session.authTimer);
			session.authTimer = null;
		}
		// As we receive relay URIs they will be appended here, and the toPath reconstructed
		session.relayPath = [];
		// Once SDP negotiation has provided the far end path, it will be stored
		// here, and appended to the toPath.
		session.farEndPath = [];
	}
	
	function sendAuth(session, resp) {
		var authReq;
		
		authReq = new CrocMSRP.Message.OutgoingRequest(session, 'AUTH');
		
		// Override the To-Path of the request
		authReq.toPath = [session.config.relayMsrpUri];

		if (resp) {
			var index, authorisation = null;
				
			if (!resp.authenticate) {
				console.log('Auth failed: no WWW-Authenticate header available');
				changeState(session, states.ERROR);
				return;
			}
			
			for (index in resp.authenticate) {
				authorisation = CrocMSRP.digestAuthentication(session.config,
					resp.request, resp.authenticate[index]);
				if (authorisation) {
					break;
				}
			}
			
			if (!authorisation || authorisation.length === 0) {
				console.log('Construction of authorization failed');
				changeState(session, states.ERROR);
				return;
			}
			
			authReq.addHeader('authorization', authorisation);
			changeState(session, states.AWAIT_AUTH_RES);
		} else {
			changeState(session, states.AWAIT_CHALLENGE);
		}
		
		if (session.config.authExpires) {
			// Set the requested auth duration
			authReq.addHeader('expires', session.config.authExpires);
		}
		
		session.con.ws.send(authReq);
	}

	function processAuthRes(session, resp) {
		if (!resp.usePath) {
			console.log('Use-Path header missing!');
			changeState(session, states.ERROR);
			return;
		}
		
		session.relayPath = resp.usePath;
		session.authTimer = setTimeout(
			function() {
				session.authTimer = null;
				initAuth(session);
				sendAuth(session);
			}, (resp.expires - 30) * 1000);
		
		changeState(session, states.AWAIT_SDP);
	}
	
	function sendResponse(req, con, uri, status) {
		if (status === CrocMSRP.Status.OK) {
			if (!req.responseOn.success) {
				return;
			}
		} else {
			if (!req.responseOn.failure) {
				return;
			}
		}
		
		con.ws.send(new CrocMSRP.Message.OutgoingResponse(req, uri, status));
	}
	
	function sendReport(session, req) {
		var report;
		
		report = new CrocMSRP.Message.OutgoingRequest(session, 'REPORT');
		report.addHeader('message-id', req.messageId);
		report.addHeader('status', '000 200 OK');

		if (req.byteRange ||
				req.continuationFlag === CrocMSRP.Message.Flag.continued) {
			// A REPORT Byte-Range will be required
			var start = 1, end, total = -1;
			if (req.byteRange) {
				// Don't trust the range end
				start = req.byteRange.start;
				total = req.byteRange.total;
			}
			if (!req.body) {
				end = 0;
			} else if (req.body instanceof ArrayBuffer) {
				// Yay! Binary frame: the length is obvious.
				end = start + req.body.byteLength - 1;
			} else {
				// Boo. Text frame: turn it back into UTF-8 and cross your fingers
				// that the resulting bytes (and length) are what they should be.
				var blob = new Blob([req.body]);
				end = start + blob.size - 1;
				// blob.close();
			}
			
			if (end !== req.byteRange.end) {
				console.warn('Report Byte-Range end does not match request');
			}
			
			report.byteRange = {'start': start, 'end': end, 'total': total};
		}
		
		session.con.ws.send(report);
	}
	
	function checkReceivers(session) {
		var msgId, receiver,
			now = new Date().getTime(),
			timeout = session.config.chunkTimeout;
		for (msgId in session.chunkReceivers) {
			receiver = session.chunkReceivers[msgId];
			if (now - receiver.lastReceive > timeout) {
				// Clean up the receiver
				receiver.abort();
				delete session.chunkReceivers[msgId];
				try {
					session.eventObj.onMessageReceiveTimeout(msgId, receiver.blob);
				} catch (e) {
					console.warn('Unexpected application exception: ' + e.stack);
				}
			}
		}
		
		if (CrocMSRP.util.isEmpty(session.chunkReceivers)) {
			clearInterval(session.receiverCheckInterval);
			session.receiverCheckInterval = null;
		}
	}
	
	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP = (function(CrocMSRP) {
	/** @constant */
	CrocMSRP.Status = {
		OK: 200,
		BAD_REQUEST: 400,
		UNAUTHORIZED: 401,
		FORBIDDEN: 403,
		REQUEST_TIMEOUT: 408,
		STOP_SENDING: 413,
		UNSUPPORTED_MEDIA: 415,
		INTERVAL_OUT_OF_BOUNDS: 423,
		SESSION_DOES_NOT_EXIST: 481,
		INTERNAL_SERVER_ERROR: 500, // Not actually defined in spec/registry!
		NOT_IMPLEMENTED: 501,
		WRONG_CONNECTION: 506
	};
	
	/** @constant */
	CrocMSRP.StatusComment = {
		200: 'OK',
		400: 'Bad Request',
		401: 'Unauthorized',
		403: 'Forbidden',
		408: 'Request Timeout',
		413: 'Stop Sending Message',
		415: 'Unsupported Media Type',
		423: 'Interval Out-of-Bounds',
		481: 'Session Does Not Exist',
		500: 'Internal Server Error', // Not actually defined in spec/registry!
		501: 'Not Implemented',
		506: 'Wrong Connection'
	};
	
	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP = (function(CrocMSRP) {

	CrocMSRP.Uri = function(uri) {
		this.secure = false;
		this.user = null;
		this.authority = '';
		this.port = null;
		this.sessionId = '';
		this.transport = 'tcp';
		
		if (uri) {
			this.uri = uri;
			this.parse(uri);
		}
	};

	CrocMSRP.Uri.prototype.parse = function(uri) {
		var colonIndex = uri.indexOf('://'),
			scheme, atIndex, portSepIndex, pathIndex, semicolonIndex;
		
		if (colonIndex === -1) {
			throw new TypeError('Invalid MSRP URI: ' + uri);
		}
		
		// Extract the scheme first
		scheme = uri.substring(0, colonIndex);
		switch (scheme.toLowerCase()) {
		case 'msrp':
			this.secure = false;
			break;
		case 'msrps':
			this.secure = true;
			break;
		default:
			throw new TypeError('Invalid MSRP URI (unknown scheme): ' + uri);
		}
		
		// Start by assuming that the authority is everything between "://" and "/"
		pathIndex = uri.indexOf('/', colonIndex + 3);
		if (pathIndex === -1) {
			throw new TypeError('Invalid MSRP URI (no session ID): ' + uri);
		}
		this.authority = uri.substring(colonIndex + 3, pathIndex);
		
		// If there's an "@" symbol in the authority, extract the user
		atIndex = this.authority.indexOf('@');
		if (atIndex !== -1) {
			this.user = this.authority.substr(0, atIndex);
			this.authority = this.authority.substr(atIndex + 1);
		}
		
		// If there's an ":" symbol in the authority, extract the port
		portSepIndex = this.authority.indexOf(':');
		if (portSepIndex !== -1) {
			this.port = this.authority.substr(portSepIndex + 1);
			this.authority = this.authority.substr(0, portSepIndex);
		}
		
		// Finally, separate the session ID from the transport
		semicolonIndex = uri.indexOf(';', colonIndex + 3);
		if (semicolonIndex === -1) {
			throw new TypeError('Invalid MSRP URI (no transport): ' + uri);
		}
		this.sessionId = uri.substring(pathIndex + 1, semicolonIndex);
		this.transport = uri.substring(semicolonIndex + 1);
		
		return true;
	};

	CrocMSRP.Uri.prototype.toString = function() {
		var uri = 'msrp';
		
		if (this.uri) {
			// Return the cached URI
			return this.uri;
		}
		
		if (this.secure) {
			uri += 's';
		}
		
		uri += '://';

		if (this.user) {
			uri += this.user + '@';
		}
		
		uri += this.authority;

		if (this.port) {
			uri += ':' + this.port;
		}
		
		uri += '/' + this.sessionId + ';' + this.transport;
		
		this.uri = uri;
		return uri;
	};
	
	CrocMSRP.Uri.prototype.equals = function(uri) {
		if (typeof uri === 'string' || uri instanceof String) {
			uri = new CrocMSRP.Uri(uri);
		}
		
		if (!uri instanceof Object) {
			return false;
		}
		
		if (uri.secure !== this.secure) {
			return false;
		}
		
		// Strictly we should be checking whether percent-encoding normalisation
		// is needed, but it's not likely to be needed.
		if (uri.authority.toLowerCase() !== this.authority.toLowerCase()) {
			return false;
		}
		
		if (parseInt(uri.port, 10) !== parseInt(this.port, 10)) {
			return false;
		}
		
		if (uri.sessionId !== this.sessionId) {
			return false;
		}
		
		if (uri.transport.toLowerCase() !== this.transport.toLowerCase()) {
			return false;
		}
		
		return true;
	};

	return CrocMSRP;
}(CrocMSRP || {}));


/* jshint unused:vars */

var CrocMSRP = (function(CrocMSRP) {
	var states;
	
	states = {
		INIT: 0,
		CONNECTING: 1,
		CONNECTED: 2,
		ERROR: 3,
		DISCONNECTING: 4,
		DISCONNECTED: 5
	};
	
	CrocMSRP.WSWrapper = function(con, relayUri) {
		this.con = con;
		this.relayUri = relayUri;

		this.state = states.INIT;

		this.ws = null;
		// Object for tracking outstanding transaction IDs (for sent requests)
		this.transactions = {};
		
		this.connect();
	};

	CrocMSRP.WSWrapper.prototype.isConnected = function() {
		return this.state === states.CONNECTED;
	};

	CrocMSRP.WSWrapper.prototype.connect = function() {
		var ws, wrapper = this;

		this.state = states.CONNECTING;
		console.log("Attempting WebSocket Connection to " + this.relayUri);
		
		try {
			ws = new WebSocket(this.relayUri, 'msrp');
		} catch (e) {
			console.log("Connection error: " + e);
			return false;
		}
		
		// We expect relatively small messages, so hint to keep in memory
		ws.binaryType = "arraybuffer";
		
		// Register callbacks
		ws.onopen = function(e) { wrapper.onOpen(e); };
		ws.onerror = function(e) { wrapper.onError(e); };
		ws.onclose = function(e) { wrapper.onClose(e); };
		ws.onmessage = function(e) { wrapper.onMessage(e); };
		
		this.running = true;
		this.ws = ws;
		
		return true;
	};

	CrocMSRP.WSWrapper.prototype.disconnect = function() {
		this.state = states.DISCONNECTING;
		if (this.ws) {
			this.ws.close();
		}
	};

	CrocMSRP.WSWrapper.prototype.send = function(message) {
		var wsWrapper = this;
		if (this.state !== states.CONNECTED || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
			console.log("Send failed: socket not ready");
			return false;
		}
		
		if (message instanceof CrocMSRP.Message.Request && message.method !== 'REPORT') {
			message.timer = setTimeout(function(){timeout(wsWrapper, message);}, 30000);
			this.transactions[message.tid] = message;
		}
		
		try {
			this.ws.send(message.encode());
		} catch (e) {
			console.log("Send failed: " + e);
			return false;
		}
		
		return true;
	};

	CrocMSRP.WSWrapper.prototype.onOpen = function(event) {
		this.state = states.CONNECTED;
		this.con.onWsConnect();
	};

	CrocMSRP.WSWrapper.prototype.onError = function(event) {
		// This should be followed by onClose, so don't need to do much here
		this.state = states.ERROR;
		console.log('WebSocket error');
	};

	CrocMSRP.WSWrapper.prototype.onClose = function(event) {
		if (this.state === states.DISCONNECTING) {
			// Report the successful disconnect
			this.con.onWsDisconnect();
		} else {
			console.warn("WebSocket closed unexpectedly: wasClean=" + event.wasClean + " code=" + event.code);
			// Report the failure
			this.con.onWsError();
		}
		this.state = states.DISCONNECTED;
	};

	CrocMSRP.WSWrapper.prototype.onMessage = function(event) {
		// Parse MSRP message
		var msg = CrocMSRP.parseMessage(event.data);
		if (!msg) {
			// Oh dear
			this.state = states.ERROR;
			console.log('MSRP message parsing error; closing websocket');
			this.ws.close();
			return;
		}
		
		if (msg instanceof CrocMSRP.Message.Response) {
			// Check for outstanding transaction
			msg.request = this.transactions[msg.tid];
			if (msg.request) {
				clearTimeout(msg.request.timer);
				delete msg.request.timer;
				delete this.transactions[msg.tid];
				this.con.onMsrpResponse(msg);
			} else {
				console.log("Unexpected response received; not in transaction list");
			}
			return;
		}
		
		// Send requests up to the con
		this.con.onMsrpRequest(msg);
	};

	function timeout(wsWrapper, request) {
		delete request.timer;
		delete wsWrapper.transactions[request.tid];
		var resp = new CrocMSRP.Message.IncomingResponse(request.tid, 408, CrocMSRP.StatusComment[408]);
		resp.request = request;
		wsWrapper.con.onMsrpResponse(resp);
	}
	
	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP;

var CrocMSRP = (function(CrocMSRP) {
	var paramSep = ', ';
	var md5 = typeof JsSIP === 'undefined' ? hex_md5 : JsSIP.Utils.calculateMD5;
	
	/**
	 * Performs HTTP digest authentication.
	 * @private
	 */
	CrocMSRP.digestAuthentication = function(config, req, authenticate) {
		var authorization = 'Digest ',
			digestUri = req.toPath[req.toPath.length - 1],
			qop = null,
			nc = '00000001',
			cnonce = Math.random().toString(36).substr(2, 12),
			HA1, HA2, response;
		
		if (authenticate.qop) {
			if (authenticate.qop.split(' ').indexOf('auth') !== -1) {
				qop = 'auth';
			}
		}

		authorization += 'username="' + config.username + '"';
		authorization += paramSep + 'realm="' + authenticate.realm + '"';
		authorization += paramSep + 'nonce="' + authenticate.nonce + '"';
		authorization += paramSep + 'uri="' + digestUri + '"';
		
		// HA1 = MD5(A1) = MD5(username:realm:password)
		HA1 = md5(config.username + ':' + authenticate.realm + ':' + config.password);
		// HA2 = MD5(A2) = MD5(method:digestUri)
		// Some confusion over what to use as the method; Kamailio uses "MSRP"
		if (config.digestMethod) {
			HA2 = md5(config.digestMethod + ':' + digestUri);
		} else {
			HA2 = md5(req.method + ':' + digestUri);
		}

		if (qop) {
			// response = MD5(HA1:nonce:nc:cnonce:qop:HA2)
			response = md5(HA1 + ':' + authenticate.nonce + ':' + nc + ':' + cnonce + ':auth:' + HA2);
		} else {
			// response = MD5(HA1:nonce:HA2)
			response = md5(HA1 + ':' + authenticate.nonce + ':' + HA2);
		}
		authorization += paramSep + 'response="' + response + '"';
		
		if (authenticate.algorithm) {
			if (authenticate.algorithm !== 'MD5') {
				console.log('Auth failure: unsupported "algorithm" parameter in challenge');
				return null;
			}
			authorization += paramSep + 'algorithm=MD5';
		}
		
		if (qop) {
			authorization += paramSep + 'qop=' + qop;
			authorization += paramSep + 'cnonce="' + cnonce + '"';
			authorization += paramSep + 'nc=' + nc;
		}

		if (authenticate.opaque) {
			authorization += paramSep + 'opaque="' + authenticate.opaque + '"';
		}
		
		return authorization;
	};
	
	return CrocMSRP;
}(CrocMSRP));


var CrocMSRP = (function(CrocMSRP) {
	var lineEnd = '\r\n';
	
	/**
	 * Parses a raw websocket message and returns a Message object.
	 * @param {String|ArrayBuffer} data Event data from the onmessage websocket event.
	 * @returns {CrocMSRP.Message.Message} Message object, or null if there an
	 * error is encountered.
	 * @private
	 */
	CrocMSRP.parseMessage = function(data) {
		var msg, startIndex = 0, endIndex, firstLine, tokens, statusCode, msgObj,
			parseResult, endLineNoFlag;
		
		if (data instanceof ArrayBuffer) {
			// Turn the ArrayBuffer into a string, assuming one-byte chars
			// The body will get sliced out once we locate it
			msg = String.fromCharCode.apply(null, new Uint8Array(data)); 
		} else if (data instanceof String || typeof data === 'string') {
			msg = data;
		} else {
			console.log('Unexpected parameter type');
			return null;
		}
		
		// Extract and parse the first line
		endIndex = msg.indexOf(lineEnd);
		if (endIndex === -1) {
			console.log('Error parsing message: no CRLF');
			return null;
		}
		
		firstLine = msg.substring(startIndex, endIndex);
		tokens = firstLine.split(' ');
		if (tokens.length < 3 || tokens[0] !== 'MSRP' ||
				tokens[1].length === 0 || tokens[2].length === 0) {
			console.log('Error parsing message: unexpected first line format: ' + firstLine);
			return null;
		}
		
		// Determine whether it is a request or response and construct the
		// appropriate object
		if (tokens[2].length === 3 && (statusCode = parseInt(tokens[2], 10))) {
			if (tokens.length > 3) {
				var comment = tokens.slice(3).join(' ');
				msgObj = new CrocMSRP.Message.IncomingResponse(tokens[1], statusCode, comment);
			} else {
				msgObj = new CrocMSRP.Message.IncomingResponse(tokens[1], statusCode);
			}
		} else if (tokens.length === 3) {
			msgObj = new CrocMSRP.Message.IncomingRequest(tokens[1], tokens[2]);
		} else {
			console.log('Error parsing message: unexpected first line format: ' + firstLine);
			return null;
		}
		
		// Iterate through the headers, adding them to the object
		startIndex = endIndex + lineEnd.length;
		while (true) {
			parseResult = getNextHeader(msg, startIndex, msgObj);
			if (parseResult > 0) {
				startIndex = parseResult;
			} else if (parseResult === 0) {
				break;
			} else {
				return null;
			}
		}
		
		// Perform further processing on selected headers
		if (!parseKnownHeaders(msgObj)) {
			console.log("Error parsing message: parseKnownHeaders failed");
			return null;
		}
		
		// Extract the message body (if present)
		endLineNoFlag = msgObj.getEndLineNoFlag();
		if (msg.substr(startIndex, lineEnd.length) === lineEnd) {
			// Empty line after headers indicates presence of a message body
			startIndex += lineEnd.length;
			endIndex = msg.indexOf(lineEnd + endLineNoFlag, startIndex);
			if (endIndex === -1) {
				console.log("Error parsing message: no end line after body");
				return null;
			}
			if (data instanceof ArrayBuffer) {
				// Slice out the body of the message from the original ArrayBuffer
				msgObj.body = data.slice(startIndex, endIndex);
			} else {
				// Assume we're only dealing with text
				msgObj.body = msg.substring(startIndex, endIndex);
			}

			msgObj.continuationFlag = msg.charAt(endIndex + lineEnd.length + endLineNoFlag.length);
		} else {
			msgObj.continuationFlag = msg.charAt(startIndex + endLineNoFlag.length);
		}
		
		return msgObj;
	};

	/**
	 * Remove any leading or trailing whitespace from the provided string.
	 * @param {String} str The string to process.
	 * @returns {String} The trimmed string.
	 * @private
	 */
	function chomp(str) {
		return str.replace(/^\s+/, '').replace(/\s+$/, '');
	}
	
	/**
	 * Remove double quotes from the start and end of the string, if present.
	 * @param {String} str The string to process.
	 * @returns {String} The unquoted string.
	 * @private
	 */
	function unq(str) {
		return str.replace(/^"/, '').replace(/"$/, '');
	}

	// Extracts the next header after startIndex, and adds it to the provided message object
	// Returns: Positive value: the new message position when a header is extracted
	//          0 if there are no more headers
	//          -1 if it encounters an error
	function getNextHeader(msg, startIndex, msgObj) {
		var endIndex, colonIndex, name, value,
			endLineNoFlag = msgObj.getEndLineNoFlag();
		
		// If there is a body, there will be an extra CRLF between the headers and
		// the body. If there is no body, we stop at the end-line.
		if (msg.substr(startIndex, 2) === '\r\n' ||
				msg.substr(startIndex, endLineNoFlag.length) === endLineNoFlag) {
			return 0;
		}
		
		endIndex = msg.indexOf('\r\n', startIndex);
		if (endIndex === -1) {
			// Oops - invalid message
			console.log('Error parsing header: no CRLF');
			return -1;
		}

		colonIndex = msg.indexOf(':', startIndex);
		if (colonIndex === -1) {
			// Oops - invalid message
			console.log('Error parsing header: no colon');
			return -1;
		}
		
		name = chomp(msg.substring(startIndex, colonIndex));
		if (name.length === 0) {
			console.log('Error parsing header: no name');
			return -1;
		}
		
		value = chomp(msg.substring(colonIndex + 1, endIndex));
		if (name.length === 0) {
			console.log('Error parsing header: no value');
			return -1;
		}
		
		msgObj.addHeader(name, value);
		
		return endIndex + 2;
	}

	function getNextAuthParam(str, startIndex, obj) {
		var equalsIndex, endIndex, name, value;
		
		// Find the next equals sign, which indicates the end of the parameter name
		equalsIndex = str.indexOf('=', startIndex);
		if (equalsIndex === -1) {
			return -1;
		}
		
		// Look for the end of this parameter, starting after the equals sign
		endIndex = equalsIndex + 1;
		if (str.charAt(endIndex) === '"') {
			// Quoted string - find the end quote
			// We assume that the string cannot itself contain double quotes,
			// as RFC 2617 makes no mention of escape sequences.
			endIndex = str.indexOf('"', endIndex + 1);
			if (endIndex === -1) {
				return -1;
			}
		}
		
		// The parameter value continues until the next unquoted comma, or the
		// end of the header line.
		endIndex = str.indexOf(',', endIndex);
		if (endIndex === -1) {
			endIndex = str.length;
		}
		
		// Trim any whitespace/quotes
		name = chomp(str.substring(startIndex, equalsIndex));
		value = unq(chomp(str.substring(equalsIndex + 1, endIndex)));
		
		// Check we've got something sensible
		if (name.length === 0 || value.length === 0) {
			return -1;
		}
		
		// Add the param to the result object, and return the current position
		// in the header line.
		obj[name] = value;
		return endIndex + 1;
	}
	
	function parseWwwAuthenticate(headerArray, msgObj) {
		var hdrIndex, value, authenticate, strIndex;
		
		// There could be multiple WWW-Authenticate headers, each giving
		// different algorithms or other options.
		for (hdrIndex in headerArray) {
			value = headerArray[hdrIndex];
			authenticate = {};
			
			if (!value.match(/^Digest /)) {
				return false;
			}
			
			strIndex = 7;
			while (strIndex !== -1 && strIndex < value.length) {
				strIndex = getNextAuthParam(value, strIndex, authenticate);
			}
			if (strIndex === -1) {
				return false;
			}
			
			msgObj.authenticate.push(authenticate);
		}
		return true;
	}
	
	function parseByteRange(headerArray, msgObj) {
		var value, range = {}, rangeSepIndex, totalSepIndex;
		
		// We only expect one Byte-Range header
		if (headerArray.length !== 1) {
			return false;
		}
		value = headerArray[0];
		
		rangeSepIndex = value.indexOf('-');
		totalSepIndex = value.indexOf('/', rangeSepIndex);
		if (rangeSepIndex === -1 || totalSepIndex === -1) {
			console.log('Unexpected Byte-Range format: ' + value);
			return false;
		}
		
		range.start = parseInt(chomp(value.substring(0, rangeSepIndex)), 10);
		range.end = chomp(value.substring(rangeSepIndex + 1, totalSepIndex));
		if (range.end === '*') {
			range.end = -1;
		} else {
			range.end = parseInt(range.end, 10);
		}
		range.total = chomp(value.substring(totalSepIndex + 1));
		if (range.total === '*') {
			range.total = -1;
		} else {
			range.total = parseInt(range.total, 10);
		}
		
		if (isNaN(range.start) || isNaN(range.end) || isNaN(range.total)) {
			console.log('Unexpected Byte-Range values: ' + value);
			return false;
		}
		
		msgObj.byteRange = range;
		return true;
	}
	
	function parseFailureReport(headerArray, msgObj) {
		// We only expect one Failure-Report header
		if (headerArray.length !== 1) {
			console.log('Multiple Failure-Report headers');
			return false;
		}
		
		switch (headerArray[0].toLowerCase()) {
		case 'yes':
			msgObj.responseOn = {success: true, failure: true};
			break;
		case 'no':
			msgObj.responseOn = {success: false, failure: false};
			break;
		case 'partial':
			msgObj.responseOn = {success: false, failure: true};
			break;
		default:
			console.log('Unexpected Failure-Report header: ' + headerArray[0]);
			return false;
		}
		
		return true;
	}
	
	function parseStatus(headerArray, msgObj) {
		var splitValue;
		
		// We only expect Status headers on REPORT requests.  Ignore the header
		// if we find it on a response.
		if (msgObj instanceof CrocMSRP.Message.Response) {
			console.log('Ignoring Status header on response');
			return true;
		}
		
		// We only expect one Status header
		if (headerArray.length !== 1) {
			console.log('Multiple Status headers');
			return false;
		}
		
		splitValue = headerArray[0].split(' ');
		if (splitValue.length < 2 || splitValue.shift() !== '000') {
			console.log('Unexpected Status header: ' + headerArray[0]);
			return false;
		}
		
		msgObj.status = parseInt(splitValue.shift(), 10);
		msgObj.comment = splitValue.join(' ');
		
		return true;
	}
	
	function parseUsePath(headerArray, msgObj) {
		// We only expect one Use-Path header
		if (headerArray.length !== 1) {
			console.log('Multiple Use-Path headers');
			return false;
		}
		
		msgObj.usePath = headerArray[0].split(' ');
		if (msgObj.usePath.length < 1) {
			console.log('Unexpected Use-Path header: ' + headerArray[0]);
			return false;
		}
		
		return true;
	}
	
	function parseExpires(headerArray, msgObj) {
		// We only expect one Expires header
		if (headerArray.length !== 1) {
			console.log('Multiple Expires headers');
			return false;
		}
		
		msgObj.expires = parseInt(headerArray[0], 10);
		if (isNaN(msgObj.expires)) {
			console.log('Unexpected Expires header: ' + headerArray[0]);
			return false;
		}
		
		return true;
	}
	
	function parseContentDisposition(headerArray, msgObj) {
		var splitValue, index, splitParam;
		
		// We only expect MIME headers on SEND requests.  Ignore the header
		// if we find it on a response.
		if (msgObj instanceof CrocMSRP.Message.Response) {
			console.log('Ignoring Content-Disposition header on response');
			return true;
		}
		
		// We only expect one Content-Disposition header
		if (headerArray.length !== 1) {
			console.log('Multiple Content-Disposition headers');
			return false;
		}
		
		splitValue = headerArray[0].split(';');
		if (splitValue.length < 1) {
			console.log('Unexpected Content-Disposition header: ' + headerArray[0]);
			return false;
		}
		
		msgObj.contentDisposition = {};
		msgObj.contentDisposition.type = chomp(splitValue.shift());
		msgObj.contentDisposition.param = {};
		for (index in splitValue) {
			splitParam = splitValue[index].split('=');
			if (splitParam.length !== 2) {
				console.log('Unexpected Content-Disposition param: ' + splitValue[index]);
				return false;
			}
			
			msgObj.contentDisposition.param[chomp(splitParam[0])] = unq(chomp(splitParam[1]));
		}
		
		return true;
	}
	
	function parseMsgId(headerArray, msgObj) {
		// We only expect one Message-ID header
		if (headerArray.length !== 1) {
			console.log('Multiple Message-ID headers');
			return false;
		}
		
		msgObj.messageId = chomp(headerArray[0]);
		if (msgObj.messageId.length < 1) {
			console.log('Unexpected Message-ID header: ' + headerArray[0]);
			return false;
		}
		
		return true;
	}
	
	var headerParsers = {
		'Message-ID': parseMsgId,
		'Failure-Report': parseFailureReport,
		'Byte-Range': parseByteRange,
		'Status': parseStatus,
		'Content-Disposition': parseContentDisposition,
		'WWW-Authenticate': parseWwwAuthenticate,
		'Use-Path': parseUsePath,
		'Expires': parseExpires,
		'Min-Expires': parseExpires,
		'Max-Expires': parseExpires
	};
	
	function parseKnownHeaders(msgObj) {
		var header, parseFn;
		for (header in msgObj.headers) {
			parseFn = headerParsers[header];
			if (!parseFn) {
				// Ignore unknown headers
				continue;
			}
			
			if (!parseFn(msgObj.headers[header], msgObj)) {
				console.log('Parsing failed for header ' + header);
				return false;
			}
		}
		
		return true;
	}
	
	return CrocMSRP;
}(CrocMSRP || {}));


var CrocMSRP = (function(CrocMSRP) {
	var unixToNtpOffset = 2208988800;
	
	/**
	 * @namespace Shared utility functions
	 * @private
	 */
	CrocMSRP.util = {
		newUriAuthority: function() {
			// Create new URI Authority (used in local MSRP URI)
			// Use a random eight-character alphanumeric string.
			return Math.random().toString(36).substr(2,8) + '.invalid';
		},
		
		newSID: function() {
			// Create new Session ID (used in local MSRP URI)
			// RFC 4975 section 14.1 requires 80 bits of randomness
			// Use a random ten-character alphanumeric string.
			return Math.random().toString(36).substr(2,10);
		},
		
		newTID: function() {
			// Create new Transaction ID (used for delimiting individual chunks)
			// Use a random eight-character alphanumeric string.
			// Could be longer, but RFC4975 only requires 64-bits of randomness.
			return Math.random().toString(36).substr(2,8);
		},
		
		newMID: function() {
			// Create new Message ID (used to identify an individual message, which may be chunked)
			// RFC 4975 suggests a complicated way of ensuring uniqueness, but we're
			// being lazy.
			var now = new Date();
			return CrocMSRP.util.dateToNtpTime(now) + '.' + Math.random().toString(36).substr(2,8);
		},
		
		newFileTransferId: function() {
			// Create new File Transfer ID (see RFC 5547). This must uniquely
			// identify a file transfer within a session, and ideally should be
			// globally unique.
			var now = new Date();
			return CrocMSRP.util.dateToNtpTime(now) + '.' + Math.random().toString(36).substr(2);
		},
		
		normaliseHeader: function(name) {
			// Normalise the header capitalisation
			var parts = name.toLowerCase().split('-'),
				part,
				header = '';
				
			for (part in parts) {
				if (part !== '0') {
					header += '-';
				}
				header += parts[part].charAt(0).toUpperCase() + parts[part].substring(1);
			}
			
			switch(header) {
			case 'Www-Authenticate':
				return 'WWW-Authenticate';
			case 'Message-Id':
				return 'Message-ID';
			}
			
			return header;
		},
		
		isEmpty: function(map) {
			var property;
			for (property in map) {
				if (map.hasOwnProperty(property)) {
					return false;
				}
			}
			return true;
		},
		
		ntpTimeToDate: function(ntpTime) {
			return new Date((parseInt(ntpTime, 10) - unixToNtpOffset) * 1000);
		},
		
		dateToNtpTime: function(date) {
			return parseInt(date.getTime() / 1000, 10) + unixToNtpOffset;
		},
		
		/**
		 * Encodes a string as an SDP filename-string, as defined in RFC 5547.
		 * @param {String} str The string to encode.
		 * @returns {String} The encoded string.
		 */
		encodeSdpFileName: function(str) {
			return str.replace(/%/g, '%25')
				.replace(/\0/g, '%00')
				.replace(/\n/g, '%0A')
				.replace(/\r/g, '%0D')
				.replace(/"/g, '%22');
		},
	
		/**
		 * Decodes an SDP filename-string, as defined in RFC 5547.
		 * @param {String} str The string to decode.
		 * @returns {String} The decoded string.
		 */
		decodeSdpFileName: function(str) {
			return str.replace(/%00/g, '\0')
				.replace(/%0A/gi, '\n')
				.replace(/%0D/gi, '\r')
				.replace(/%22/g, '"')
				.replace(/%25/g, '%');
		},

		/**
		 * Encodes a string as a quoted-string, as defined in RFC 822.
		 * Note: does not support folding, as this is not used in MSRP.
		 * @param {String} str The string to encode.
		 * @returns {String} The encoded string.
		 */
		encodeQuotedString: function(str) {
			var chars = str.split(''), index;
			for (index in chars) {
				switch (chars[index]) {
				case '"':
				case '\r':
				case '\\':
					// These must be escaped as a quoted-pair
					chars[index] = '\\' + chars[index];
					break;
				}
			}
			return chars.join('');
		},
	
		/**
		 * Decodes a quoted-string, as defined in RFC 822.
		 * Note: does not support folding, as this is not used in MSRP.
		 * @param {String} str The string to decode.
		 * @returns {String} The decoded string.
		 */
		decodeQuotedString: function(str) {
			var chars = str.split(''), index, escaped = false;
			for (index in chars) {
				if (escaped) {
					// Always include this char as-is
					continue;
				}
				
				if (chars[index] === '\\') {
					escaped = true;
					delete chars[index];
				}
			}
			return chars.join('');
		}
	
	};
	
	return CrocMSRP;
}(CrocMSRP || {}));


JSJAC_HAVEKEYS = true;          // whether to use keys
JSJAC_NKEYS    = 16;            // number of keys to generate
JSJAC_INACTIVITY = 300;         // qnd hack to make suspend/resume
                                    // work more smoothly with polling
JSJAC_ERR_COUNT = 10;           // number of retries in case of connection
                                    // errors

JSJAC_ALLOW_PLAIN = true;       // whether to allow plaintext logins

JSJAC_CHECKQUEUEINTERVAL = 100;   // msecs to poll send queue
JSJAC_CHECKINQUEUEINTERVAL = 100; // msecs to poll incoming queue
JSJAC_TIMERVAL = 2000;          // default polling interval
JSJAC_RETRYDELAY = 5000;        // msecs to wait before trying next request after error

// Options specific to HTTP Binding (BOSH)
JSJACHBC_MAX_HOLD = 1;          // default for number of connctions held by
                                    // connection manager
JSJACHBC_MAX_WAIT = 300;        // default 'wait' param - how long an idle connection
                                    // should be held by connection manager

JSJACHBC_BOSH_VERSION  = "1.6";
JSJACHBC_USE_BOSH_VER  = true;

JSJACHBC_MAXPAUSE = 120;        // how long a suspend/resume cycle may take

/*** END CONFIG ***/
/**
 * @fileoverview Collection of functions to make live easier
 * @author Stefan Strigler
 */

/**
 * Convert special chars to HTML entities
 * @addon
 * @return The string with chars encoded for HTML
 * @type String
 */
String.prototype.htmlEnc = function() {
  if(!this)
    return this;
  
  var str = this.replace(/&/g,"&amp;");
  str = str.replace(/</g,"&lt;");
  str = str.replace(/>/g,"&gt;");
  str = str.replace(/\"/g,"&quot;");
  str = str.replace(/\n/g,"<br />");
  return str;
};

/**
 * Convert HTML entities to special chars
 * @addon
 * @return The normal string
 * @type String
 */
String.prototype.revertHtmlEnc = function() {
  if(!this)
    return this;
  
  var str = this.replace(/&amp;/gi,'&');
  str = str.replace(/&lt;/gi,'<');
  str = str.replace(/&gt;/gi,'>');
  str = str.replace(/&quot;/gi,'\"');
  str = str.replace(/<br( )?(\/)?>/gi,'\n');
  return str;
};

/**
 * Converts from jabber timestamps to JavaScript Date objects
 * @addon
 * @param {String} ts A string representing a jabber datetime timestamp as
 * defined by {@link http://www.xmpp.org/extensions/xep-0082.html XEP-0082}
 * @return A javascript Date object corresponding to the jabber DateTime given
 * @type Date
 */
Date.jab2date = function(ts) {
  var date = new Date(Date.UTC(ts.substr(0,4),ts.substr(5,2)-1,ts.substr(8,2),ts.substr(11,2),ts.substr(14,2),ts.substr(17,2)));
  if (ts.substr(ts.length-6,1) != 'Z') { // there's an offset
    var offset = new Date();
    offset.setTime(0);
    offset.setUTCHours(ts.substr(ts.length-5,2));
    offset.setUTCMinutes(ts.substr(ts.length-2,2));
    if (ts.substr(ts.length-6,1) == '+')
      date.setTime(date.getTime() - offset.getTime());
    else if (ts.substr(ts.length-6,1) == '-')
      date.setTime(date.getTime() + offset.getTime());
  }
  return date;
};

/**
 * Takes a timestamp in the form of 2004-08-13T12:07:04+02:00 as argument
 * and converts it to some sort of humane readable format
 * @addon
 */
Date.hrTime = function(ts) {
  return Date.jab2date(ts).toLocaleString();
};

/**
 * somewhat opposit to {@link #hrTime}
 * expects a javascript Date object as parameter and returns a jabber
 * date string conforming to
 * {@link http://www.xmpp.org/extensions/xep-0082.html XEP-0082}
 * @see #hrTime
 * @return The corresponding jabber DateTime string
 * @type String
 */
Date.prototype.jabberDate = function() {
  var padZero = function(i) {
    if (i < 10) return "0" + i;
    return i;
  };

  var jDate = this.getUTCFullYear() + "-";
  jDate += padZero(this.getUTCMonth()+1) + "-";
  jDate += padZero(this.getUTCDate()) + "T";
  jDate += padZero(this.getUTCHours()) + ":";
  jDate += padZero(this.getUTCMinutes()) + ":";
  jDate += padZero(this.getUTCSeconds()) + "Z";

  return jDate;
};

/**
 * Determines the maximum of two given numbers
 * @addon
 * @param {Number} A a number
 * @param {Number} B another number
 * @return the maximum of A and B
 * @type Number
 */
Number.max = function(A, B) {
  return (A > B)? A : B;
};

Number.min = function(A, B) {
  return (A < B)? A : B;
};
if (window.XDomainRequest) {
    window.ieXDRToXHR = function(window) {
        "use strict";
        var XHR = window.XMLHttpRequest;

        window.XMLHttpRequest = function() {
            this.onreadystatechange = Object;

            this.xhr = null;
            this.xdr = null;

            this.readyState = 0;
            this.status = '';
            this.statusText = null;
            this.responseText = null;

            this.getResponseHeader = null;
            this.getAllResponseHeaders = null;

            this.setRequestHeader = null;

            this.abort = null;
            this.send = null;
            this.isxdr = false;

            // static binding
            var self = this;

            self.xdrLoadedBinded = function() {
                self.xdrLoaded();
            };
            self.xdrErrorBinded = function() {
                self.xdrError();
            };
            self.xdrProgressBinded = function() {
                self.xdrProgress();
            };
            self.xhrReadyStateChangedBinded = function() {
                self.xhrReadyStateChanged();
            };
        };

        XMLHttpRequest.prototype.open = function(method, url, asynch, user, pwd) {
            //improve CORS deteciton (chat.example.net exemple.net), remove hardcoded http-bind
            var parser = document.createElement('a');
            parser.href = url;
            if (parser.hostname!=document.domain) {
                if (this.xdr === null){
                    this.xdr = new window.XDomainRequest();
                }

                this.isxdr = true;
                this.setXDRActive();
                this.xdr.open(method, url);
            } else {
                if (this.xhr === null){
                    this.xhr = new XHR();
                }

                this.isxdr = false;
                this.setXHRActive();
                this.xhr.open(method, url, asynch, user, pwd);
            }
        };

        XMLHttpRequest.prototype.xdrGetResponseHeader = function(name) {
            if (name === 'Content-Type' && this.xdr.contentType > ''){
                return this.xdr.contentType;
            }

            return '';
        };
        
        XMLHttpRequest.prototype.xdrGetAllResponseHeaders = function() {
            return (this.xdr.contentType > '') ? 'Content-Type: ' + this.xdr.contentType : '';
        };
        
        XMLHttpRequest.prototype.xdrSetRequestHeader = function(name, value) {
            //throw new Error('Request headers not supported');
        };
        
        XMLHttpRequest.prototype.xdrLoaded = function() {
            if (this.onreadystatechange !== null) {
                this.readyState = 4;
                this.status = 200;
                this.statusText = 'OK';
                this.responseText = this.xdr.responseText;
                if (window.ActiveXObject){
                    var doc = new ActiveXObject('Microsoft.XMLDOM');
                    doc.async='false';
                    doc.loadXML(this.responseText);
                    this.responseXML = doc;
                }
                this.onreadystatechange();
            }
        };
        
        XMLHttpRequest.prototype.xdrError = function() {
            if (this.onreadystatechange !== null) {
                this.readyState = 4;
                this.status = 0;
                this.statusText = '';
                // ???
                this.responseText = '';
                this.onreadystatechange();
            }
        };
        
        XMLHttpRequest.prototype.xdrProgress = function() {
            if (this.onreadystatechange !== null && this.status !== 3) {
                this.readyState = 3;
                this.status = 3;
                this.statusText = '';
                this.onreadystatechange();
            }
        };
        
        XMLHttpRequest.prototype.finalXDRRequest = function() {
            var xdr = this.xdr;
            delete xdr.onload;
            delete xdr.onerror;
            delete xdr.onprogress;
        };
        
        XMLHttpRequest.prototype.sendXDR = function(data) {
            var xdr = this.xdr;

            xdr.onload = this.xdrLoadedBinded;
            xdr.onerror = this.xdr.ontimeout = this.xdrErrorBinded;
            xdr.onprogress = this.xdrProgressBinded;
            this.responseText = null;

            this.xdr.send(data);
        };
        
        XMLHttpRequest.prototype.abortXDR = function() {
            this.finalXDRRequest();
            this.xdr.abort();
        };
        
        XMLHttpRequest.prototype.setXDRActive = function() {
            this.send = this.sendXDR;
            this.abort = this.abortXDR;
            this.getResponseHeader = this.xdrGetResponseHeader;
            this.getAllResponseHeaders = this.xdrGetAllResponseHeaders;
            this.setRequestHeader = this.xdrSetRequestHeader;
        };

        XMLHttpRequest.prototype.xhrGetResponseHeader = function(name) {
            return this.xhr.getResponseHeader(name);
        };
        
        XMLHttpRequest.prototype.xhrGetAllResponseHeaders = function() {
            return this.xhr.getAllResponseHeaders();
        };
        
        XMLHttpRequest.prototype.xhrSetRequestHeader = function(name, value) {
            return this.xhr.setRequestHeader(name, value);
        };
        
        XMLHttpRequest.prototype.xhrReadyStateChanged = function() {
            if (this.onreadystatechange !== null && this.readyState !== this.xhr.readyState) {
                var xhr = this.xhr;

                this.readyState = xhr.readyState;
                if (this.readyState === 4) {
                    this.status = xhr.status;
                    this.statusText = xhr.statusText;
                    this.responseText = xhr.responseText;
                    this.responseXML = xhr.responseXML;
                }

                this.onreadystatechange();
            }
        };
        
        XMLHttpRequest.prototype.finalXHRRequest = function() {
            delete this.xhr.onreadystatechange;
        };
        XMLHttpRequest.prototype.abortXHR = function() {
            this.finalXHRRequest();
            this.xhr.abort();
        };
        XMLHttpRequest.prototype.sendXHR = function(data) {
            this.xhr.onreadystatechange = this.xhrReadyStateChangedBinded;

            this.xhr.send(data);
        };
        XMLHttpRequest.prototype.setXHRActive = function() {
            this.send = this.sendXHR;
            this.abort = this.abortXHR;
            this.getResponseHeader = this.xhrGetResponseHeader;
            this.getAllResponseHeaders = this.xhrGetAllResponseHeaders;
            this.setRequestHeader = this.xhrSetRequestHeader;
        };

        window.ieXDRToXHR = undefined;
    };
    window.ieXDRToXHR(window);
}
/* Copyright (c) 1998 - 2007, Paul Johnston & Contributors
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following
 * disclaimer. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution.
 *
 * Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/**
 * @fileoverview Collection of MD5 and SHA1 hashing and encoding
 * methods.
 * @author Stefan Strigler steve@zeank.in-berlin.de
 */

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "="; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
    {
      var olda = a;
      var oldb = b;
      var oldc = c;
      var oldd = d;
      var olde = e;

      for(var j = 0; j < 80; j++)
        {
          if(j < 16) w[j] = x[i + j];
          else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
          var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                           safe_add(safe_add(e, w[j]), sha1_kt(j)));
          e = d;
          d = c;
          c = rol(b, 30);
          b = a;
          a = t;
        }

      a = safe_add(a, olda);
      b = safe_add(b, oldb);
      c = safe_add(c, oldc);
      d = safe_add(d, oldd);
      e = safe_add(e, olde);
    }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
    (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
    {
      ipad[i] = bkey[i] ^ 0x36363636;
      opad[i] = bkey[i] ^ 0x5C5C5C5C;
    }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
    {
      str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
        hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
    }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
    {
      var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
        | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
        |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
      for(var j = 0; j < 4; j++)
        {
          if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
          else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
        }
    }
  return str.replace(/AAA\=(\=*?)$/,'$1'); // cleans garbage chars at end of string
}

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
// var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
// var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
// var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s){ return binl2hex(core_md5(str2binl(s), s.length * chrsz));}
function b64_md5(s){ return binl2b64(core_md5(str2binl(s), s.length * chrsz));}
function str_md5(s){ return binl2str(core_md5(str2binl(s), s.length * chrsz));}
function hex_hmac_md5(key, data) { return binl2hex(core_hmac_md5(key, data)); }
function b64_hmac_md5(key, data) { return binl2b64(core_hmac_md5(key, data)); }
function str_hmac_md5(key, data) { return binl2str(core_hmac_md5(key, data)); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Calculate the HMAC-MD5, of a key and some data
 */
function core_hmac_md5(key, data)
{
  var bkey = str2binl(key);
  if(bkey.length > 16) bkey = core_md5(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);
  return core_md5(opad.concat(hash), 512 + 128);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert a string to an array of little-endian words
 * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
 */
function str2binl(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);
  return bin;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);
  return str;
}

/*
 * Convert an array of little-endian words to a hex string.
 */
function binl2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of little-endian words to a base-64 string
 */
function binl2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}

/* #############################################################################
   UTF-8 Decoder and Encoder
   base64 Encoder and Decoder
   written by Tobias Kieslich, justdreams
   Contact: tobias@justdreams.de				http://www.justdreams.de/
   ############################################################################# */

// returns an array of byterepresenting dezimal numbers which represent the
// plaintext in an UTF-8 encoded version. Expects a string.
// This function includes an exception management for those nasty browsers like
// NN401, which returns negative decimal numbers for chars>128. I hate it!!
// This handling is unfortunately limited to the user's charset. Anyway, it works
// in most of the cases! Special signs with an unicode>256 return numbers, which
// can not be converted to the actual unicode and so not to the valid utf-8
// representation. Anyway, this function does always return values which can not
// misinterpretd by RC4 or base64 en- or decoding, because every value is >0 and
// <255!!
// Arrays are faster and easier to handle in b64 encoding or encrypting....
function utf8t2d(t)
{
  t = t.replace(/\r\n/g,"\n");
  var d=new Array; var test=String.fromCharCode(237);
  if (test.charCodeAt(0) < 0)
    for(var n=0; n<t.length; n++)
      {
        var c=t.charCodeAt(n);
        if (c>0)
          d[d.length]= c;
        else {
          d[d.length]= (((256+c)>>6)|192);
          d[d.length]= (((256+c)&63)|128);}
      }
  else
    for(var n=0; n<t.length; n++)
      {
        var c=t.charCodeAt(n);
        // all the signs of asci => 1byte
        if (c<128)
          d[d.length]= c;
        // all the signs between 127 and 2047 => 2byte
        else if((c>127) && (c<2048)) {
          d[d.length]= ((c>>6)|192);
          d[d.length]= ((c&63)|128);}
        // all the signs between 2048 and 66536 => 3byte
        else {
          d[d.length]= ((c>>12)|224);
          d[d.length]= (((c>>6)&63)|128);
          d[d.length]= ((c&63)|128);}
      }
  return d;
}
	
// returns plaintext from an array of bytesrepresenting dezimal numbers, which
// represent an UTF-8 encoded text; browser which does not understand unicode
// like NN401 will show "?"-signs instead
// expects an array of byterepresenting decimals; returns a string
function utf8d2t(d)
{
  var r=new Array; var i=0;
  while(i<d.length)
    {
      if (d[i]<128) {
        r[r.length]= String.fromCharCode(d[i]); i++;}
      else if((d[i]>191) && (d[i]<224)) {
        r[r.length]= String.fromCharCode(((d[i]&31)<<6) | (d[i+1]&63)); i+=2;}
      else {
        r[r.length]= String.fromCharCode(((d[i]&15)<<12) | ((d[i+1]&63)<<6) | (d[i+2]&63)); i+=3;}
    }
  return r.join("");
}

// included in <body onload="b64arrays"> it creates two arrays which makes base64
// en- and decoding faster
// this speed is noticeable especially when coding larger texts (>5k or so)
function b64arrays() {
  var b64s='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  b64 = new Array();f64 =new Array();
  for (var i=0; i<b64s.length ;i++) {
    b64[i] = b64s.charAt(i);
    f64[b64s.charAt(i)] = i;
  }
}

// creates a base64 encoded text out of an array of byerepresenting dezimals
// it is really base64 :) this makes serversided handling easier
// expects an array; returns a string
function b64d2t(d) {
  var r=new Array; var i=0; var dl=d.length;
  // this is for the padding
  if ((dl%3) == 1) {
    d[d.length] = 0; d[d.length] = 0;}
  if ((dl%3) == 2)
    d[d.length] = 0;
  // from here conversion
  while (i<d.length)
    {
      r[r.length] = b64[d[i]>>2];
      r[r.length] = b64[((d[i]&3)<<4) | (d[i+1]>>4)];
      r[r.length] = b64[((d[i+1]&15)<<2) | (d[i+2]>>6)];
      r[r.length] = b64[d[i+2]&63];
      i+=3;
    }
  // this is again for the padding
  if ((dl%3) == 1)
    r[r.length-1] = r[r.length-2] = "=";
  if ((dl%3) == 2)
    r[r.length-1] = "=";
  // we join the array to return a textstring
  var t=r.join("");
  return t;
}

// returns array of byterepresenting numbers created of an base64 encoded text
// it is still the slowest function in this modul; I hope I can make it faster
// expects string; returns an array
function b64t2d(t) {
  var d=new Array; var i=0;
  // here we fix this CRLF sequenz created by MS-OS; arrrgh!!!
  t=t.replace(/\n|\r/g,""); t=t.replace(/=/g,"");
  while (i<t.length)
    {
      d[d.length] = (f64[t.charAt(i)]<<2) | (f64[t.charAt(i+1)]>>4);
      d[d.length] = (((f64[t.charAt(i+1)]&15)<<4) | (f64[t.charAt(i+2)]>>2));
      d[d.length] = (((f64[t.charAt(i+2)]&3)<<6) | (f64[t.charAt(i+3)]));
      i+=4;
    }
  if (t.length%4 == 2)
    d = d.slice(0, d.length-2);
  if (t.length%4 == 3)
    d = d.slice(0, d.length-1);
  return d;
}

if (typeof(atob) == 'undefined' || typeof(btoa) == 'undefined')
  b64arrays();

if (typeof(atob) == 'undefined') {
  b64decode = function(s) {
    return utf8d2t(b64t2d(s));
  }
} else {
  b64decode = function(s) {
    return decodeURIComponent(escape(atob(s)));
  }
}

if (typeof(btoa) == 'undefined') {
  b64encode = function(s) {
    return b64d2t(utf8t2d(s));
  }
} else {
  b64encode = function(s) {
    return btoa(unescape(encodeURIComponent(s)));
  }
}

function cnonce(size) {
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  var cnonce = '';
  for (var i=0; i<size; i++) {
    cnonce += tab.charAt(Math.round(Math.random(new Date().getTime())*(tab.length-1)));
  }
  return cnonce;
}
/* Copyright (c) 2005-2007 Sam Stephenson
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
  json.js
  taken from prototype.js, made static
*/
function JSJaCJSON() {}
JSJaCJSON.toString = function (obj) {
  var m = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '"' : '\\"',
    '\\': '\\\\'
  },
  s = {
    array: function (x) {
      var a = ['['], b, f, i, l = x.length, v;
      for (i = 0; i < l; i += 1) {
        v = x[i];
        f = s[typeof v];
        if (f) {
	  try {
            v = f(v);
            if (typeof v == 'string') {
              if (b) {
                a[a.length] = ',';
              }
              a[a.length] = v;
              b = true;
            }
	  } catch(e) { 
	  }
        }
      }
      a[a.length] = ']';
      return a.join('');
    },
    'boolean': function (x) {
      return String(x);
    },
    'null': function (x) {
      return "null";
    },
    number: function (x) {
      return isFinite(x) ? String(x) : 'null';
    },
    object: function (x) {
      if (x) {
        if (x instanceof Array) {
          return s.array(x);
        }
        var a = ['{'], b, f, i, v;
        for (i in x) {
          if (x.hasOwnProperty(i)) {
            v = x[i];
            f = s[typeof v];
            if (f) {
	      try {
                v = f(v);
                if (typeof v == 'string') {
                  if (b) {
                    a[a.length] = ',';
                  }
                  a.push(s.string(i), ':', v);
                  b = true;
                }
	      } catch(e) {
	      }
            }
          }
        }
         
        a[a.length] = '}';
        return a.join('');
      }
      return 'null';
    },
    string: function (x) {
      if (/["\\\x00-\x1f]/.test(x)) {
                    x = x.replace(/([\x00-\x1f\\"])/g, function(a, b) {
          var c = m[b];
          if (c) {
            return c;
          }
          c = b.charCodeAt();
          return '\\u00' +
          Math.floor(c / 16).toString(16) +
          (c % 16).toString(16);
        });
  }
  return '"' + x + '"';
}
  };

switch (typeof(obj)) {
 case 'object':
   return s.object(obj);
 case 'array':
   return s.array(obj);
   
 }
};

JSJaCJSON.parse = function (str) {
  try {
    return !(/[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/.test(
                                                       str.replace(/"(\\.|[^"\\])*"/g, ''))) &&
            eval('(' + str + ')');
    } catch (e) {
        return false;
    }
};
/* Copyright 2006 Erik Arvidsson
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License.  You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied.  See the License for the specific language governing
 * permissions and limitations under the License.
 */

/**
 * @fileoverview Wrapper to make working with XmlHttpRequest and the
 * DOM more convenient (cross browser compliance).
 * this code is taken from
 * {@link http://webfx.eae.net/dhtml/xmlextras/xmlextras.html}.
 * @author Erik Arvidsson
 * @author Stefan Strigler steve@zeank.in-berlin.de
 */

/**
 * XmlHttp factory
 * @private
 */
function XmlHttp() {}

/**
 * creates a cross browser compliant XmlHttpRequest object
 */
XmlHttp.create = function () {
  try {
    if (window.XMLHttpRequest) {
        var req = new XMLHttpRequest();

        // some versions of Moz do not support the readyState property
        // and the onreadystate event so we patch it!
        if (req.readyState === null) {
            req.readyState = 1;
            req.addEventListener("load", function () {
                req.readyState = 4;
                if (typeof req.onreadystatechange == "function")
                    req.onreadystatechange();
			}, false);
        }

        return req;
    }
      if (window.ActiveXObject) {
          return new ActiveXObject(XmlHttp.getPrefix() + ".XmlHttp");
      }
  }
    catch (ex) {}
    // fell through
    throw new Error("Your browser does not support XmlHttp objects");
};

/**
 * used to find the Automation server name
 * @private
 */
XmlHttp.getPrefix = function() {
  if (XmlHttp.prefix) // I know what you did last summer
    return XmlHttp.prefix;

  var prefixes = ["MSXML2", "Microsoft", "MSXML", "MSXML3"];
  var o;
  for (var i = 0; i < prefixes.length; i++) {
    try {
      // try to create the objects
      o = new ActiveXObject(prefixes[i] + ".XmlHttp");
      return XmlHttp.prefix = prefixes[i];
    }
    catch (ex) {}
  }

  throw new Error("Could not find an installed XML parser");
};


/**
 * XmlDocument factory
 * @private
 */
function XmlDocument() {}

XmlDocument.create = function (name,ns) {
  name = name || 'foo';
  ns = ns || '';

  try {
    var doc;
    // DOM2
    if (document.implementation && document.implementation.createDocument) {
      doc = document.implementation.createDocument(ns, name, null);
      // some versions of Moz do not support the readyState property
      // and the onreadystate event so we patch it!
      if (doc.readyState === null) {
          doc.readyState = 1;
          doc.addEventListener("load", function () {
              doc.readyState = 4;
              if (typeof doc.onreadystatechange == "function")
                  doc.onreadystatechange();
          }, false);
      }
    } else if (window.ActiveXObject) {
      doc = new ActiveXObject(XmlDocument.getPrefix() + ".DomDocument");
    }

    if (!doc.documentElement || doc.documentElement.tagName != name ||
        (doc.documentElement.namespaceURI &&
         doc.documentElement.namespaceURI != ns)) {
          try {
            if (ns !== '')
              doc.appendChild(doc.createElement(name)).
                setAttribute('xmlns',ns);
            else
              doc.appendChild(doc.createElement(name));
          } catch (dex) {
            doc = document.implementation.createDocument(ns,name,null);

            if (doc.documentElement === null)
              doc.appendChild(doc.createElement(name));

             // fix buggy opera 8.5x
            if (ns !== '' &&
                doc.documentElement.getAttribute('xmlns') != ns) {
              doc.documentElement.setAttribute('xmlns',ns);
            }
          }
        }

    return doc;
  }
  catch (ex) { }
  throw new Error("Your browser does not support XmlDocument objects");
};

/**
 * used to find the Automation server name
 * @private
 */
XmlDocument.getPrefix = function() {
  if (XmlDocument.prefix)
    return XmlDocument.prefix;

  var prefixes = ["MSXML2", "Microsoft", "MSXML", "MSXML3"];
  var o;
  for (var i = 0; i < prefixes.length; i++) {
    try {
      // try to create the objects
      o = new ActiveXObject(prefixes[i] + ".DomDocument");
      return XmlDocument.prefix = prefixes[i];
    }
    catch (ex) {}
  }

  throw new Error("Could not find an installed XML parser");
};


// Create the loadXML method
if (typeof(Document) != 'undefined' && window.DOMParser) {

  /**
   * XMLDocument did not extend the Document interface in some
   * versions of Mozilla.
   * @private
   */
  Document.prototype.loadXML = function (s) {

    // parse the string to a new doc
    var doc2 = (new DOMParser()).parseFromString(s, "text/xml");

    // remove all initial children
    while (this.hasChildNodes())
      this.removeChild(this.lastChild);

    // insert and import nodes
    for (var i = 0; i < doc2.childNodes.length; i++) {
      this.appendChild(this.importNode(doc2.childNodes[i], true));
    }
  };
 }

// Create xml getter for Mozilla
if (window.XMLSerializer &&
    window.Node && Node.prototype && Node.prototype.__defineGetter__) {

  /**
   * xml getter
   *
   * This serializes the DOM tree to an XML String
   *
   * Usage: var sXml = oNode.xml
   * @deprecated
   * @private
   */
  // XMLDocument did not extend the Document interface in some versions
  // of Mozilla. Extend both!
  XMLDocument.prototype.__defineGetter__("xml", function () {
                                           return (new XMLSerializer()).serializeToString(this);
                                         });
  /**
   * xml getter
   *
   * This serializes the DOM tree to an XML String
   *
   * Usage: var sXml = oNode.xml
   * @deprecated
   * @private
   */
  Document.prototype.__defineGetter__("xml", function () {
                                        return (new XMLSerializer()).serializeToString(this);
                                      });

  /**
   * xml getter
   *
   * This serializes the DOM tree to an XML String
   *
   * Usage: var sXml = oNode.xml
   * @deprecated
   * @private
   */
  Node.prototype.__defineGetter__("xml", function () {
                                    return (new XMLSerializer()).serializeToString(this);
                                  });
 }
/* Copyright (c) 2005 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This code is taken from 
 * {@link http://wiki.script.aculo.us/scriptaculous/show/Builder | script.aculo.us' Dom Builder} 
 * and has been modified to suit our
 * needs.<br/>
 * The original parts of the code do have the following
 * copyright and license notice:<br/>
 * Copyright (c) 2005, 2006 Thomas Fuchs (http://script.aculo.us,
 * http://mir.acu lo.us) <br/>
 * script.aculo.us is freely distributable under the terms of an
 * MIT-style license.<br>
 * For details, see the script.aculo.us web site at
 * {@link http://script.aculo.us/}
 * @namespace
 */
var JSJaCBuilder = {

    /**
     * build a new node within an xml document
     * @param {XMLDocument} doc an xml document to build the new nodes for
     * @param {string} elementName the name of the element to be created
     */
  buildNode: function(doc, elementName) {

    var element, ns = arguments[4];

    // attributes (or text)
    if(arguments[2])
      if(JSJaCBuilder._isStringOrNumber(arguments[2]) ||
         (arguments[2] instanceof Array)) {
        element = this._createElement(doc, elementName, ns);
        JSJaCBuilder._children(doc, element, arguments[2]);
      } else {
        ns = arguments[2]['xmlns'] || ns;
        element = this._createElement(doc, elementName, ns);
        for(var attr in arguments[2]) {
          if (arguments[2].hasOwnProperty(attr) && attr != 'xmlns')
            element.setAttribute(attr, arguments[2][attr]);
        }
      }
    else
      element = this._createElement(doc, elementName, ns);
    // text, or array of children
    if(arguments[3])
      JSJaCBuilder._children(doc, element, arguments[3], ns);

    return element;
  },

  /**
   * @private
   */
  _createElement: function(doc, elementName, ns) {
    try {
      if (ns)
        return doc.createElementNS(ns, elementName);
    } catch (ex) { }

    var el = doc.createElement(elementName);

    if (ns)
      el.setAttribute("xmlns", ns);

    return el;
  },

  /**
   * @private
   */
  _text: function(doc, text) {
    return doc.createTextNode(text);
  },

  /**
   * @private
   */
  _children: function(doc, element, children, ns) {
    if(typeof children=='object') { // array can hold nodes and text
      for (var i in children) {
        if (children.hasOwnProperty(i)) {
          var e = children[i];
          if (typeof e=='object') {
            if (e instanceof Array) {
              var node = JSJaCBuilder.buildNode(doc, e[0], e[1], e[2], ns);
              element.appendChild(node);
            } else {
              element.appendChild(e);
            }
          } else {
            if(JSJaCBuilder._isStringOrNumber(e)) {
              element.appendChild(JSJaCBuilder._text(doc, e));
            }
          }
        }
      }
    } else {
      if(JSJaCBuilder._isStringOrNumber(children)) {
        element.appendChild(JSJaCBuilder._text(doc, children));
      }
    }
  },

  /**
   * @private
   */
  _attributes: function(attributes) {
    var attrs = [];
    for(var attribute in attributes)
      if (attributes.hasOwnProperty(attribute))
        attrs.push(attribute +
          '="' + attributes[attribute].toString().htmlEnc() + '"');
    return attrs.join(" ");
  },

  /**
   * @private
   */
  _isStringOrNumber: function(param) {
    return(typeof param=='string' || typeof param=='number');
  }
};
var NS_DISCO_ITEMS =  "http://jabber.org/protocol/disco#items";
var NS_DISCO_INFO =   "http://jabber.org/protocol/disco#info";
var NS_VCARD =        "vcard-temp";
var NS_AUTH =         "jabber:iq:auth";
var NS_AUTH_ERROR =   "jabber:iq:auth:error";
var NS_REGISTER =     "jabber:iq:register";
var NS_SEARCH =       "jabber:iq:search";
var NS_ROSTER =       "jabber:iq:roster";
var NS_PRIVACY =      "jabber:iq:privacy";
var NS_PRIVATE =      "jabber:iq:private";
var NS_VERSION =      "jabber:iq:version";
var NS_TIME =         "jabber:iq:time";
var NS_TIME_NEW =     "urn:xmpp:time";
var NS_LAST =         "jabber:iq:last";
var NS_XDATA =        "jabber:x:data";
var NS_IQDATA =       "jabber:iq:data";
var NS_DELAY =        "jabber:x:delay";
var NS_DELAY_NEW =    "urn:xmpp:delay";
var NS_EXPIRE =       "jabber:x:expire";
var NS_EVENT =        "jabber:x:event";
var NS_XCONFERENCE =  "jabber:x:conference";
var NS_PING =         "urn:xmpp:ping";
var NS_CHAT_STATES =  "http://jabber.org/protocol/chatstates";
var NS_STATS =        "http://jabber.org/protocol/stats";
var NS_MUC =          "http://jabber.org/protocol/muc";
var NS_MUC_USER =     "http://jabber.org/protocol/muc#user";
var NS_MUC_ADMIN =    "http://jabber.org/protocol/muc#admin";
var NS_MUC_OWNER =    "http://jabber.org/protocol/muc#owner";
var NS_PUBSUB =       "http://jabber.org/protocol/pubsub";
var NS_PUBSUB_EVENT = "http://jabber.org/protocol/pubsub#event";
var NS_PUBSUB_OWNER = "http://jabber.org/protocol/pubsub#owner";
var NS_PUBSUB_NMI =   "http://jabber.org/protocol/pubsub#node-meta-info";
var NS_COMMANDS =     "http://jabber.org/protocol/commands";
var NS_STREAM =       "http://etherx.jabber.org/streams";
var NS_CLIENT =       "jabber:client";

var NS_BOSH =         "http://jabber.org/protocol/httpbind";
var NS_XBOSH =        "urn:xmpp:xbosh";

var NS_STANZAS =      "urn:ietf:params:xml:ns:xmpp-stanzas";
var NS_STREAMS =      "urn:ietf:params:xml:ns:xmpp-streams";

var NS_TLS =          "urn:ietf:params:xml:ns:xmpp-tls";
var NS_SASL =         "urn:ietf:params:xml:ns:xmpp-sasl";
var NS_SESSION =      "urn:ietf:params:xml:ns:xmpp-session";
var NS_BIND =         "urn:ietf:params:xml:ns:xmpp-bind";

var NS_FEATURE_IQAUTH = "http://jabber.org/features/iq-auth";
var NS_FEATURE_IQREGISTER = "http://jabber.org/features/iq-register";
var NS_FEATURE_COMPRESS = "http://jabber.org/features/compress";

var NS_COMPRESS =     "http://jabber.org/protocol/compress";

function STANZA_ERROR(code, type, cond) {
  if (window == this)
    return new STANZA_ERROR(code, type, cond);

  this.code = code;
  this.type = type;
  this.cond = cond;
}

var ERR_BAD_REQUEST =
        STANZA_ERROR("400", "modify", "bad-request");
var ERR_CONFLICT =
        STANZA_ERROR("409", "cancel", "conflict");
var ERR_FEATURE_NOT_IMPLEMENTED =
        STANZA_ERROR("501", "cancel", "feature-not-implemented");
var ERR_FORBIDDEN =
        STANZA_ERROR("403", "auth",   "forbidden");
var ERR_GONE =
        STANZA_ERROR("302", "modify", "gone");
var ERR_INTERNAL_SERVER_ERROR =
        STANZA_ERROR("500", "wait",   "internal-server-error");
var ERR_ITEM_NOT_FOUND =
        STANZA_ERROR("404", "cancel", "item-not-found");
var ERR_JID_MALFORMED =
        STANZA_ERROR("400", "modify", "jid-malformed");
var ERR_NOT_ACCEPTABLE =
        STANZA_ERROR("406", "modify", "not-acceptable");
var ERR_NOT_ALLOWED =
        STANZA_ERROR("405", "cancel", "not-allowed");
var ERR_NOT_AUTHORIZED =
        STANZA_ERROR("401", "auth",   "not-authorized");
var ERR_PAYMENT_REQUIRED =
        STANZA_ERROR("402", "auth",   "payment-required");
var ERR_RECIPIENT_UNAVAILABLE =
        STANZA_ERROR("404", "wait",   "recipient-unavailable");
var ERR_REDIRECT =
        STANZA_ERROR("302", "modify", "redirect");
var ERR_REGISTRATION_REQUIRED =
        STANZA_ERROR("407", "auth",   "registration-required");
var ERR_REMOTE_SERVER_NOT_FOUND =
        STANZA_ERROR("404", "cancel", "remote-server-not-found");
var ERR_REMOTE_SERVER_TIMEOUT =
        STANZA_ERROR("504", "wait",   "remote-server-timeout");
var ERR_RESOURCE_CONSTRAINT =
        STANZA_ERROR("500", "wait",   "resource-constraint");
var ERR_SERVICE_UNAVAILABLE =
        STANZA_ERROR("503", "cancel", "service-unavailable");
var ERR_SUBSCRIPTION_REQUIRED =
        STANZA_ERROR("407", "auth",   "subscription-required");
var ERR_UNEXPECTED_REQUEST =
        STANZA_ERROR("400", "wait",   "unexpected-request");

/**
 * @fileOverview Contains Debugger interface for Firebug and Safari
 */
/**
 * A logger that logs using the 'console' object.
 * @constructor
 * @class Implementation of the Debugger interface for 
 * {@link http://www.getfirebug.com/ | Firebug} and Safari.
 * Creates a new debug logger to be passed to jsjac's connection
 * constructor. Of course you can use it for debugging in your code
 * too.
 * @extends {JSJaCDebugger}
 * @author Stefan Strigler steve@zeank.in-berlin.de
 * @param {int} level The maximum level for debugging messages to be
 * displayed. Thus you can tweak the verbosity of the logger. A value
 * of 0 means very low traffic whilst a value of 4 makes logging very
 * verbose about what's going on.
 */
function JSJaCConsoleLogger(level) {
  /**
   * @private
   */
  this.level = level || 4;

  /**
   * Empty function for API compatibility
   */
  this.start = function() {};
  /**
   * Logs a message to firebug's/safari's console
   * @param {String} msg The message to be logged.
   * @param {int} level The message's verbosity level. Importance is
   * from 0 (very important) to 4 (not so important). A value of 1
   * denotes an error in the usual protocol flow.
   */
  this.log = function(msg, level) {
    level = level || 0;
    if (level > this.level)
      return;
    if (typeof(console) == 'undefined')
      return;
    try {
      switch (level) {
      case 0:
        console.warn(msg);
        break;
      case 1:
        console.error(msg);
        break;
      case 2:
        console.info(msg);
        break;
      case 4:
        console.debug(msg);
        break;
      default:
        console.log(msg);
        break;
      }
    } catch(e) { try { console.log(msg); } catch(e) {} }
  };

  /**
   * Sets verbosity level.
   * @param {int} level The maximum level for debugging messages to be
   * displayed. Thus you can tweak the verbosity of the logger. A
   * value of 0 means very low traffic whilst a value of 4 makes
   * logging very verbose about what's going on.
   * @return This debug logger
   * @type ConsoleLogger
   */
  this.setLevel = function(level) { this.level = level; return this; };
  /**
   * Gets verbosity level.
   * @return {int} The level
   */
  this.getLevel = function() { return this.level; };
}
/**
 * @fileoverview OO interface to handle cookies.
 * Taken from {@link http://www.quirksmode.org/js/cookies.html}.
 * Regarding licensing of this code the author states:
 *
 * "You may copy, tweak, rewrite, sell or lease any code example on
 * this site, with one single exception."
 *
 * @author 2003-2006 Peter-Paul Koch
 * @author Stefan Strigler
 */

/**
 * Creates a new Cookie
 * @class Class representing browser cookies for storing small amounts of data
 * @constructor
 * @param {String} name   The name of the value to store
 * @param {String} value  The value to store
 * @param {int}    secs   Number of seconds until cookie expires (may be empty)
 * @param {String} domain The domain for the cookie
 * @param {String} path   The path of cookie
 */
function JSJaCCookie(name,value,secs,domain,path)
{
  if (window == this)
    return new JSJaCCookie(name, value, secs, domain, path);

  /**
   * This cookie's name
   * @type String
   */
  this.name = name;
  /**
   * This cookie's value
   * @type String
   */
  this.value = value;
  /**
   * Time in seconds when cookie expires (thus being delete by
   * browser). A value of -1 denotes a session cookie which means that
   * stored data gets lost when browser is being closed.
   * @type int
   */
  this.secs = secs;

  /**
   * The cookie's domain
   * @type string
   */
  this.domain = domain;

  /**
   * The cookie's path
   * @type string
   */
  this.path = path;

  /**
   * Stores this cookie
   */
  this.write = function() {
    var expires;
    if (this.secs) {
      var date = new Date();
      date.setTime(date.getTime()+(this.secs*1000));
      expires = "; expires="+date.toGMTString();
    } else
      expires = "";
    var domain = this.domain?"; domain="+this.domain:"";
    var path = this.path?"; path="+this.path:"; path=/";
    document.cookie = this.getName()+"="+JSJaCCookie._escape(this.getValue())+
      expires+
      domain+
      path;
  };

  /**
   * Deletes this cookie
   */
  this.erase = function() {
    var c = new JSJaCCookie(this.getName(),"",-1);
    c.write();
  };

  /**
   * Gets the name of this cookie
   * @return The name
   * @type String
   */
  this.getName = function() {
    return this.name;
  };

  /**
   * Sets the name of this cookie
   * @param {String} name The name for this cookie
   * @return This cookie
   * @type Cookie
   */
  this.setName = function(name) {
    this.name = name;
    return this;
  };

  /**
   * Gets the value of this cookie
   * @return The value
   * @type String
   */
  this.getValue = function() {
    return this.value;
  };

  /**
   * Sets the value of this cookie
   * @param {String} value The value for this cookie
   * @return This cookie
   * @type Cookie
   */
  this.setValue = function(value) {
    this.value = value;
    return this;
  };

  /**
   * Sets the domain of this cookie
   * @param {String} domain The value for the domain of the cookie
   * @return This cookie
   * @type Cookie
   */
  this.setDomain = function(domain) {
    this.domain = domain;
    return this;
  };

  /**
   * Sets the path of this cookie
   * @param {String} path The value of the path of the cookie
   * @return This cookie
   * @type Cookie
   */
  this.setPath = function(path) {
    this.path = path;
    return this;
  };
}

/**
 * Reads the value for given <code>name</code> from cookies and return new
 * <code>Cookie</code> object
 * @param {String} name The name of the cookie to read
 * @return A cookie object of the given name
 * @type Cookie
 * @throws CookieException when cookie with given name could not be found
 */
JSJaCCookie.read = function(name) {
  var nameEQ = name + "=";
  var ca = document.cookie.split(';');
  for(var i=0;i < ca.length;i++) {
    var c = ca[i];
    while (c.charAt(0)==' ') c = c.substring(1,c.length);
    if (c.indexOf(nameEQ) == 0)
      return new JSJaCCookie(
        name,
        JSJaCCookie._unescape(c.substring(nameEQ.length,c.length)));
  }
  throw new JSJaCCookieException("Cookie not found");
};

/**
 * Reads the value for given <code>name</code> from cookies and returns
 * its valued new
 * @param {String} name The name of the cookie to read
 * @return The value of the cookie read
 * @type String
 * @throws CookieException when cookie with given name could not be found
 */
JSJaCCookie.get = function(name) {
  return JSJaCCookie.read(name).getValue();
};

/**
 * Deletes cookie with given <code>name</code>
 * @param {String} name The name of the cookie to delete
 * @throws CookieException when cookie with given name could not be found
 */
JSJaCCookie.remove = function(name) {
  JSJaCCookie.read(name).erase();
};

/**
 * @private
 */
JSJaCCookie._escape = function(str) {
  return str.replace(/;/g, "%3AB");
}

/**
 * @private
 */
JSJaCCookie._unescape = function(str) {
  return str.replace(/%3AB/g, ";");
}

/**
 * Some exception denoted to dealing with cookies
 * @constructor
 * @param {String} msg The message to pass to the exception
 */
function JSJaCCookieException(msg) {
  this.message = msg;
  this.name = "CookieException";
}

/**
 * an error packet for internal use
 * @private
 * @constructor
 */
function JSJaCError(code,type,condition) {
  var xmldoc = XmlDocument.create("error","jsjac");

  xmldoc.documentElement.setAttribute('code',code);
  xmldoc.documentElement.setAttribute('type',type);
  if (condition)
    xmldoc.documentElement.appendChild(xmldoc.createElement(condition)).
      setAttribute('xmlns', NS_STANZAS);
  return xmldoc.documentElement;
}
/**
 * @fileoverview This file contains all things that make life easier when
 * dealing with JIDs
 * @author Stefan Strigler
 */

/**
 * list of forbidden chars for nodenames
 * @private
 */
var JSJACJID_FORBIDDEN = ['"',' ','&','\'','/',':','<','>','@'];

/**
 * Creates a new JSJaCJID object
 * @class JSJaCJID models xmpp jid objects
 * @constructor
 * @param {Object} jid jid may be either of type String or a JID represented
 * by JSON with fields 'node', 'domain' and 'resource'
 * @throws JSJaCJIDInvalidException Thrown if jid is not valid
 * @return a new JSJaCJID object
 */
function JSJaCJID(jid) {
    /**
     *@private
     */
    this._node = '';
    /**
     *@private
     */
    this._domain = '';
    /**
     *@private
     */
    this._resource = '';

    if (typeof(jid) == 'string') {
        if (jid.indexOf('@') != -1) {
            this.setNode(jid.substring(0,jid.indexOf('@')));
            jid = jid.substring(jid.indexOf('@')+1);
        }
        if (jid.indexOf('/') != -1) {
            this.setResource(jid.substring(jid.indexOf('/')+1));
            jid = jid.substring(0,jid.indexOf('/'));
        }
        this.setDomain(jid);
    } else {
        this.setNode(jid.node);
        this.setDomain(jid.domain);
        this.setResource(jid.resource);
    }
}

/**
 * Gets the bare jid (i.e. the JID without resource)
 * @return A string representing the bare jid
 * @type String
 */
JSJaCJID.prototype.getBareJID = function() {
    return this.getNode()+'@'+this.getDomain();
};

/**
 * Gets the node part of the jid
 * @return A string representing the node name
 * @type String
 */
JSJaCJID.prototype.getNode = function() { return this._node; };

/**
 * Gets the domain part of the jid
 * @return A string representing the domain name
 * @type String
 */
JSJaCJID.prototype.getDomain = function() { return this._domain; };

/**
 * Gets the resource part of the jid
 * @return A string representing the resource
 * @type String
 */
JSJaCJID.prototype.getResource = function() { return this._resource; };


/**
 * Sets the node part of the jid
 * @param {String} node Name of the node
 * @throws JSJaCJIDInvalidException Thrown if node name contains invalid chars
 * @return This object
 * @type JSJaCJID
 */
JSJaCJID.prototype.setNode = function(node) {
    JSJaCJID._checkNodeName(node);
    this._node = node || '';
    return this;
};

/**
 * Sets the domain part of the jid
 * @param {String} domain Name of the domain
 * @throws JSJaCJIDInvalidException Thrown if domain name contains invalid
 * chars or is empty
 * @return This object
 * @type JSJaCJID
 */
JSJaCJID.prototype.setDomain = function(domain) {
    if (!domain || domain === '')
        throw new JSJaCJIDInvalidException("domain name missing");
    // chars forbidden for a node are not allowed in domain names
    // anyway, so let's check
    JSJaCJID._checkNodeName(domain);
    this._domain = domain;
    return this;
};

/**
 * Sets the resource part of the jid
 * @param {String} resource Name of the resource
 * @return This object
 * @type JSJaCJID
 */
JSJaCJID.prototype.setResource = function(resource) {
    this._resource = resource || '';
    return this;
};

/**
 * The string representation of the full jid
 * @return A string representing the jid
 * @type String
 */
JSJaCJID.prototype.toString = function() {
    var jid = '';
    if (this.getNode() && this.getNode() !== '')
        jid = this.getNode() + '@';
    jid += this.getDomain(); // we always have a domain
    if (this.getResource() && this.getResource() !== "")
        jid += '/' + this.getResource();
    return jid;
};

/**
 * Removes the resource part of the jid
 * @return This object
 * @type JSJaCJID
 */
JSJaCJID.prototype.removeResource = function() {
    return this.setResource();
};

/**
 * creates a copy of this JSJaCJID object
 * @return A copy of this
 * @type JSJaCJID
 */
JSJaCJID.prototype.clone = function() {
    return new JSJaCJID(this.toString());
};

/**
 * Compares two jids if they belong to the same entity (i.e. w/o resource)
 * @param {String} jid a jid as string or JSJaCJID object
 * @return 'true' if jid is same entity as this
 * @type Boolean
 */
JSJaCJID.prototype.isEntity = function(jid) {
    if (typeof jid == 'string')
        jid = (new JSJaCJID(jid));
    else
        jid = jid.clone();
    jid.removeResource();
    return (this.clone().removeResource().toString() === jid.toString());
};

/**
 * Check if node name is valid
 * @private
 * @param {String} node A name for a node
 * @throws JSJaCJIDInvalidException Thrown if name for node is not allowed
 */
JSJaCJID._checkNodeName = function(nodeprep) {
    if (!nodeprep || nodeprep === '')
        return;
    for (var i=0; i< JSJACJID_FORBIDDEN.length; i++) {
        if (nodeprep.indexOf(JSJACJID_FORBIDDEN[i]) != -1) {
            throw new JSJaCJIDInvalidException("forbidden char in nodename: "+JSJACJID_FORBIDDEN[i]);
        }
    }
};

/**
 * Creates a new Exception of type JSJaCJIDInvalidException
 * @class Exception to indicate invalid values for a jid
 * @constructor
 * @param {String} message The message associated with this Exception
 */
function JSJaCJIDInvalidException(message) {
    /**
     * The exceptions associated message
     * @type String
     */
    this.message = message;
    /**
     * The name of the exception
     * @type String
     */
    this.name = "JSJaCJIDInvalidException";
}

/**
 * Creates a new set of hash keys
 * @class Reflects a set of sha1/md5 hash keys for securing sessions
 * @constructor
 * @param {Function} func The hash function to be used for creating the keys
 * @param {Debugger} oDbg Reference to debugger implementation [optional]
 */
function JSJaCKeys(func,oDbg) {
  var seed = Math.random();

  /**
   * @private
   */
  this._k = new Array();
  this._k[0] = seed.toString();
  if (oDbg)
    /**
     * Reference to Debugger
     * @type Debugger
     */
    this.oDbg = oDbg;
  else {
    this.oDbg = {};
    this.oDbg.log = function() {};
  }

  if (func) {
    for (var i=1; i<JSJAC_NKEYS; i++) {
      this._k[i] = func(this._k[i-1]);
      oDbg.log(i+": "+this._k[i],4);
    }
  }

  /**
   * @private
   */
  this._indexAt = JSJAC_NKEYS-1;
  /**
   * Gets next key from stack
   * @return New hash key
   * @type String
   */
  this.getKey = function() {
    return this._k[this._indexAt--];
  };
  /**
   * Indicates whether there's only one key left
   * @return <code>true</code> if there's only one key left, false otherwise
   * @type boolean
   */
  this.lastKey = function() { return (this._indexAt == 0); };
  /**
   * Returns number of overall/initial stack size
   * @return Number of keys created
   * @type int
   */
  this.size = function() { return this._k.length; };

  /**
   * @private
   */
  this._getSuspendVars = function() {
    return ('_k,_indexAt').split(',');
  };
}
/**
 * @fileoverview Contains all Jabber/XMPP packet related classes.
 * @author Stefan Strigler steve@zeank.in-berlin.de
 */

var JSJACPACKET_USE_XMLNS = true;

/**
 * Creates a new packet with given root tag name (for internal use)
 * @class Somewhat abstract base class for all kinds of specialised packets
 * @param {String} name The root tag name of the packet
 * (i.e. one of 'message', 'iq' or 'presence')
 */
function JSJaCPacket(name) {
  /**
   * @private
   */
  this.name = name;

  if (typeof(JSJACPACKET_USE_XMLNS) != 'undefined' && JSJACPACKET_USE_XMLNS)
    /**
     * @private
     */
    this.doc = XmlDocument.create(name, NS_CLIENT);
  else
    /**
     * @private
     */
    this.doc = XmlDocument.create(name,'');
}

/**
 * Gets the type (name of root element) of this packet, i.e. one of
 * 'presence', 'message' or 'iq'
 * @return {string} The top level tag name.
 */
JSJaCPacket.prototype.pType = function() { return this.name; };

/**
 * Gets the associated Document for this packet.
 * @see {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#i-Document | Document}
 * @returns {Document}
 */
JSJaCPacket.prototype.getDoc = function() {
  return this.doc;
};
/**
 * Gets the root node of this packet
 * @see {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 | Node}
 * @return {Node}
 */
JSJaCPacket.prototype.getNode = function() {
  if (this.getDoc() && this.getDoc().documentElement)
    return this.getDoc().documentElement;
  else
    return null;
};

/**
 * Sets the 'to' attribute of the root node of this packet
 * @param {String} [to] A string representing a jid sending this packet to. If omitted the property will be deleted thus sending to service rather than dedicated recipient.
 * @return {JSJaCPacket} this
 */
JSJaCPacket.prototype.setTo = function(to) {
  if (!to || to == '')
    this.getNode().removeAttribute('to');
  else if (typeof(to) == 'string')
    this.getNode().setAttribute('to',to);
  else
    this.getNode().setAttribute('to',to.toString());
  return this;
};
/**
 * Sets the 'from' attribute of the root node of this
 * packet. Usually this is not needed as the server will take care
 * of this automatically.
 * @param {string} [from] A string representing the jid of the sender of this packet.
 * @deprecated
 * @return {JSJaCPacket} this
 */
JSJaCPacket.prototype.setFrom = function(from) {
  if (!from || from == '')
    this.getNode().removeAttribute('from');
  else if (typeof(from) == 'string')
    this.getNode().setAttribute('from',from);
  else
    this.getNode().setAttribute('from',from.toString());
  return this;
};

/**
 * Sets 'id' attribute of the root node of this packet.
 * @param {string} id The id of the packet.
 * @return {JSJaCPacket} this
 */
JSJaCPacket.prototype.setID = function(id) {
  if (!id || id == '')
    this.getNode().removeAttribute('id');
  else
    this.getNode().setAttribute('id',id);
  return this;
};
/**
 * Sets the 'type' attribute of the root node of this packet.
 * @param {string} type The type of the packet.
 * @return {JSJaCPacket} this
 */
JSJaCPacket.prototype.setType = function(type) {
  if (!type || type == '')
    this.getNode().removeAttribute('type');
  else
    this.getNode().setAttribute('type',type);
  return this;
};
/**
 * Sets 'xml:lang' for this packet
 * @param {string} xmllang The xml:lang of the packet.
 * @return {JSJaCPacket} this
 */
JSJaCPacket.prototype.setXMLLang = function(xmllang) {
  if (!xmllang || xmllang == '')
    this.getNode().removeAttribute('xml:lang');
  else
    this.getNode().setAttribute('xml:lang',xmllang);
  return this;
};

/**
 * Gets the 'to' attribute of this packet
 * @return {string}
 */
JSJaCPacket.prototype.getTo = function() {
  return this.getNode().getAttribute('to');
};
/**
 * Gets the 'from' attribute of this packet.
 * @return {string}
 */
JSJaCPacket.prototype.getFrom = function() {
  return this.getNode().getAttribute('from');
};
/**
 * Gets the 'to' attribute of this packet as a JSJaCJID object
 * @return {JSJaCJID}
 */
JSJaCPacket.prototype.getToJID = function() {
  return new JSJaCJID(this.getTo());
};
/**
 * Gets the 'from' attribute of this packet as a JSJaCJID object
 * @return {JSJaCJID}
 */
JSJaCPacket.prototype.getFromJID = function() {
  return new JSJaCJID(this.getFrom());
};
/**
 * Gets the 'id' of this packet
 * @return {string}
 */
JSJaCPacket.prototype.getID = function() {
  return this.getNode().getAttribute('id');
};
/**
 * Gets the 'type' of this packet
 * @return {string}
 */
JSJaCPacket.prototype.getType = function() {
  return this.getNode().getAttribute('type');
};
/**
 * Gets the 'xml:lang' of this packet
 * @return {string}
 */
JSJaCPacket.prototype.getXMLLang = function() {
  return this.getNode().getAttribute('xml:lang');
};
/**
 * Gets the 'xmlns' (xml namespace) of the root node of this packet
 * @return {string}
 */
JSJaCPacket.prototype.getXMLNS = function() {
  return this.getNode().namespaceURI || this.getNode().getAttribute('xmlns');
};

/**
 * Gets a child element of this packet. If no params given returns first child.
 * @see {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 | Node}
 * @param {string} name Tagname of child to retrieve. Use '*' to match any tag. [optional]
 * @param {string} ns   Namespace of child. Use '*' to match any ns.[optional]
 * @return {Node} The child node, null if none found
 */
JSJaCPacket.prototype.getChild = function(name, ns) {
  if (!this.getNode()) {
    return null;
  }

  name = name || '*';
  ns = ns || '*';

  if (this.getNode().getElementsByTagNameNS) {
    return this.getNode().getElementsByTagNameNS(ns, name).item(0);
  }

  // fallback
  var nodes = this.getNode().getElementsByTagName(name);
  if (ns != '*') {
    for (var i=0; i<nodes.length; i++) {
      if (nodes.item(i).namespaceURI == ns || nodes.item(i).getAttribute('xmlns') == ns) {
        return nodes.item(i);
      }
    }
  } else {
    return nodes.item(0);
  }
  return null; // nothing found
};

/**
 * Gets the node value of a child element of this packet.
 * @param {string} name Tagname of child to retrieve.
 * @param {string} ns   Namespace of child
 * @return {string} The value of the child node, empty string if none found
 */
JSJaCPacket.prototype.getChildVal = function(name, ns) {
  var node = this.getChild(name, ns);
  var ret = '';
  if (node && node.hasChildNodes()) {
    // concatenate all values from childNodes
    for (var i=0; i<node.childNodes.length; i++)
      if (node.childNodes.item(i).nodeValue)
        ret += node.childNodes.item(i).nodeValue;
  }
  return ret;
};

/**
 * Returns a copy of this node
 * @return {JSJaCPacket} a copy of this node
 */
JSJaCPacket.prototype.clone = function() {
  return JSJaCPacket.wrapNode(this.getNode());
};

/**
 * Checks if packet is of type 'error'
 * @return {boolean} 'true' if this packet is of type 'error', 'false' otherwise
 */
JSJaCPacket.prototype.isError = function() {
  return (this.getType() == 'error');
};

/**
 * Returns an error condition reply according to {@link http://xmpp.org/extensions/xep-0086.html | XEP-0086}. Creates a clone of the calling packet with senders and recipient exchanged and error stanza appended.
 * @param {STANZA_ERROR} stanza_error an error stanza containing error cody, type and condition of the error to be indicated
 * @return {JSJaCPacket} an error reply packet
 */
JSJaCPacket.prototype.errorReply = function(stanza_error) {
  var rPacket = this.clone();
  rPacket.setTo(this.getFrom());
  rPacket.setFrom();
  rPacket.setType('error');

  rPacket.appendNode('error',
                     {code: stanza_error.code, type: stanza_error.type},
                     [[stanza_error.cond, {xmlns: NS_STANZAS}]]);

  return rPacket;
};

/**
 * Returns a string representation of the raw xml content of this packet.
 * @return {string} deserialized xml packet
 */
JSJaCPacket.prototype.xml = typeof XMLSerializer != 'undefined' ?
function() {
  var r = (new XMLSerializer()).serializeToString(this.getNode());
  if (typeof(r) == 'undefined')
    r = (new XMLSerializer()).serializeToString(this.doc); // oldschool
  return r;
} :
function() {// IE
  return this.getDoc().xml;
};


// PRIVATE METHODS DOWN HERE

/**
 * Gets an attribute of the root element
 * @private
 */
JSJaCPacket.prototype._getAttribute = function(attr) {
  return this.getNode().getAttribute(attr);
};


if (document.ELEMENT_NODE == null) {
  document.ELEMENT_NODE = 1;
  document.ATTRIBUTE_NODE = 2;
  document.TEXT_NODE = 3;
  document.CDATA_SECTION_NODE = 4;
  document.ENTITY_REFERENCE_NODE = 5;
  document.ENTITY_NODE = 6;
  document.PROCESSING_INSTRUCTION_NODE = 7;
  document.COMMENT_NODE = 8;
  document.DOCUMENT_NODE = 9;
  document.DOCUMENT_TYPE_NODE = 10;
  document.DOCUMENT_FRAGMENT_NODE = 11;
  document.NOTATION_NODE = 12;
}

/**
 * import node into this packets document
 * @private
 */
JSJaCPacket.prototype._importNode = function(node, allChildren) {
  switch (node.nodeType) {
  case document.ELEMENT_NODE:

  var newNode;
  if (this.getDoc().createElementNS) {
    newNode = this.getDoc().createElementNS(node.namespaceURI, node.nodeName);
  } else {
    newNode = this.getDoc().createElement(node.nodeName);
  }

  var i, il;
  /* does the node have any attributes to add? */
  if (node.attributes && node.attributes.length > 0)
    for (i = 0, il = node.attributes.length;i < il; i++) {
      var attr = node.attributes.item(i);
      if (attr.nodeName == 'xmlns' &&
          (newNode.getAttribute('xmlns') !== null || newNode.namespaceURI)) {
          // skip setting an xmlns attribute as it has been set
          // before already by createElementNS

          // namespaceURI is '' for IE<9
          continue;
      }
      if (newNode.setAttributeNS && attr.namespaceURI) {
        newNode.setAttributeNS(attr.namespaceURI,
                               attr.name,
                               attr.value);
      } else {
        newNode.setAttribute(attr.name,
                             attr.value);
      }
    }
  /* are we going after children too, and does the node have any? */
  if (allChildren && node.childNodes && node.childNodes.length > 0) {
    for (i = 0, il = node.childNodes.length; i < il; i++) {
      newNode.appendChild(this._importNode(node.childNodes.item(i), allChildren));
    }
  }
  return newNode;
  case document.TEXT_NODE:
  case document.CDATA_SECTION_NODE:
  case document.COMMENT_NODE:
  return this.getDoc().createTextNode(node.nodeValue);
  }
};

/**
 * Set node value of a child node
 * @private
 */
JSJaCPacket.prototype._setChildNode = function(nodeName, nodeValue) {
  var aNode = this.getChild(nodeName);
  var tNode = this.getDoc().createTextNode(nodeValue);
  if (aNode)
    try {
      aNode.replaceChild(tNode,aNode.firstChild);
    } catch (e) { }
  else {
    try {
      aNode = this.getDoc().createElementNS(this.getNode().namespaceURI,
                                            nodeName);
    } catch (ex) {
      aNode = this.getDoc().createElement(nodeName);
    }
    this.getNode().appendChild(aNode);
    aNode.appendChild(tNode);
  }
  return aNode;
};

/**
 * Builds a node using {@link http://wiki.script.aculo.us/scriptaculous/show/Builder | script.aculo.us' Dom Builder} notation.
 * This code is taken from {@link http://wiki.script.aculo.us/scriptaculous/show/Builder | script.aculo.us' Dom Builder} and has been modified to suit our needs.<br/>
 * The original parts of the code do have the following copyright
 * and license notice:<br/>
 * Copyright (c) 2005, 2006 Thomas Fuchs (http://script.aculo.us,
 * http://mir.acu lo.us) <br/>
 * script.aculo.us is freely distributable under the terms of an
 * MIT-style licen se.  // For details, see the script.aculo.us web
 * site: http://script.aculo.us/<br>
 * @author Thomas Fuchs
 * @author Stefan Strigler
 * @return {Node} The newly created node
 * @see {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 | Node}
 */
JSJaCPacket.prototype.buildNode = function(elementName) {
  return JSJaCBuilder.buildNode(this.getDoc(),
                                elementName,
                                arguments[1],
                                arguments[2],
                                arguments[3]);
};

/**
 * Appends node created by buildNode to this packets parent node.
 * @param {Node} element The node to append or
 * @param {string} element A name plus an object hash with attributes (optional) plus an array of childnodes (optional)
 * @see #buildNode
 * @return {JSJaCPacket} This packet
 * @see {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 | Node}
 */
JSJaCPacket.prototype.appendNode = function(element) {
  if (typeof element=='object') { // seems to be a prebuilt node
    this.getNode().appendChild(element);
  } else { // build node
    this.getNode().appendChild(this.buildNode(element,
                                                     arguments[1],
                                                     arguments[2],
                                                     this.getNode().namespaceURI));
  }
  return this;
};


/**
 * A jabber/XMPP presence packet
 * @class Models the XMPP notion of a 'presence' packet
 * @extends JSJaCPacket
 */
function JSJaCPresence() {
  /**
   * @ignore
   */
  this.base = JSJaCPacket;
  this.base('presence');
}
JSJaCPresence.prototype = new JSJaCPacket;

/**
 * Sets the status message for current status. Usually this is set
 * to some human readable string indicating what the user is
 * doing/feel like currently.
 * @param {string} status A status message
 * @return {JSJaCPresence} this
 */
JSJaCPresence.prototype.setStatus = function(status) {
  this._setChildNode("status", status);
  return this;
};
/**
 * Sets the online status for this presence packet.
 * @param {string} show An XMPP complient status indicator. Must
 * be one of 'chat', 'away', 'xa', 'dnd'
 * @return {JSJaCPresence} this
 */
JSJaCPresence.prototype.setShow = function(show) {
  if (show == 'chat' || show == 'away' || show == 'xa' || show == 'dnd')
    this._setChildNode("show",show);
  return this;
};
/**
 * Sets the priority of the resource bind to with this connection
 * @param {int} prio The priority to set this resource to
 * @return {JSJaCPresence} this
 */
JSJaCPresence.prototype.setPriority = function(prio) {
  this._setChildNode("priority", prio);
  return this;
};
/**
 * Some combined method that allowes for setting show, status and
 * priority at once
 * @param {string} show A status message
 * @param {string} status A status indicator as defined by XMPP
 * @param {int} prio A priority for this resource
 * @return {JSJaCPresence} this
 */
JSJaCPresence.prototype.setPresence = function(show,status,prio) {
  if (show)
    this.setShow(show);
  if (status)
    this.setStatus(status);
  if (prio)
    this.setPriority(prio);
  return this;
};

/**
 * Gets the status message of this presence
 * @return The (human readable) status message
 * @type String
 */
JSJaCPresence.prototype.getStatus = function() {
  return this.getChildVal('status');
};
/**
 * Gets the status of this presence.
 * Either one of 'chat', 'away', 'xa' or 'dnd' or null.
 * @return The status indicator as defined by XMPP
 * @type String
 */
JSJaCPresence.prototype.getShow = function() {
  return this.getChildVal('show');
};
/**
 * Gets the priority of this status message
 * @return A resource priority
 * @type int
 */
JSJaCPresence.prototype.getPriority = function() {
  return this.getChildVal('priority');
};


/**
 * A jabber/XMPP iq packet
 * @class Models the XMPP notion of an 'iq' packet
 * @extends JSJaCPacket
 */
function JSJaCIQ() {
  /**
   * @ignore
   */
  this.base = JSJaCPacket;
  this.base('iq');
}
JSJaCIQ.prototype = new JSJaCPacket;

/**
 * Some combined method to set 'to', 'type' and 'id' at once
 * @param {string} to the recepients JID
 * @param {string} type A XMPP compliant iq type (one of 'set', 'get', 'result' and 'error'
 * @param {string} id A packet ID
 * @return {JSJaCIQ} this
 */
JSJaCIQ.prototype.setIQ = function(to,type,id) {
  if (to)
    this.setTo(to);
  if (type)
    this.setType(type);
  if (id)
    this.setID(id);
  return this;
};
/**
 * Creates a 'query' child node with given XMLNS
 * @param {string} xmlns The namespace for the 'query' node
 * @return {Node} The query node
 * @see {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 | Node}
 */
JSJaCIQ.prototype.setQuery = function(xmlns) {
  var query;
  try {
    query = this.getDoc().createElementNS(xmlns,'query');
  } catch (e) {
    query = this.getDoc().createElement('query');
	query.setAttribute('xmlns',xmlns);
  }
  this.getNode().appendChild(query);
  return query;
};

/**
 * Gets the 'query' node of this packet
 * @return {Node} The query node
 * @see {@link http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247 | Node}
 */
JSJaCIQ.prototype.getQuery = function() {
  return this.getNode().getElementsByTagName('query').item(0);
};
/**
 * Gets the XMLNS of the query node contained within this packet
 * @return {string} The namespace of the query node
 */
JSJaCIQ.prototype.getQueryXMLNS = function() {
  if (this.getQuery()) {
    return this.getQuery().namespaceURI || this.getQuery().getAttribute('xmlns');
  } else {
    return null;
  }
};

/**
 * Creates an IQ reply with type set to 'result'. If given appends payload to first child if IQ. Payload maybe XML as string or a DOM element (or an array of such elements as well).
 * @param {Element} [payload] An optional payload to be appended.
 * @return {JSJaCIQ} An IQ reply packet
 */
JSJaCIQ.prototype.reply = function(payload) {
  var rIQ = this.clone();
  rIQ.setTo(this.getFrom());
  rIQ.setFrom();
  rIQ.setType('result');
  if (payload) {
    if (typeof payload == 'string')
      rIQ.getChild().appendChild(rIQ.getDoc().loadXML(payload));
    else if (payload.constructor == Array) {
      var node = rIQ.getChild();
      for (var i=0; i<payload.length; i++)
        if(typeof payload[i] == 'string')
          node.appendChild(rIQ.getDoc().loadXML(payload[i]));
        else if (typeof payload[i] == 'object')
          node.appendChild(payload[i]);
    }
    else if (typeof payload == 'object')
      rIQ.getChild().appendChild(payload);
  }
  return rIQ;
};

/**
 * A jabber/XMPP message packet
 * @class Models the XMPP notion of an 'message' packet
 * @extends JSJaCPacket
 */
function JSJaCMessage() {
  /**
   * @ignore
   */
  this.base = JSJaCPacket;
  this.base('message');
}
JSJaCMessage.prototype = new JSJaCPacket;

/**
 * Sets the body of the message
 * @param {string} body Your message to be sent along
 * @return {JSJaCMessage} this message
 */
JSJaCMessage.prototype.setBody = function(body) {
  this._setChildNode("body",body);
  return this;
};
/**
 * Sets the subject of the message
 * @param {string} subject Your subject to be sent along
 * @return {JSJaCMessage} this message
 */
JSJaCMessage.prototype.setSubject = function(subject) {
  this._setChildNode("subject",subject);
  return this;
};
/**
 * Sets the 'tread' attribute for this message. This is used to identify
 * threads in chat conversations
 * @param {string} thread Usually a somewhat random hash.
 * @returns {JSJaCMessage} this message
 */
JSJaCMessage.prototype.setThread = function(thread) {
  this._setChildNode("thread", thread);
  return this;
};
/**
 * Gets the 'thread' identifier for this message
 * @return {string} A thread identifier
 */
JSJaCMessage.prototype.getThread = function() {
  return this.getChildVal('thread');
};
/**
 * Gets the body of this message
 * @return {string} The body of this message
 */
JSJaCMessage.prototype.getBody = function() {
  return this.getChildVal('body');
};
/**
 * Gets the subject of this message
 * @return {string} The subject of this message
 */
JSJaCMessage.prototype.getSubject = function() {
  return this.getChildVal('subject');
};


/**
 * Tries to transform a w3c DOM node to JSJaC's internal representation
 * (JSJaCPacket type, one of JSJaCPresence, JSJaCMessage, JSJaCIQ)
 * @param: {Node
 * http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247}
 * node The node to be transformed
 * @return A JSJaCPacket representing the given node. If node's root
 * elemenent is not one of 'message', 'presence' or 'iq',
 * <code>null</code> is being returned.
 * @type JSJaCPacket
 */
JSJaCPacket.wrapNode = function(node) {
  var oPacket = null;

  switch (node.nodeName.toLowerCase()) {
  case 'presence':
      oPacket = new JSJaCPresence();
      break;
  case 'message':
      oPacket = new JSJaCMessage();
      break;
  case 'iq':
      oPacket = new JSJaCIQ();
      break;
  }

  if (oPacket) {
    oPacket.getDoc().replaceChild(oPacket._importNode(node, true),
                                  oPacket.getNode());
  }

  return oPacket;
};
/**
 * @fileoverview Contains all things in common for all subtypes of connections
 * supported.
 * @author Stefan Strigler steve@zeank.in-berlin.de
 */

/**
 * Creates a new Jabber/XMPP connection (a connection to a jabber server)
 * @class Somewhat abstract base class for jabber connections. Contains all
 * of the code in common for all jabber connections
 * @constructor
 * @param {Object} oArg Configurational object for this connection.
 * @param {string} oArg.httpbase The connection endpoint of the HTTP service to talk to.
 * @param {JSJaCDebugger} [oArg.oDbg] A reference to a debugger implementing the JSJaCDebugger interface.
 * @param {int} [oArg.timerval] The polling interval.
 * @param {string} [oArg.cookie_prefix] Prefix to cookie names used when suspending.
 */
function JSJaCConnection(oArg) {

  if (oArg && oArg.httpbase)
    /**
     * @private
     */
    this._httpbase = oArg.httpbase;

  if (oArg && oArg.oDbg && oArg.oDbg.log) {
      /**
       * Reference to debugger interface
       * (needs to implement method <code>log</code>)
       * @type JSJaCDebugger
       */
    this.oDbg = oArg.oDbg;
  } else {
      this.oDbg = {log: function() { }};
  }

  if (oArg && oArg.timerval)
    this.setPollInterval(oArg.timerval);
  else
    this.setPollInterval(JSJAC_TIMERVAL);

  if (oArg && oArg.cookie_prefix)
      /**
       * @private
       */
    this._cookie_prefix = oArg.cookie_prefix;
  else
    this._cookie_prefix = "";

  /**
   * @private
   */
  this._connected = false;
  /**
   * @private
   */
  this._events = [];
  /**
   * @private
   */
  this._keys = null;
  /**
   * @private
   */
  this._ID = 0;
  /**
   * @private
   */
  this._inQ = [];
  /**
   * @private
   */
  this._pQueue = [];
  /**
   * @private
   */
  this._regIDs = [];
  /**
   * @private
   */
  this._req = [];
  /**
   * @private
   */
  this._status = 'intialized';
  /**
   * @private
   */
  this._errcnt = 0;
  /**
   * @private
   */
  this._inactivity = JSJAC_INACTIVITY;
  /**
   * @private
   */
  this._sendRawCallbacks = [];
}

/**
 * Connect to a jabber/XMPP server.
 * @param {Object} oArg The configuration to be used for connecting.
 * @param {string} oArg.domain The domain name of the XMPP service.
 * @param {string} oArg.username The username (nodename) to be logged in with.
 * @param {string} oArg.resource The resource to identify the login with.
 * @param {string} oArg.password The user's password.
 * @param {boolean} [oArg.allow_plain] Whether to allow plain text logins.
 * @param {boolean} [oArg.register] Whether to register a new account.
 * @param {string} [oArg.host] The host to connect to which might be different from the domain given above. So some XMPP service might host the domain 'example.com' but might be located at the host 'jabber.example.com'. Normally such situations should be gracefully handled by using DNS SRV records. But in cases where this isn't available you can set the host manually here.
 * @param {int} [oArg.port] The port of the manually given host from above.
 * @param {boolean} [oArg.secure] Whether to only allow secured (i.e. encrypted) connections to the XMPP service.
 * @param {string} [oArg.authhost] The host that handles the actualy authorization. There are cases where this is different from the settings above, e.g. if there's a service that provides anonymous logins at 'anon.example.org'.
 * @param {string} [oArg.authtype] Must be one of 'sasl' (default), 'nonsasl', 'saslanon', 'anonymous', or 'x-facebook-platform'.
 * @param {string} [oArg.xmllang] The requested language for this login. Typically XMPP server try to respond with error messages and the like in this language if available.
 */
JSJaCConnection.prototype.connect = function(oArg) {
    this._setStatus('connecting');

    if (oArg.authtype != 'x-facebook-platform') {

        this.domain = oArg.domain || 'localhost';
        this.username = oArg.username;
        this.resource = oArg.resource;
        this.pass = oArg.password || oArg.pass;
        this.register = oArg.register;

        this.authhost = oArg.authhost || oArg.host || oArg.domain;
        this.authtype = oArg.authtype || 'sasl';

    } else {

        this.domain = 'chat.facebook.com';
        this.authtype = oArg.authtype;

        if (oArg.facebookApp !== undefined) {

            this._facebookApp = oArg.facebookApp;

            if(!document.getElementById('fb-root')){
                var fbDiv = document.createElement('div');
                fbDiv.id = 'fb-root';
                document.body.appendChild(fbDiv);
            }

              if (oArg.facebookApp.getSession() === undefined) {
                this._facebookApp.Login(this, oArg);
                return;
            }

        } else {
             this.oDbg.log("No Facebook application param specified!",1);
            return;
        }

    }

    if (oArg.xmllang && oArg.xmllang !== '')
        this._xmllang = oArg.xmllang;
    else
        this._xmllang = 'en';

    if (oArg.allow_plain)
        this._allow_plain = oArg.allow_plain;
    else
        this._allow_plain = JSJAC_ALLOW_PLAIN;

    this.host = oArg.host;
    this.port = oArg.port || 5222;
    if (oArg.secure)
        /**
         * @private
         */
        this.secure = 'true';
    else
        /**
         * @private
         */
        this.secure = 'false';

    this.jid = this.username + '@' + this.domain;
    this.fulljid = this.jid + '/' + this.resource;

    this._rid  = Math.round( 100000.5 + ( ( (900000.49999) - (100000.5) ) * Math.random() ) );

    // setupRequest must be done after rid is created but before first use in reqstr
    var slot = this._getFreeSlot();
    this._req[slot] = this._setupRequest(true);

    var reqstr = this._getInitialRequestString();

    this.oDbg.log(reqstr,4);

    this._req[slot].r.onreadystatechange =
        JSJaC.bind(function() {
            var r = this._req[slot].r;
            if (r.readyState == 4) {
                this.oDbg.log("async recv: "+r.responseText,4);
                this._handleInitialResponse(r); // handle response
            }
        }, this);

    if (typeof(this._req[slot].r.onerror) != 'undefined') {
        this._req[slot].r.onerror =
            JSJaC.bind(function(e) {
                this.oDbg.log('XmlHttpRequest error',1);
            }, this);
    }

    this._req[slot].r.send(reqstr);
};

/**
 * Tells whether this connection is connected
 * @return <code>true</code> if this connections is connected,
 * <code>false</code> otherwise
 * @type boolean
 */
JSJaCConnection.prototype.connected = function() { return this._connected; };

/**
 * Disconnects from jabber server and terminates session (if applicable)
 */
JSJaCConnection.prototype.disconnect = function() {
  this._setStatus('disconnecting');

  if (!this.connected())
    return;
  this._connected = false;

  clearInterval(this._interval);
  clearInterval(this._inQto);

  if (this._timeout)
    clearTimeout(this._timeout); // remove timer

  var slot = this._getFreeSlot();
  // Intentionally synchronous
  this._req[slot] = this._setupRequest(false);

  var request = this._getRequestString(false, true);

  this.oDbg.log("Disconnecting: " + request,4);
  try {
    this._req[slot].r.send(request);
  } catch(e) {}
  this.oDbg.log("disconnected");
  try {
    JSJaCCookie.read(this._cookie_prefix+'JSJaC_State').erase();
  } catch (e) {}

  this._handleEvent('ondisconnect');
};

/**
 * Gets current value of polling interval
 * @return Polling interval in milliseconds
 * @type int
 */
JSJaCConnection.prototype.getPollInterval = function() {
  return this._timerval;
};

/**
 * Registers an event handler (callback) for this connection.

 * <p>Note: All of the packet handlers for specific packets (like
 * message_in, presence_in and iq_in) fire only if there's no
 * callback associated with the id.<br>

 * <p>Example:<br/>
 * <code>con.registerHandler('iq', 'query', 'jabber:iq:version', handleIqVersion);</code>


 * @param {String} event One of

 * <ul>
 * <li>onConnect - connection has been established and authenticated</li>
 * <li>onDisconnect - connection has been disconnected</li>
 * <li>onResume - connection has been resumed</li>

 * <li>onStatusChanged - connection status has changed, current
 * status as being passed argument to handler. See {@link #status}.</li>

 * <li>onError - an error has occured, error node is supplied as
 * argument, like this:<br><code>&lt;error code='404' type='cancel'&gt;<br>
 * &lt;item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/&gt;<br>
 * &lt;/error&gt;</code></li>

 * <li>packet_in - a packet has been received (argument: the
 * packet)</li>

 * <li>packet_out - a packet is to be sent(argument: the
 * packet)</li>

 * <li>message_in | message - a message has been received (argument:
 * the packet)</li>

 * <li>message_out - a message packet is to be sent (argument: the
 * packet)</li>

 * <li>presence_in | presence - a presence has been received
 * (argument: the packet)</li>

 * <li>presence_out - a presence packet is to be sent (argument: the
 * packet)</li>

 * <li>iq_in | iq - an iq has been received (argument: the packet)</li>
 * <li>iq_out - an iq is to be sent (argument: the packet)</li>
 * </ul>

 * @param {String} childName A childnode's name that must occur within a
 * retrieved packet [optional]

 * @param {String} childNS A childnode's namespace that must occure within
 * a retrieved packet (works only if childName is given) [optional]

 * @param {String} type The type of the packet to handle (works only if childName and chidNS are given (both may be set to '*' in order to get skipped) [optional]

 * @param {Function} handler The handler to be called when event occurs. If your handler returns 'true' it cancels bubbling of the event. No other registered handlers for this event will be fired.
 */
JSJaCConnection.prototype.registerHandler = function(event) {
  event = event.toLowerCase(); // don't be case-sensitive here
  var eArg = {handler: arguments[arguments.length-1],
              childName: '*',
              childNS: '*',
              type: '*'};
  if (arguments.length > 2)
    eArg.childName = arguments[1];
  if (arguments.length > 3)
    eArg.childNS = arguments[2];
  if (arguments.length > 4)
    eArg.type = arguments[3];
  if (!this._events[event])
    this._events[event] = new Array(eArg);
  else
    this._events[event] = this._events[event].concat(eArg);

  // sort events in order how specific they match criterias thus using
  // wildcard patterns puts them back in queue when it comes to
  // bubbling the event
  this._events[event] =
  this._events[event].sort(function(a,b) {
    var aRank = 0;
    var bRank = 0;
    with (a) {
      if (type == '*')
        aRank++;
      if (childNS == '*')
        aRank++;
      if (childName == '*')
        aRank++;
    }
    with (b) {
      if (type == '*')
        bRank++;
      if (childNS == '*')
        bRank++;
      if (childName == '*')
        bRank++;
    }
    if (aRank > bRank)
      return 1;
    if (aRank < bRank)
      return -1;
    return 0;
  });
  this.oDbg.log("registered handler for event '"+event+"'",2);
};

JSJaCConnection.prototype.unregisterHandler = function(event,handler) {
  event = event.toLowerCase(); // don't be case-sensitive here

  if (!this._events[event])
    return;

  var arr = this._events[event], res = [];
  for (var i=0; i<arr.length; i++)
    if (arr[i].handler != handler)
      res.push(arr[i]);

  if (arr.length != res.length) {
    this._events[event] = res;
    this.oDbg.log("unregistered handler for event '"+event+"'",2);
  }
};

/**
 * Register for iq packets of type 'get'.
 * @param {String} childName A childnode's name that must occur within a
 * retrieved packet

 * @param {String} childNS A childnode's namespace that must occure within
 * a retrieved packet (works only if childName is given)

 * @param {Function} handler The handler to be called when event occurs. If your handler returns 'true' it cancels bubbling of the event. No other registered handlers for this event will be fired.
 */
JSJaCConnection.prototype.registerIQGet =
  function(childName, childNS, handler) {
  this.registerHandler('iq', childName, childNS, 'get', handler);
};

/**
 * Register for iq packets of type 'set'.
 * @param {String} childName A childnode's name that must occur within a
 * retrieved packet

 * @param {String} childNS A childnode's namespace that must occure within
 * a retrieved packet (works only if childName is given)

 * @param {Function} handler The handler to be called when event occurs. If your handler returns 'true' it cancels bubbling of the event. No other registered handlers for this event will be fired.
 */
JSJaCConnection.prototype.registerIQSet =
  function(childName, childNS, handler) {
  this.registerHandler('iq', childName, childNS, 'set', handler);
};

/**
 * Resumes this connection from saved state (cookie)
 * @return Whether resume was successful
 * @type boolean
 */
JSJaCConnection.prototype.resume = function() {
  try {
    var json = JSJaCCookie.read(this._cookie_prefix+'JSJaC_State').getValue();
    this.oDbg.log('read cookie: '+json,2);
    JSJaCCookie.read(this._cookie_prefix+'JSJaC_State').erase();

    return this.resumeFromData(JSJaCJSON.parse(json));
  } catch (e) {}
    return false;
};

/**
 * Resumes BOSH connection from data
 * @param {Object} serialized jsjac state information
 * @return Whether resume was successful
 * @type boolean
 */
JSJaCConnection.prototype.resumeFromData = function(data) {
    try {

        for (var i in data)
            if (data.hasOwnProperty(i))
                this[i] = data[i];

        // copy keys - not being very generic here :-/
        if (this._keys) {
            this._keys2 = new JSJaCKeys();
            var u = this._keys2._getSuspendVars();
            for (var j=0; j<u.length; j++)
                this._keys2[u[j]] = this._keys[u[j]];
            this._keys = this._keys2;
        }

        if (this._connected) {
            this._setStatus('resuming');
            this._handleEvent('onresume');

            // don't poll too fast!
            setTimeout(JSJaC.bind(this._resume, this),this.getPollInterval());

            this._interval = setInterval(JSJaC.bind(this._checkQueue, this),
                                         JSJAC_CHECKQUEUEINTERVAL);
            this._inQto = setInterval(JSJaC.bind(this._checkInQ, this),
                                      JSJAC_CHECKINQUEUEINTERVAL);
        } else {
            this._setStatus('terminated');
        }

        return (this._connected === true);
    } catch (e) {
        if (e.message)
            this.oDbg.log("Resume failed: "+e.message, 1);
        else
            this.oDbg.log("Resume failed: "+e, 1);
        return false;
    }
};

/**
 * Sends a JSJaCPacket
 * @param {JSJaCPacket} packet  The packet to send
 * @param {Function}    cb      The callback to be called if there's a reply
 * to this packet (identified by id) [optional]
 * @param {Object}      arg     Arguments passed to the callback
 * (additionally to the packet received) [optional]
 * @return 'true' if sending was successfull, 'false' otherwise
 * @type boolean
 */
JSJaCConnection.prototype.send = function(packet,cb,arg) {
  if (!packet || !packet.pType) {
    this.oDbg.log("no packet: "+packet, 1);
    return false;
  }

  if (!this.connected())
    return false;

  // if (this._xmllang && !packet.getXMLLang())
  //   packet.setXMLLang(this._xmllang);

  // remember id for response if callback present
  if (cb) {
    if (!packet.getID())
      packet.setID('JSJaCID_'+this._ID++); // generate an ID

    // register callback with id
    this._registerPID(packet.getID(),cb,arg);
  }

  this._pQueue = this._pQueue.concat(packet.xml());
  this._handleEvent(packet.pType()+'_out', packet);
  this._handleEvent("packet_out", packet);

  return true;
};

/**
 * Sends an IQ packet. Has default handlers for each reply type.
 * Those maybe overriden by passing an appropriate handler.
 * @param {JSJaCIQPacket} iq - the iq packet to send
 * @param {Object} handlers - object with properties 'error_handler',
 *                            'result_handler' and 'default_handler'
 *                            with appropriate functions
 * @param {Object} arg - argument to handlers
 * @return 'true' if sending was successfull, 'false' otherwise
 * @type boolean
 */
JSJaCConnection.prototype.sendIQ = function(iq, handlers, arg) {
  if (!iq || iq.pType() != 'iq') {
    return false;
  }

  handlers = handlers || {};
    var error_handler = handlers.error_handler || JSJaC.bind(function(aIq) {
        this.oDbg.log(aIq.xml(), 1);
    }, this);

    var result_handler = handlers.result_handler ||  JSJaC.bind(function(aIq) {
        this.oDbg.log(aIq.xml(), 2);
    }, this);

  var iqHandler = function(aIq, arg) {
    switch (aIq.getType()) {
      case 'error':
      error_handler(aIq);
      break;
      case 'result':
      result_handler(aIq, arg);
      break;
    }
  };
  return this.send(iq, iqHandler, arg);
};

/**
 * Sets polling interval for this connection
 * @param {int} millisecs Milliseconds to set timer to
 * @return effective interval this connection has been set to
 * @type int
 */
JSJaCConnection.prototype.setPollInterval = function(timerval) {
  if (timerval && !isNaN(timerval))
    this._timerval = timerval;
  return this._timerval;
};

/**
 * Returns current status of this connection
 * @return String to denote current state. One of
 * <ul>
 * <li>'initializing' ... well
 * <li>'connecting' if connect() was called
 * <li>'resuming' if resume() was called
 * <li>'processing' if it's about to operate as normal
 * <li>'onerror_fallback' if there was an error with the request object
 * <li>'protoerror_fallback' if there was an error at the http binding protocol flow (most likely that's where you interested in)
 * <li>'internal_server_error' in case of an internal server error
 * <li>'suspending' if suspend() is being called
 * <li>'aborted' if abort() was called
 * <li>'disconnecting' if disconnect() has been called
 * </ul>
 * @type String
 */
JSJaCConnection.prototype.status = function() { return this._status; };

/**
 * Suspends this connection (saving state for later resume)
 * Saves state to cookie
 * @return Whether suspend (saving to cookie) was successful
 * @type boolean
 */
JSJaCConnection.prototype.suspend = function() {
  var data = this.suspendToData();

  try {
    var c = new JSJaCCookie(this._cookie_prefix+'JSJaC_State', JSJaCJSON.toString(data));
    this.oDbg.log("writing cookie: "+c.getValue()+"\n"+
                  "(length:"+c.getValue().length+")",2);
    c.write();

    var c2 = JSJaCCookie.get(this._cookie_prefix+'JSJaC_State');
    if (c.getValue() != c2) {
      this.oDbg.log("Suspend failed writing cookie.\nread: " + c2, 1);
      c.erase();
      return false;
    }
    return true;
  } catch (e) {
    this.oDbg.log("Failed creating cookie '"+this._cookie_prefix+
                  "JSJaC_State': "+e.message,1);
  }
  return false;
};

/**
 * Suspend connection and return serialized JSJaC connection state
 * @return JSJaC connection state object
 * @type Object
 */
JSJaCConnection.prototype.suspendToData = function() {

  // remove timers
  clearTimeout(this._timeout);
  clearInterval(this._interval);
  clearInterval(this._inQto);

  this._suspend();

  var u = ('_connected,_keys,_ID,_xmllang,_inQ,_pQueue,_regIDs,_errcnt,_inactivity,domain,username,resource,jid,fulljid,_sid,_httpbase,_timerval,_is_polling').split(',');
  u = u.concat(this._getSuspendVars());
  var s = {};

  for (var i=0; i<u.length; i++) {
    if (!this[u[i]]) continue; // hu? skip these!
    var o = {};
    if (this[u[i]]._getSuspendVars) {
      var uo = this[u[i]]._getSuspendVars();
      for (var j=0; j<uo.length; j++)
        o[uo[j]] = this[u[i]][uo[j]];
    } else
      o = this[u[i]];

    s[u[i]] = o;
  }
  this._connected = false;
  this._setStatus('suspending');
  return s;
};

/**
 * @private
 */
JSJaCConnection.prototype._abort = function() {
  clearTimeout(this._timeout); // remove timer

  clearInterval(this._inQto);
  clearInterval(this._interval);

  this._connected = false;

  this._setStatus('aborted');

  this.oDbg.log("Disconnected.",1);
  this._handleEvent('ondisconnect');
  this._handleEvent('onerror',
                    JSJaCError('500','cancel','service-unavailable'));
};

/**
 * @private
 */
JSJaCConnection.prototype._checkInQ = function() {
  for (var i=0; i<this._inQ.length && i<10; i++) {
    var item = this._inQ[0];
    this._inQ = this._inQ.slice(1,this._inQ.length);
    var packet = JSJaCPacket.wrapNode(item);

    if (!packet)
      return;

    this._handleEvent("packet_in", packet);

    if (packet.pType && !this._handlePID(packet)) {
      this._handleEvent(packet.pType()+'_in',packet);
      this._handleEvent(packet.pType(),packet);
    }
  }
};

/**
 * @private
 */
JSJaCConnection.prototype._checkQueue = function() {
  if (this._pQueue.length > 0)
    this._process();
  return true;
};

/**
 * @private
 */
JSJaCConnection.prototype._doAuth = function() {
  if (this.has_sasl && this.authtype == 'nonsasl')
    this.oDbg.log("Warning: SASL present but not used", 1);

  if (!this._doSASLAuth() &&
      !this._doLegacyAuth()) {
    this.oDbg.log("Auth failed for authtype "+this.authtype,1);
    this.disconnect();
    return false;
  }
  return true;
};

/**
 * @private
 */
JSJaCConnection.prototype._doInBandReg = function() {
  if (this.authtype == 'saslanon' || this.authtype == 'anonymous')
    return; // bullshit - no need to register if anonymous

  /* ***
   * In-Band Registration see JEP-0077
   */

  var iq = new JSJaCIQ();
  iq.setType('set');
  iq.setID('reg1');
  iq.appendNode("query", {xmlns: NS_REGISTER},
                [["username", this.username],
                 ["password", this.pass]]);

  this.send(iq,this._doInBandRegDone);
};

/**
 * @private
 */
JSJaCConnection.prototype._doInBandRegDone = function(iq) {
  if (iq && iq.getType() == 'error') { // we failed to register
    this.oDbg.log("registration failed for "+this.username,0);
    this._handleEvent('onerror',iq.getChild('error'));
    return;
  }

  this.oDbg.log(this.username + " registered succesfully",0);

  this._doAuth();
};

/**
 * @private
 */
JSJaCConnection.prototype._doLegacyAuth = function() {
  if (this.authtype != 'nonsasl' && this.authtype != 'anonymous')
    return false;

  /* ***
   * Non-SASL Authentication as described in JEP-0078
   */
  var iq = new JSJaCIQ();
  iq.setIQ(null,'get','auth1');
  iq.appendNode('query', {xmlns: NS_AUTH},
                [['username', this.username]]);

  this.send(iq,this._doLegacyAuth2);
  return true;
};

/**
 * @private
 */
JSJaCConnection.prototype._doLegacyAuth2 = function(resIq) {
  if (!resIq || resIq.getType() != 'result') {
    if (resIq && resIq.getType() == 'error')
      this._handleEvent('onerror',resIq.getChild('error'));
    this.disconnect();
    return;
  }

  var use_digest = (resIq.getChild('digest') !== null);

  /* ***
   * Send authentication
   */
  var iq = new JSJaCIQ();
  iq.setIQ(null,'set','auth2');

  var query = iq.appendNode('query', {xmlns: NS_AUTH},
                            [['username', this.username],
                             ['resource', this.resource]]);

  if (use_digest) { // digest login
    query.appendChild(iq.buildNode('digest', {xmlns: NS_AUTH},
                                   hex_sha1(this.streamid + this.pass)));
  } else if (this._allow_plain) { // use plaintext auth
    query.appendChild(iq.buildNode('password', {xmlns: NS_AUTH},
                                    this.pass));
  } else {
    this.oDbg.log("no valid login mechanism found",1);
    this.disconnect();
    return;
  }

  this.send(iq,this._doLegacyAuthDone);
};

/**
 * @private
 */
JSJaCConnection.prototype._doLegacyAuthDone = function(iq) {
  if (iq.getType() != 'result') { // auth' failed
    if (iq.getType() == 'error')
      this._handleEvent('onerror',iq.getChild('error'));
    this.disconnect();
  } else
    this._handleEvent('onconnect');
};

/**
 * @private
 */
JSJaCConnection.prototype._doSASLAuth = function() {
  if (this.authtype == 'nonsasl' || this.authtype == 'anonymous')
    return false;

  if (this.authtype == 'saslanon') {
    if (this.mechs['ANONYMOUS']) {
      this.oDbg.log("SASL using mechanism 'ANONYMOUS'",2);
      return this._sendRaw("<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='ANONYMOUS'/>",
                           this._doSASLAuthDone);
    }
    this.oDbg.log("SASL ANONYMOUS requested but not supported",1);

  } else if (this.authtype == 'x-facebook-platform') {
      if (this.mechs['X-FACEBOOK-PLATFORM']) {
          return this._sendRaw(
              "<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='X-FACEBOOK-PLATFORM' />",
              this._doFacebookAuth);
      }
      this.oDbg.log("X-FACEBOOK-PLATFORM requested but not supported",1);

  } else {
    if (this.mechs['DIGEST-MD5']) {
      this.oDbg.log("SASL using mechanism 'DIGEST-MD5'",2);
      return this._sendRaw("<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='DIGEST-MD5'/>",
                           this._doSASLAuthDigestMd5S1);
    } else if (this._allow_plain && this.mechs['PLAIN']) {
      this.oDbg.log("SASL using mechanism 'PLAIN'",2);
      var authStr = this.username+'@'+
      this.domain+String.fromCharCode(0)+
      this.username+String.fromCharCode(0)+
      this.pass;
      this.oDbg.log("authenticating with '"+authStr+"'",2);
      authStr = b64encode(authStr);
      return this._sendRaw("<auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl' mechanism='PLAIN'>"+authStr+"</auth>",
                           this._doSASLAuthDone);
    }
    this.oDbg.log("No SASL mechanism applied",1);
    this.authtype = 'nonsasl'; // fallback
  }
  return false;
};

/**
 * @private
 */
JSJaCConnection.prototype._doSASLAuthDigestMd5S1 = function(el) {
  if (el.nodeName != "challenge") {
    this.oDbg.log("challenge missing",1);
    this._handleEvent('onerror',JSJaCError('401','auth','not-authorized'));
    this.disconnect();
  } else {
    var challenge = b64decode(el.firstChild.nodeValue);
    this.oDbg.log("got challenge: "+challenge,2);
    this._nonce = challenge.substring(challenge.indexOf("nonce=")+7);
    this._nonce = this._nonce.substring(0,this._nonce.indexOf("\""));
    this.oDbg.log("nonce: "+this._nonce,2);
    if (this._nonce === '' || this._nonce.indexOf('\"') != -1) {
      this.oDbg.log("nonce not valid, aborting",1);
      this.disconnect();
      return;
    }

    this._digest_uri = "xmpp/";
    //     if (typeof(this.host) != 'undefined' && this.host != '') {
    //       this._digest-uri += this.host;
    //       if (typeof(this.port) != 'undefined' && this.port)
    //         this._digest-uri += ":" + this.port;
    //       this._digest-uri += '/';
    //     }
    this._digest_uri += this.domain;

    this._cnonce = cnonce(14);

    this._nc = '00000001';

    var A1 = str_md5(this.username+':'+this.domain+':'+this.pass)+
    ':'+this._nonce+':'+this._cnonce;

    var A2 = 'AUTHENTICATE:'+this._digest_uri;

    var response = hex_md5(hex_md5(A1)+':'+this._nonce+':'+this._nc+':'+
                           this._cnonce+':auth:'+hex_md5(A2));

    var rPlain = 'username="'+this.username+'",realm="'+this.domain+
    '",nonce="'+this._nonce+'",cnonce="'+this._cnonce+'",nc="'+this._nc+
    '",qop=auth,digest-uri="'+this._digest_uri+'",response="'+response+
    '",charset="utf-8"';

    this.oDbg.log("response: "+rPlain,2);

    this._sendRaw("<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>"+
                  binb2b64(str2binb(rPlain))+"</response>",
                  this._doSASLAuthDigestMd5S2);
  }
};

/**
 * @private
 */
JSJaCConnection.prototype._doSASLAuthDigestMd5S2 = function(el) {
  if (el.nodeName == 'failure') {
    if (el.xml)
      this.oDbg.log("auth error: "+el.xml,1);
    else
      this.oDbg.log("auth error",1);
    this._handleEvent('onerror',JSJaCError('401','auth','not-authorized'));
    this.disconnect();
    return;
  }

  var response = b64decode(el.firstChild.nodeValue);
  this.oDbg.log("response: "+response,2);

  var rspauth = response.substring(response.indexOf("rspauth=")+8);
  this.oDbg.log("rspauth: "+rspauth,2);

  var A1 = str_md5(this.username+':'+this.domain+':'+this.pass)+
  ':'+this._nonce+':'+this._cnonce;

  var A2 = ':'+this._digest_uri;

  var rsptest = hex_md5(hex_md5(A1)+':'+this._nonce+':'+this._nc+':'+
                        this._cnonce+':auth:'+hex_md5(A2));
  this.oDbg.log("rsptest: "+rsptest,2);

  if (rsptest != rspauth) {
    this.oDbg.log("SASL Digest-MD5: server repsonse with wrong rspauth",1);
    this.disconnect();
    return;
  }

    if (el.nodeName == 'success') {
        this._reInitStream(JSJaC.bind(this._doStreamBind, this));
    } else { // some extra turn
        this._sendRaw("<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>",
                      this._doSASLAuthDone);
    }
};

/**
 * @private
 */
JSJaCConnection.prototype._doSASLAuthDone = function (el) {
    if (el.nodeName != 'success') {
        this.oDbg.log("auth failed",1);
        this._handleEvent('onerror',JSJaCError('401','auth','not-authorized'));
        this.disconnect();
    } else {
        this._reInitStream(JSJaC.bind(this._doStreamBind, this));
    }
};

/**
 * @private
 */
JSJaCConnection.prototype._doFacebookAuth = function(el) {

  if (el.nodeName != "challenge") {
    this.oDbg.log("challenge missing",1);
    this._handleEvent('onerror',JSJaCError('401','auth','not-authorized'));
    this.disconnect();
  } else {
    var challenge = b64decode(el.firstChild.nodeValue);
    this.oDbg.log("got challenge: "+challenge,2);

	//Let's split all the variables taked back from server side
	var parts = challenge.split('&');
	var vars = Array();
	for (var i=0;i<parts.length;i++){
		var tmp = parts[i].split('=');
		vars[tmp[0]] = tmp[1];
	}

      if(vars['nonce'] != ''){

          var fbSession = this._facebookApp.getSession();

          var response = {
              'api_key'     : this._facebookApp.getApiKey(),
              'call_id'     : new Date().getTime(),
              'method'      : vars['method'],
              'nonce'       : vars['nonce'],
              'session_key' : fbSession['session_key'],
              'v'           : '1.0'
          };

          response['sig'] = 'api_key=' + response['api_key'] +
              'call_id=' + response['call_id'] +
              'method=' + response['method'] +
              'nonce=' + response['nonce'] +
              'session_key=' + response['session_key'] +
              'v=' + response['v'];

          response['sig'] = hex_md5(response['sig'] + this._facebookApp.getApiSecret());

          response = 'api_key=' + response['api_key'] + '&' +
              'call_id=' + response['call_id'] + '&' +
              'method=' + response['method'] + '&' +
              'nonce=' + response['nonce'] + '&' +
              'session_key=' + response['session_key'] + '&' +
              'v=' + response['v'] + '&' +
              'sig=' + response['sig'];

          response = b64encode(response);

          return this._sendRaw("<response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>" + response + "</response>",
                               this._doFacebookAuthDone);


      }else{

          this.oDbg.log("nonce missing",1);
          this._handleEvent('onerror',JSJaCError('401','auth','not-authorized'));
          this.disconnect();

      }

  }

};

/**
 * @private
 */
JSJaCConnection.prototype._doFacebookAuthDone = function(el) {

	if (el.nodeName != 'success') {
		this.oDbg.log("auth failed",1);
		this._handleEvent('onerror',JSJaCError('401','auth','not-authorized'));
		this.disconnect();
	}else {
        this._reInitStream(JSJaC.bind(this._doStreamBind, this));
	}
};

/**
 * @private
 */
JSJaCConnection.prototype._doStreamBind = function() {
  var iq = new JSJaCIQ();
  iq.setIQ(null,'set','bind_1');
  iq.appendNode("bind", {xmlns: NS_BIND}, [["resource", this.resource]]);
  this.oDbg.log(iq.xml());
  this.send(iq,this._doXMPPSess);
};

/**
 * @private
 */
JSJaCConnection.prototype._doXMPPSess = function(iq) {
  if (iq.getType() != 'result' || iq.getType() == 'error') { // failed
    this.disconnect();
    if (iq.getType() == 'error')
      this._handleEvent('onerror',iq.getChild('error'));
    return;
  }

  this.fulljid = iq.getChildVal("jid");
  this.jid = this.fulljid.substring(0,this.fulljid.lastIndexOf('/'));

  iq = new JSJaCIQ();
  iq.setIQ(null,'set','sess_1');
  iq.appendNode("session", {xmlns: NS_SESSION}, []);
  this.oDbg.log(iq.xml());
  this.send(iq,this._doXMPPSessDone);
};

/**
 * @private
 */
JSJaCConnection.prototype._doXMPPSessDone = function(iq) {
  if (iq.getType() != 'result' || iq.getType() == 'error') { // failed
    this.disconnect();
    if (iq.getType() == 'error')
      this._handleEvent('onerror',iq.getChild('error'));
    return;
  } else
    this._handleEvent('onconnect');
};

/**
 * @private
 */
JSJaCConnection.prototype._handleEvent = function(event,arg) {
  event = event.toLowerCase(); // don't be case-sensitive here
  this.oDbg.log("incoming event '"+event+"'",3);
  if (!this._events[event])
    return;
  this.oDbg.log("handling event '"+event+"'",2);
  for (var i=0;i<this._events[event].length; i++) {
    var aEvent = this._events[event][i];
    if (typeof aEvent.handler == 'function') {
      if (arg) {
        if (arg.pType) { // it's a packet
          if ((!arg.getNode().hasChildNodes() && aEvent.childName != '*') ||
              (arg.getNode().hasChildNodes() &&
               !arg.getChild(aEvent.childName, aEvent.childNS)))
            continue;
          if (aEvent.type != '*' &&
              arg.getType() != aEvent.type)
            continue;
          this.oDbg.log(aEvent.childName+"/"+aEvent.childNS+"/"+aEvent.type+" => match for handler "+aEvent.handler,3);
        }
        if (aEvent.handler(arg)) {
          // handled!
          break;
        }
      } else if (aEvent.handler()) {
        // handled!
        break;
      }
    }
  }
};

/**
 * @private
 */
JSJaCConnection.prototype._handlePID = function(aJSJaCPacket) {
  if (!aJSJaCPacket.getID())
    return false;
  for (var i in this._regIDs) {
    if (this._regIDs.hasOwnProperty(i) &&
        this._regIDs[i] && i == aJSJaCPacket.getID()) {
      var pID = aJSJaCPacket.getID();
      this.oDbg.log("handling "+pID,3);
      if (this._regIDs[i].cb.call(this, aJSJaCPacket, this._regIDs[i].arg) === false) {
        // don't unregister
        return false;
      } else {
        this._unregisterPID(pID);
        return true;
      }
    }
  }
  return false;
};

/**
 * @private
 */
JSJaCConnection.prototype._handleResponse = function(req) {
  var rootEl = this._parseResponse(req);

  if (!rootEl)
    return;

  for (var i=0; i<rootEl.childNodes.length; i++) {
    if (this._sendRawCallbacks.length) {
      var cb = this._sendRawCallbacks[0];
      this._sendRawCallbacks = this._sendRawCallbacks.slice(1, this._sendRawCallbacks.length);
      cb.fn.call(this, rootEl.childNodes.item(i), cb.arg);
      continue;
    }
    this._inQ = this._inQ.concat(rootEl.childNodes.item(i));
  }
};

/**
 * @private
 */
JSJaCConnection.prototype._parseStreamFeatures = function(doc) {
    if (!doc) {
        this.oDbg.log("nothing to parse ... aborting",1);
        return false;
    }

    var errorTag;
    if (doc.getElementsByTagNameNS) {
        errorTag = doc.getElementsByTagNameNS(NS_STREAM, "error").item(0);
    } else {
        var errors = doc.getElementsByTagName("error");
        for (var i=0; i<errors.length; i++)
            if (errors.item(i).namespaceURI == NS_STREAM ||
                errors.item(i).getAttribute('xmlns') == NS_STREAM) {
                errorTag = errors.item(i);
                break;
            }
    }

    if (errorTag) {
        this._setStatus("internal_server_error");
        clearTimeout(this._timeout); // remove timer
        clearInterval(this._interval);
        clearInterval(this._inQto);
        this._handleEvent('onerror',JSJaCError('503','cancel','session-terminate'));
        this._connected = false;
        this.oDbg.log("Disconnected.",1);
        this._handleEvent('ondisconnect');
        return false;
    }

    this.mechs = {};
    var lMec1 = doc.getElementsByTagName("mechanisms");
    if (!lMec1.length) return false;
    this.has_sasl = false;
    for (var i=0; i<lMec1.length; i++)
        if (lMec1.item(i).getAttribute("xmlns") == NS_SASL) {
            this.has_sasl=true;
            var lMec2 = lMec1.item(i).getElementsByTagName("mechanism");
            for (var j=0; j<lMec2.length; j++)
                this.mechs[lMec2.item(j).firstChild.nodeValue] = true;
            break;
        }
    if (this.has_sasl)
        this.oDbg.log("SASL detected",2);
    else {
        this.oDbg.log("No support for SASL detected",2);
        return true;
    }

    /* [TODO]
     * check if in-band registration available
     * check for session and bind features
     */

    return true;
};

/**
 * @private
 */
JSJaCConnection.prototype._process = function(timerval) {
  if (!this.connected()) {
    this.oDbg.log("Connection lost ...",1);
    if (this._interval)
      clearInterval(this._interval);
    return;
  }

  this.setPollInterval(timerval);

  if (this._timeout)
    clearTimeout(this._timeout);

  var slot = this._getFreeSlot();

  if (slot < 0)
    return;

  if (typeof(this._req[slot]) != 'undefined' &&
      typeof(this._req[slot].r) != 'undefined' &&
      this._req[slot].r.readyState != 4) {
    this.oDbg.log("Slot "+slot+" is not ready");
    return;
  }

  if (!this.isPolling() && this._pQueue.length === 0 &&
      this._req[(slot+1)%2] && this._req[(slot+1)%2].r.readyState != 4) {
    this.oDbg.log("all slots busy, standby ...", 2);
    return;
  }

  if (!this.isPolling())
    this.oDbg.log("Found working slot at "+slot,2);

  this._req[slot] = this._setupRequest(true);

  /* setup onload handler for async send */
  this._req[slot].r.onreadystatechange =
  JSJaC.bind(function() {
               if (!this.connected())
                 return;
               if (this._req[slot].r.readyState == 4) {
                 this.oDbg.log("async recv: "+this._req[slot].r.responseText,4);
                 this._handleResponse(this._req[slot]);
                 // schedule next tick
                 this._setStatus('processing');
                 if (this._pQueue.length) {
                   this._timeout = setTimeout(JSJaC.bind(this._process, this),
                                              100);
                 } else {
                   this.oDbg.log("scheduling next poll in "+
                                 this.getPollInterval()+
                                 " msec", 4);
                   this._timeout = setTimeout(JSJaC.bind(this._process, this),
                                              this.getPollInterval());
                 }
               }
             }, this);

  try {
    this._req[slot].r.onerror =
      JSJaC.bind(function() {
                   if (!this.connected())
                     return;
                   this._errcnt++;
                   this.oDbg.log('XmlHttpRequest error ('+this._errcnt+')',1);
                   if (this._errcnt > JSJAC_ERR_COUNT) {
                     // abort
                     this._abort();
                     return;
                   }

                   this._setStatus('onerror_fallback');

                   // schedule next tick
                   setTimeout(JSJaC.bind(this._repeat, this), JSJAC_RETRYDELAY);
                   return;
                 }, this);
  } catch(e) {
      // well ... no onerror property available, maybe we
      // can catch the error somewhere else ...
  }

  var reqstr = this._getRequestString();

  if (typeof(this._rid) != 'undefined') // remember request id if any
    this._req[slot].rid = this._rid;

  this.oDbg.log("sending: " + reqstr,4);
  this._req[slot].r.send(reqstr);
};

/**
 * @private
 */
JSJaCConnection.prototype._registerPID = function(pID,cb,arg) {
  if (!pID || !cb)
    return false;
  this._regIDs[pID] = {};
  this._regIDs[pID].cb = cb;
  if (arg)
    this._regIDs[pID].arg = arg;
  this.oDbg.log("registered "+pID,3);
  return true;
};

/**
 * partial function binding sendEmpty to callback
 * @private
 */
JSJaCConnection.prototype._prepSendEmpty = function(cb, ctx) {
    return function() {
        ctx._sendEmpty(JSJaC.bind(cb, ctx));
    };
};

/**
 * send empty request
 * waiting for stream id to be able to proceed with authentication
 * @private
 */
JSJaCConnection.prototype._sendEmpty = function(cb) {
  var slot = this._getFreeSlot();
  this._req[slot] = this._setupRequest(true);

  this._req[slot].r.onreadystatechange =
  JSJaC.bind(function() {
               if (this._req[slot].r.readyState == 4) {
                 this.oDbg.log("async recv: "+this._req[slot].r.responseText,4);
                   cb(this._req[slot].r); // handle response
               }
             },this);

  if (typeof(this._req[slot].r.onerror) != 'undefined') {
    this._req[slot].r.onerror =
      JSJaC.bind(function(e) {
                   this.oDbg.log('XmlHttpRequest error',1);
                 }, this);
  }

  var reqstr = this._getRequestString();
  this.oDbg.log("sending: " + reqstr,4);
  this._req[slot].r.send(reqstr);
};

/**
 * @private
 */
JSJaCConnection.prototype._sendRaw = function(xml,cb,arg) {
  if (cb)
    this._sendRawCallbacks.push({fn: cb, arg: arg});

  this._pQueue.push(xml);
  this._process();

  return true;
};

/**
 * @private
 */
JSJaCConnection.prototype._setStatus = function(status) {
  if (!status || status === '')
    return;
  if (status != this._status) { // status changed!
    this._status = status;
    this._handleEvent('onstatuschanged', status);
    this._handleEvent('status_changed', status);
  }
};

/**
 * @private
 */
JSJaCConnection.prototype._unregisterPID = function(pID) {
  if (!this._regIDs[pID])
    return false;
  this._regIDs[pID] = null;
  this.oDbg.log("unregistered "+pID,3);
  return true;
};
/**
 * @fileoverview All stuff related to HTTP Binding
 * @author Stefan Strigler steve@zeank.in-berlin.de
 */

/**
 * Instantiates a BOSH session connection.
 * @class Implementation of {@link http://xmpp.org/extensions/xep-0206.html | XMPP Over BOSH}
 * formerly known as HTTP Binding.
 * @constructor
 * @extends {JSJaCConnection}
 * @param {Object} oArg Configurational object for this connection.
 * @param {string} oArg.httpbase The connection endpoint of the HTTP service to talk to.
 * @param {JSJaCDebugger} [oArg.oDbg] A reference to a debugger implementing the JSJaCDebugger interface.
 * @param {int} [oArg.timerval] The polling interval.
 * @param {string} [oArg.cookie_prefix] Prefix to cookie names used when suspending.
 * @param {int} [oArg.wait] The 'wait' attribute of BOSH connections.
 */
function JSJaCHttpBindingConnection(oArg) {
  /**
   * @ignore
   */
  this.base = JSJaCConnection;
  this.base(oArg);

  // member vars
  /**
   * @private
   */
  this._hold = JSJACHBC_MAX_HOLD;
  /**
   * @private
   */
  this._inactivity = 0;
  /**
   * @private
   */
  this._last_requests = {}; // 'hash' storing hold+1 last requests
  /**
   * @private
   */
  this._last_rid = 0;                 // I know what you did last summer
  /**
   * @private
   */
  this._min_polling = 0;
  /**
   * @private
   */
  this._pause = 0;
  /**
   * @private
   */
  this._wait = oArg.wait || JSJACHBC_MAX_WAIT;
}
JSJaCHttpBindingConnection.prototype = new JSJaCConnection();

/**
 * Inherit an instantiated HTTP Binding session
 * @param {Object} oArg The configuration to be used for connecting.
 * @param {string} oArg.jid The full jid of the entity this session is connected with. Either provide this or 'domain', 'username' and 'resource'.
 * @param {string} oArg.domain The domain name of the XMPP service.
 * @param {string} oArg.username The username (nodename) to be logged in with.
 * @param {string} oArg.resource The resource to identify the login with.
 * @param {string} oArg.sid The BOSH session id.
 * @param {int} oArg.rid The BOSH request id.
 * @param {int} oArg.polling The BOSH polling attribute.
 * @param {int} oArg.inactivity The BOSH inactivity attribute.
 * @param {int} oArg.requests The BOSH requests attribute.
 * @param {int} [oArg.wait] The BOSH wait attribute.
 */
JSJaCHttpBindingConnection.prototype.inherit = function(oArg) {
  if (oArg.jid) {
    var oJid = new JSJaCJID(oArg.jid);
    this.domain = oJid.getDomain();
    this.username = oJid.getNode();
    this.resource = oJid.getResource();
  } else {
    this.domain = oArg.domain || 'localhost';
    this.username = oArg.username;
    this.resource = oArg.resource;
  }
  this._sid = oArg.sid;
  this._rid = oArg.rid;
  this._min_polling = oArg.polling;
  this._inactivity = oArg.inactivity;
  this._setHold(oArg.requests-1);
  this.setPollInterval(this._timerval);

  if (oArg.wait)
    this._wait = oArg.wait;

  this._connected = true;

  this._handleEvent('onconnect');

  this._interval= setInterval(JSJaC.bind(this._checkQueue, this),
                              JSJAC_CHECKQUEUEINTERVAL);
  this._inQto = setInterval(JSJaC.bind(this._checkInQ, this),
                            JSJAC_CHECKINQUEUEINTERVAL);
  this._timeout = setTimeout(JSJaC.bind(this._process, this),
                             this.getPollInterval());
};

/**
 * Sets poll interval
 * @param {int} timerval the interval in seconds
 */
JSJaCHttpBindingConnection.prototype.setPollInterval = function(timerval) {
  if (timerval && !isNaN(timerval)) {
    if (!this.isPolling())
      this._timerval = 100;
    else if (this._min_polling && timerval < this._min_polling*1000)
      this._timerval = this._min_polling*1000;
    else if (this._inactivity && timerval > this._inactivity*1000)
      this._timerval = this._inactivity*1000;
    else
      this._timerval = timerval;
  }
  return this._timerval;
};

/**
 * whether this session is in polling mode
 * @type boolean
 */
JSJaCHttpBindingConnection.prototype.isPolling = function() { return (this._hold === 0); };

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getFreeSlot = function() {
  for (var i=0; i<this._hold+1; i++)
    if (typeof(this._req[i]) == 'undefined' || typeof(this._req[i].r) == 'undefined' || this._req[i].r.readyState == 4)
      return i;
  return -1; // nothing found
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getHold = function() { return this._hold; };

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getRequestString = function(raw, last) {
  raw = raw || '';
  var reqstr = '';

  // check if we're repeating a request

  if (this._rid <= this._last_rid && typeof(this._last_requests[this._rid]) != 'undefined') // repeat!
    reqstr = this._last_requests[this._rid].xml;
  else { // grab from queue
    var xml = '';
    while (this._pQueue.length) {
      var curNode = this._pQueue[0];
      xml += curNode;
      this._pQueue = this._pQueue.slice(1,this._pQueue.length);
    }

    reqstr = "<body rid='"+this._rid+"' sid='"+this._sid+"' xmlns='http://jabber.org/protocol/httpbind' ";
    if (JSJAC_HAVEKEYS) {
      reqstr += "key='"+this._keys.getKey()+"' ";
      if (this._keys.lastKey()) {
        this._keys = new JSJaCKeys(hex_sha1,this.oDbg);
        reqstr += "newkey='"+this._keys.getKey()+"' ";
      }
    }
    if (last)
      reqstr += "type='terminate'";
    else if (this._reinit) {
      if (JSJACHBC_USE_BOSH_VER)
        reqstr += "xml:lang='"+this._xmllang+"' xmpp:restart='true' xmlns:xmpp='urn:xmpp:xbosh' to='"+this.domain+"'";
      this._reinit = false;
    }

    if (xml != '' || raw != '') {
      reqstr += ">" + raw + xml + "</body>";
    } else {
      reqstr += "> </body>";
    }

    this._last_requests[this._rid] = {};
    this._last_requests[this._rid].xml = reqstr;
    this._last_rid = this._rid;

    for (var i in this._last_requests)
      if (this._last_requests.hasOwnProperty(i) &&
          i < this._rid-this._hold)
        delete(this._last_requests[i]); // truncate
  }

  return reqstr;
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getInitialRequestString = function() {
  var reqstr = "<body content='text/xml; charset=utf-8' hold='"+this._hold+"' xmlns='http://jabber.org/protocol/httpbind' to='"+this.authhost+"' wait='"+this._wait+"' rid='"+this._rid+"'";
  if (this.host && this.port)
    reqstr += " route='xmpp:"+this.host+":"+this.port+"'";
  if (this.secure)
    reqstr += " secure='"+this.secure+"'";
  if (JSJAC_HAVEKEYS) {
    this._keys = new JSJaCKeys(hex_sha1,this.oDbg); // generate first set of keys
    var key = this._keys.getKey();
    reqstr += " newkey='"+key+"'";
  }
  reqstr += " xml:lang='"+this._xmllang + "'";

  if (JSJACHBC_USE_BOSH_VER) {
    reqstr += " ver='" + JSJACHBC_BOSH_VERSION + "'";
    reqstr += " xmlns:xmpp='urn:xmpp:xbosh'";
    if (this.authtype == 'sasl' || this.authtype == 'saslanon' || this.authtype == 'x-facebook-platform')
      reqstr += " xmpp:version='1.0'";
  }
  reqstr += "/>";
  return reqstr;
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getStreamID = function(req) {

  this.oDbg.log(req.responseText,4);

  if (!req.responseXML || !req.responseXML.documentElement) {
    this._handleEvent('onerror',JSJaCError('503','cancel','service-unavailable'));
    return;
  }
  var body = req.responseXML.documentElement;

  // any session error?
  if(body.getAttribute('type') == 'terminate') {
    this._handleEvent('onerror',JSJaCError('503','cancel','service-unavailable'));
    return;
  }

  // extract stream id used for non-SASL authentication
  if (body.getAttribute('authid')) {
    this.streamid = body.getAttribute('authid');
    this.oDbg.log("got streamid: "+this.streamid,2);
  }

  if (!this._parseStreamFeatures(body)) {
      this._sendEmpty(JSJaC.bind(this._getStreamID, this));
      return;
  }

  this._timeout = setTimeout(JSJaC.bind(this._process, this),
                             this.getPollInterval());

  if (this.register)
    this._doInBandReg();
  else
    this._doAuth();
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._getSuspendVars = function() {
  return ('host,port,secure,_rid,_last_rid,_wait,_min_polling,_inactivity,_hold,_last_requests,_pause').split(',');
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._handleInitialResponse = function(req) {
  try {
    // This will throw an error on Mozilla when the connection was refused
    this.oDbg.log(req.getAllResponseHeaders(),4);
    this.oDbg.log(req.responseText,4);
  } catch(ex) {
    this.oDbg.log("No response",4);
  }

  if (req.status != 200 || !req.responseXML) {
    this.oDbg.log("initial response broken (status: "+req.status+")",1);
    this._handleEvent('onerror',JSJaCError('503','cancel','service-unavailable'));
    return;
  }
  var body = req.responseXML.documentElement;

  if (!body || body.tagName != 'body' || body.namespaceURI != NS_BOSH) {
    this.oDbg.log("no body element or incorrect body in initial response",1);
    this._handleEvent("onerror",JSJaCError("500","wait","internal-service-error"));
    return;
  }

  // Check for errors from the server
  if (body.getAttribute("type") == "terminate") {
    this.oDbg.log("invalid response:\n" + req.responseText,1);
    clearTimeout(this._timeout); // remove timer
    this._connected = false;
    this.oDbg.log("Disconnected.",1);
    this._handleEvent('ondisconnect');
    this._handleEvent('onerror',JSJaCError('503','cancel','service-unavailable'));
    return;
  }

  // get session ID
  this._sid = body.getAttribute('sid');
  this.oDbg.log("got sid: "+this._sid,2);

  // get attributes from response body
  if (body.getAttribute('polling'))
    this._min_polling = body.getAttribute('polling');

  if (body.getAttribute('inactivity'))
    this._inactivity = body.getAttribute('inactivity');

  if (body.getAttribute('requests'))
    this._setHold(body.getAttribute('requests')-1);
  this.oDbg.log("set hold to " + this._getHold(),2);

  if (body.getAttribute('ver'))
    this._bosh_version = body.getAttribute('ver');

  if (body.getAttribute('maxpause'))
    this._pause = Number.min(body.getAttribute('maxpause'), JSJACHBC_MAXPAUSE);

  // must be done after response attributes have been collected
  this.setPollInterval(this._timerval);

  /* start sending from queue for not polling connections */
  this._connected = true;

  this._inQto = setInterval(JSJaC.bind(this._checkInQ, this),
                            JSJAC_CHECKINQUEUEINTERVAL);
  this._interval= setInterval(JSJaC.bind(this._checkQueue, this),
                              JSJAC_CHECKQUEUEINTERVAL);

  /* wait for initial stream response to extract streamid needed
   * for digest auth
   */
  this._getStreamID(req);
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._parseResponse = function(req) {
    if (!this.connected() || !req)
        return null;

    var r = req.r; // the XmlHttpRequest

    try {
        if (r.status == 404 || r.status == 403) {
            // connection manager killed session
            this._abort();
            return null;
        }

        if (r.status != 200 || !r.responseXML) {
            this._errcnt++;
            var errmsg = "invalid response ("+r.status+"):\n" + r.getAllResponseHeaders()+"\n"+r.responseText;
            if (!r.responseXML)
                errmsg += "\nResponse failed to parse!";
            this.oDbg.log(errmsg,1);
            if (this._errcnt > JSJAC_ERR_COUNT) {
                // abort
                this._abort();
                return null;
            }

            if (this.connected()) {
                this.oDbg.log("repeating ("+this._errcnt+")",1);
                this._setStatus('proto_error_fallback');

                // schedule next tick
                setTimeout(JSJaC.bind(this._repeat, this),
                           this.getPollInterval());
            }

            return null;
        }
    } catch (e) {
        this.oDbg.log("XMLHttpRequest error: status not available", 1);
        this._errcnt++;
        if (this._errcnt > JSJAC_ERR_COUNT) {
            // abort
            this._abort();
        } else {
            if (this.connected()) {
                this.oDbg.log("repeating ("+this._errcnt+")",1);
                this._setStatus('proto_error_fallback');
                // schedule next tick
                setTimeout(JSJaC.bind(this._repeat, this),
                           this.getPollInterval());
            }
        }
        return null;
    }

    var body = r.responseXML.documentElement;
    if (!body || body.tagName != 'body' || body.namespaceURI != NS_BOSH) {
        this.oDbg.log("invalid response:\n" + r.responseText,1);

        clearTimeout(this._timeout); // remove timer
        clearInterval(this._interval);
        clearInterval(this._inQto);

        this._connected = false;
        this.oDbg.log("Disconnected.",1);
        this._handleEvent('ondisconnect');

        this._setStatus('internal_server_error');
        this._handleEvent('onerror',
                          JSJaCError('500','wait','internal-server-error'));

        return null;
    }

    if (typeof(req.rid) != 'undefined' && this._last_requests[req.rid]) {
        if (this._last_requests[req.rid].handled) {
            this.oDbg.log("already handled "+req.rid,2);
            return null;
        } else
            this._last_requests[req.rid].handled = true;
    }

    // Check for errors from the server
    if (body.getAttribute("type") == "terminate") {
        // read condition
        var condition = body.getAttribute('condition');

        this.oDbg.log("session terminated:\n" + r.responseText,1);

        clearTimeout(this._timeout); // remove timer
        clearInterval(this._interval);
        clearInterval(this._inQto);

        try {
            JSJaCCookie.read(this._cookie_prefix+'JSJaC_State').erase();
        } catch (e) {}

        this._connected = false;

        if (condition == "remote-stream-error") {
            if (body.getElementsByTagName("conflict").length > 0)
                this._setStatus("session-terminate-conflict");
            else
                this._setStatus('terminated');
        } else {
            this._setStatus('terminated');
        }
        if (condition === null)
            condition = 'session-terminate';
        this._handleEvent('onerror',JSJaCError('503','cancel',condition));

        this.oDbg.log("Aborting remaining connections",4);

        for (var i=0; i<this._hold+1; i++) {
            try {
                if (this._req[i] && this._req[i] != req)
                    this._req[i].r.abort();
            } catch(e) { this.oDbg.log(e, 1); }
        }

        this.oDbg.log("parseResponse done with terminating", 3);

        this.oDbg.log("Disconnected.",1);
        this._handleEvent('ondisconnect');

        return null;
    }

    // no error
    this._errcnt = 0;
    return r.responseXML.documentElement;
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._reInitStream = function(cb) {
    // tell http binding to reinit stream with/before next request
    this._reinit = true;

    this._sendEmpty(this._prepReInitStreamWait(cb));
};


JSJaCHttpBindingConnection.prototype._prepReInitStreamWait = function(cb) {
    return JSJaC.bind(function(req) {
        this._reInitStreamWait(req, cb);
    }, this);
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._reInitStreamWait = function(req, cb) {
    this.oDbg.log("checking for stream features");
    var doc = req.responseXML.documentElement, features, bind;
    this.oDbg.log(doc);
    if (doc.getElementsByTagNameNS) {
        this.oDbg.log("checking with namespace");

        features = doc.getElementsByTagNameNS(NS_STREAM, 'features').item(0);
        if (features) {
            bind = features.getElementsByTagNameNS(NS_BIND, 'bind').item(0);
        }
    } else {
        var featuresNL = doc.getElementsByTagName('stream:features'), i, l;
        for (i=0, l=featuresNL.length; i<l; i++) {
            if (featuresNL.item(i).namespaceURI == NS_STREAM ||
                featuresNL.item(i).getAttribute('xmlns') == NS_STREAM) {
                features = featuresNL.item(i);
                break;
            }
        }
        if (features) {
            bind = features.getElementsByTagName('bind');
            for (i=0, l=bind.length; i<l; i++) {
                if (bind.item(i).namespaceURI == NS_BIND ||
                    bind.item(i).getAttribute('xmlns') == NS_BIND) {
                    bind = bind.item(i);
                    break;
                }
            }
        }
    }
    this.oDbg.log(features);
    this.oDbg.log(bind);

    if (features) {
        if (bind) {
            cb();
        } else {
            this.oDbg.log("no bind feature - giving up",1);
            this._handleEvent('onerror',JSJaCError('503','cancel',
                                                   "service-unavailable"));
            this._connected = false;
            this.oDbg.log("Disconnected.",1);
            this._handleEvent('ondisconnect');
        }
    } else {
        // wait
        this._sendEmpty(this._prepReInitStreamWait(cb));
    }
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._repeat = function() {
  if (this._rid >= this._last_rid)
    this._rid = this._last_rid-1;

  this._process();
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._resume = function() {
    // make sure to repeat last request as we can be sure that it had failed
    // (only if we're not using the 'pause' attribute)
    if (this._pause === 0)
        this._repeat();
    else
        this._process();
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._setHold = function(hold)  {
  if (!hold || isNaN(hold) || hold < 0)
    hold = 0;
  else if (hold > JSJACHBC_MAX_HOLD)
    hold = JSJACHBC_MAX_HOLD;
  this._hold = hold;
  return this._hold;
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._setupRequest = function(async) {
  var req = {};
  var r = XmlHttp.create();
  try {
    r.open("POST",this._httpbase,async);
    r.setRequestHeader('Content-Type','text/xml; charset=utf-8');
  } catch(e) { this.oDbg.log(e,1); }
  req.r = r;
  this._rid++;
  req.rid = this._rid;
  return req;
};

/**
 * @private
 */
JSJaCHttpBindingConnection.prototype._suspend = function() {
  if (this._pause === 0)
    return; // got nothing to do

  var slot = this._getFreeSlot();
  // Intentionally synchronous
  this._req[slot] = this._setupRequest(false);

  var reqstr = "<body pause='"+this._pause+"' xmlns='http://jabber.org/protocol/httpbind' sid='"+this._sid+"' rid='"+this._rid+"'";
  if (JSJAC_HAVEKEYS) {
    reqstr += " key='"+this._keys.getKey()+"'";
    if (this._keys.lastKey()) {
      this._keys = new JSJaCKeys(hex_sha1,this.oDbg);
      reqstr += " newkey='"+this._keys.getKey()+"'";
    }

  }
  reqstr += ">";

  while (this._pQueue.length) {
    var curNode = this._pQueue[0];
    reqstr += curNode;
    this._pQueue = this._pQueue.slice(1,this._pQueue.length);
  }

  //reqstr += "<presence type='unavailable' xmlns='jabber:client'/>";
  reqstr += "</body>";

  this.oDbg.log("Disconnecting: " + reqstr,4);
  this._req[slot].r.send(reqstr);
};
/**
 * @author Janusz Dziemidowicz rraptorr@nails.eu.org
 * @fileoverview All stuff related to WebSocket
 * <pre>
 * The WebSocket protocol is a bit of a mess. Various, incompatible,
 * protocol drafts were implemented in browsers. Fortunately, recently
 * a finished protocol was released in RFC6455. Further description
 * assumes RFC6455 WebSocket protocol version.
 *
 * WebSocket browser support. Current (November 2012) browser status:
 * - Chrome 16+ - works properly and supports RFC6455
 * - Firefox 16+ - works properly and support RFC6455 (ealier versions
 *   have problems with proxies)
 * - Opera 12.10 - supports RFC6455, but does not work at all if a
 *   proxy is configured (earlier versions do not support RFC6455)
 * - Internet Explorer 10+ - works properly and supports RFC6455
 *
 * Due to the above status, this code is currently recommended on
 * Chrome 16+, Firefox 16+ and Internet Explorer 10+. Using it on
 * other browsers is discouraged.
 *
 * Please also note that some users are only able to connect to ports
 * 80 and 443. Port 80 is sometimes intercepted by transparent HTTP
 * proxies, which mostly does not support WebSocket, so port 443 is
 * the best choice currently (it does not have to be
 * encrypted). WebSocket also usually does not work well with reverse
 * proxies, be sure to make extensive tests if you use one.
 *
 * There is no standard for XMPP over WebSocket. However, there is a
 * draft
 * (http://tools.ietf.org/html/draft-moffitt-xmpp-over-websocket-01)
 * and this implementation follows it.
 *
 * Tested servers:
 *
 * - node-xmpp-bosh (https://github.com/dhruvbird/node-xmpp-bosh) -
 *   supports RFC6455 and works with no problems since 0.6.1, it also
 *   transparently uses STARTTLS if necessary
 * - wxg (https://github.com/Gordin/wxg) - supports RFC6455 and works
 *   with no problems, but cannot connect to servers requiring
 *   STARTTLS (original wxg at https://github.com/hocken/wxg has some
 *   issues, that were fixed by Gordin).
 * - ejabberd-websockets
 *   (https://github.com/superfeedr/ejabberd-websockets) - does not
 *   support RFC6455 hence it does not work, adapting it to support
 *   RFC6455 should be quite easy for anyone knowing Erlang (some work
 *   in progress can be found on github)
 * - Openfire (http://www.igniterealtime.org/projects/openfire/) -
 *   unofficial plugin is available, but it lacks support
 *   for RFC6455 hence it does not work
 * - Apache Vysper (http://mina.apache.org/vysper/) - does
 *   not support RFC6455 hence does not work
 * - Tigase (http://www.tigase.org/) - no known work on WebSocket
 *   support
 * - MongooseIM (https://github.com/esl/ejabberd) - a fork of ejabberd
 *   with support for XMPP over Websockets.
 * </pre>
 */

/**
 * Instantiates a WebSocket session.
 * @class Implementation of {@link http://tools.ietf.org/html/draft-moffitt-xmpp-over-websocket-01 | An XMPP Sub-protocol for WebSocket}.
 * @extends JSJaCConnection
 * @constructor
 * @param {Object} oArg connection properties.
 * @param {string} oArg.httpbase WebSocket connection endpoint (i.e. ws://localhost:5280)
 * @param {JSJaCDebugger} [oArg.oDbg] A reference to a debugger implementing the JSJaCDebugger interface.
 */
function JSJaCWebSocketConnection(oArg) {
  this.base = JSJaCConnection;
  this.base(oArg);

  this._ws = null;

  this.registerHandler('onerror', JSJaC.bind(this._cleanupWebSocket, this));
}

JSJaCWebSocketConnection.prototype = new JSJaCConnection();

JSJaCWebSocketConnection.prototype._cleanupWebSocket = function() {
  if (this._ws !== null) {
    this._ws.onclose = null;
    this._ws.onerror = null;
    this._ws.onopen = null;
    this._ws.onmessage = null;

    this._ws.close();
    this._ws = null;
  }
};

/**
 * Connect to a jabber/XMPP server.
 * @param {Object} oArg The configuration to be used for connecting.
 * @param {string} oArg.domain The domain name of the XMPP service.
 * @param {string} oArg.username The username (nodename) to be logged in with.
 * @param {string} oArg.resource The resource to identify the login with.
 * @param {string} oArg.password The user's password.
 * @param {boolean} [oArg.allow_plain] Whether to allow plain text logins.
 * @param {boolean} [oArg.register] Whether to register a new account.
 * @param {string} [oArg.authhost] The host that handles the actualy authorization. There are cases where this is different from the settings above, e.g. if there's a service that provides anonymous logins at 'anon.example.org'.
 * @param {string} [oArg.authtype] Must be one of 'sasl' (default), 'nonsasl', 'saslanon', 'anonymous', or 'x-facebook-platform'.
 * @param {string} [oArg.xmllang] The requested language for this login. Typically XMPP server try to respond with error messages and the like in this language if available.
 */
JSJaCWebSocketConnection.prototype.connect = function(oArg) {
  this._setStatus('connecting');

  this.domain = oArg.domain || 'localhost';
  this.username = oArg.username;
  this.resource = oArg.resource;
  this.pass = oArg.password || oArg.pass;
  this.register = oArg.register;

  this.authhost = oArg.authhost || this.domain;
  this.authtype = oArg.authtype || 'sasl';

  this.jid = this.username + '@' + this.domain;
  this.fulljid = this.jid + '/' + this.resource;

  if (oArg.allow_plain) {
    this._allow_plain = oArg.allow_plain;
  } else {
    this._allow_plain = JSJAC_ALLOW_PLAIN;
  }

  if (oArg.xmllang && oArg.xmllang !== '') {
    this._xmllang = oArg.xmllang;
  } else {
    this._xmllang = 'en';
  }

  if (typeof WebSocket === 'undefined') {
    this._handleEvent('onerror', JSJaCError('503', 'cancel', 'service-unavailable'));
    return;
  }

  this._ws = new WebSocket(this._httpbase, 'xmpp');
  this._ws.onclose = JSJaC.bind(this._onclose, this);
  this._ws.onerror = JSJaC.bind(this._onerror, this);
  this._ws.onopen = JSJaC.bind(this._onopen, this);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._onopen = function() {
  var reqstr = this._getInitialRequestString();

  this.oDbg.log(reqstr, 4);

  this._ws.onmessage = JSJaC.bind(this._handleOpenStream, this);
  this._ws.send(reqstr);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._handleOpenStream = function(event) {
  var open, stream;

  this.oDbg.log(event.data, 4);

  open = event.data;
  // skip XML prolog if any
  open = open.substr(open.indexOf('<stream:stream'));
  if (open.substr(-2) !== '/>' && open.substr(-16) !== '</stream:stream>') {
    // some servers send closed opening tag, some not
    open += '</stream:stream>';
  }
  stream = this._parseXml(open);
  if(!stream) {
    this._handleEvent('onerror', JSJaCError('503', 'cancel', 'service-unavailable'));
    return;
  }

  // extract stream id used for non-SASL authentication
  this.streamid = stream.getAttribute('id');

  this.oDbg.log('got streamid: ' + this.streamid, 2);
  this._ws.onmessage = JSJaC.bind(this._handleInitialResponse, this);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._handleInitialResponse = function(event) {
  var doc = this._parseXml(event.data);
  if (!this._parseStreamFeatures(doc)) {
    this._handleEvent('onerror', JSJaCError('503', 'cancel', 'service-unavailable'));
    return;
  }

  this._connected = true;

  if (this.register) {
    this._doInBandReg();
  } else {
    this._doAuth();
  }
};

/**
 * Disconnect from XMPP service
 *
 * When called upon leaving a page needs to use 'onbeforeunload' event
 * as Websocket would be closed already otherwise prior to this call.
 */
JSJaCWebSocketConnection.prototype.disconnect = function() {
  this._setStatus('disconnecting');

  if (!this.connected()) {
    return;
  }
  this._connected = false;

  this.oDbg.log('Disconnecting', 4);
  this._sendRaw('</stream:stream>', JSJaC.bind(this._cleanupWebSocket, this));

  this.oDbg.log('Disconnected', 2);
  this._handleEvent('ondisconnect');
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._onclose = function() {
  this.oDbg.log('websocket closed', 2);
  if (this._status !== 'disconnecting') {
    this._connected = false;
    this._handleEvent('onerror', JSJaCError('503', 'cancel', 'service-unavailable'));
  }
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._onerror = function() {
  this.oDbg.log('websocket error', 1);
  this._connected = false;
  this._handleEvent('onerror', JSJaCError('503', 'cancel', 'service-unavailable'));
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._onmessage = function(event) {
  var stanza, node, packet;

  stanza = event.data;
  this._setStatus('processing');
  if (!stanza || stanza === '') {
    return;
  }

  // WebSocket works only on modern browsers, so it is safe to assume
  // that namespaceURI and getElementsByTagNameNS are available.
  node = this._parseXml(stanza);
  if (node.namespaceURI === NS_STREAM && node.localName === 'error') {
    if (node.getElementsByTagNameNS(NS_STREAMS, 'conflict').length > 0) {
      this._setStatus('session-terminate-conflict');
    }
    this._connected = false;
    this._handleEvent('onerror', JSJaCError('503', 'cancel', 'remote-stream-error'));
    return;
  }

  packet = JSJaCPacket.wrapNode(node);
  if (!packet) {
    return;
  }

  this.oDbg.log('async recv: ' + event.data, 4);
  this._handleEvent('packet_in', packet);

  if (packet.pType && !this._handlePID(packet)) {
    this._handleEvent(packet.pType() + '_in', packet);
    this._handleEvent(packet.pType(), packet);
  }
};

/**
 * Parse single XML stanza. As proposed in XMPP Sub-protocol for
 * WebSocket draft, it assumes that every stanza is sent in a separate
 * WebSocket frame, which greatly simplifies parsing.
 * @private
 */
JSJaCWebSocketConnection.prototype._parseXml = function(s) {
  var doc;

  this.oDbg.log('Parsing: ' + s, 4);
  try {
    doc = XmlDocument.create('stream', NS_STREAM);
    if(s.indexOf('<stream:stream') === -1) {
      // Wrap every stanza into stream element, so that XML namespaces work properly.
      doc.loadXML("<stream:stream xmlns:stream='" + NS_STREAM + "' xmlns='jabber:client'>" + s + "</stream:stream>");
      return doc.documentElement.firstChild;
    } else {
      doc.loadXML(s);
      return doc.documentElement;
    }
  } catch (e) {
    this.oDbg.log('Error: ' + e);
    this._connected = false;
    this._handleEvent('onerror', JSJaCError('500', 'wait', 'internal-service-error'));
  }

  return null;
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._getInitialRequestString = function() {
  var streamto, reqstr;

  streamto = this.domain;
  if (this.authhost) {
    streamto = this.authhost;
  }

  reqstr = '<stream:stream to="' + streamto + '" xmlns="jabber:client" xmlns:stream="' + NS_STREAM + '"';
  if (this.authtype === 'sasl' || this.authtype === 'saslanon') {
    reqstr += ' version="1.0"';
  }
  reqstr += '>';
  return reqstr;
};

JSJaCWebSocketConnection.prototype.send = function(packet, cb, arg) {
  this._ws.onmessage = JSJaC.bind(this._onmessage, this);
  if (!packet || !packet.pType) {
    this.oDbg.log('no packet: ' + packet, 1);
    return false;
  }

  if (!this.connected()) {
    return false;
  }

  // remember id for response if callback present
  if (cb) {
    if (!packet.getID()) {
      packet.setID('JSJaCID_' + this._ID++); // generate an ID
    }

    // register callback with id
    this._registerPID(packet.getID(), cb, arg);
  }

  try {
    this._handleEvent(packet.pType() + '_out', packet);
    this._handleEvent('packet_out', packet);
    this._ws.send(packet.xml());
  } catch (e) {
    this.oDbg.log(e.toString(), 1);
    return false;
  }

  return true;
};

/**
 * Resuming connections is not supported by WebSocket.
 */
JSJaCWebSocketConnection.prototype.resume = function() {
  return false; // not supported for websockets
};

/**
 * Suspending connections is not supported by WebSocket.
 */
JSJaCWebSocketConnection.prototype.suspend = function() {
  return false; // not supported for websockets
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._doSASLAuthDigestMd5S1 = function(event) {
  var el = this._parseXml(event.data);
  return JSJaC.bind(JSJaCConnection.prototype._doSASLAuthDigestMd5S1, this)(el);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._doSASLAuthDigestMd5S2 = function(event) {
  var el = this._parseXml(event.data);
  return JSJaC.bind(JSJaCConnection.prototype._doSASLAuthDigestMd5S2, this)(el);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._doSASLAuthDone = function(event) {
  var el = this._parseXml(event.data);
  return JSJaC.bind(JSJaCConnection.prototype._doSASLAuthDone, this)(el);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._reInitStream = function(cb) {
  var reqstr, streamto = this.domain;
  if (this.authhost) {
    streamto = this.authhost;
  }

  reqstr = '<stream:stream xmlns:stream="' + NS_STREAM + '" xmlns="jabber:client" to="' + streamto + '" version="1.0">';
  this._sendRaw(reqstr, cb);
};

/**
 * @private
 */
JSJaCWebSocketConnection.prototype._sendRaw = function(xml, cb, arg) {
  if (!this._ws) {
    // Socket might have been closed already because of an 'onerror'
    // event. In this case we'd try to send a closing stream element
    // 'ondisconnect' which won't work.
    return false;
  }
  if (cb) {
    this._ws.onmessage = JSJaC.bind(cb, this, arg);
  }
  this._ws.send(xml);
  return true;
};
/**
 * @fileoverview Contains all the Facebook Application configurations.
 * @author Andrea Cammarata - acammarata@simacs.com - http://www.andreacammarata.com
 * @version 1.00
 */

/**
 * Creates a new Facebook application object to use if 
 * the JSJaCConnection authtype is set to x-facebook-platform.
 * @class Somewhat abstract base class that keeps all the Facebook auth params.
 * @constructor
 * @param {JSON http://www.json.org/index} oArg JSON with properties: <br>
 * * <code>appID</code> The Facebook Application ID
 * * <code>apiKey</code> The Facebook Application Key
 * * <code>apiKey</code> The Facebook Secret Key
 */
function JSJaCFBApplication(oArg){

	if (oArg && oArg.appID)
		this._appID = oArg.appID;

	if (oArg && oArg.apiKey)
		this._apiKey = oArg.apiKey;

	if (oArg && oArg.apiSecret)
		this._apiSecret = oArg.apiSecret;

	this._perms = '';
		
	this._session = undefined;
	
};

/**
 * @private
 */
JSJaCFBApplication.prototype.Login = function(conn, oArg) {

	var me = this;

	FB.init({ 
		appId: this._appID, 
        status: true
    });

	FB.login(function(response) {
	
		if (response.session) {
			
			if (response.perms) {

				me._perms = response.perms;
				me._session = response.session;

				conn.connect(oArg);

			}
		}
		
	 },{
		perms:'xmpp_login'
	 }
	);
	
};

/**
 * Get the Facebook Application ID.
 * @return string The Facebook Application ID.
 */
JSJaCFBApplication.prototype.getAppID = function(){ return this._appID; };

/**
 * Get the Facebook Api Key.
 * @return string The Facebook Api Key.
 */
JSJaCFBApplication.prototype.getApiKey = function(){ return this._apiKey; };

/**
 * Get the Facebook Api Secret.
 * @return string The Facebook Api Secret.
 */
JSJaCFBApplication.prototype.getApiSecret = function(){ return this._apiSecret; };

/**
 * Get the Facebook Session object.
 * @return object The Facebook Session object retrived after the user
 * has correctly login inside his Facebook account and granted 
 * the xmpp_login privileges to the Facebook Application.
 */
JSJaCFBApplication.prototype.getSession = function(){ return this._session; };/**
 * @fileoverview Magic dependency loading. Taken from script.aculo.us
 * and modified to break it.
 * @author Stefan Strigler steve@zeank.in-berlin.de
 */

var JSJaC = {
  Version: '1.4',
  require: function(libraryName) {
    // inserting via DOM fails in Safari 2.0, so brute force approach
    document.write('<script type="text/javascript" src="'+libraryName+'"></script>');
  },
  load: function() {
    var includes =
    ['xmlextras',
     'jsextras',
     'crypt',
     'JSJaCConfig',
     'JSJaCConstants',
     'JSJaCCookie',
     'JSJaCJSON',
     'JSJaCJID',
     'JSJaCBuilder',
     'JSJaCPacket',
     'JSJaCError',
     'JSJaCKeys',
     'JSJaCConnection',
     'JSJaCHttpPollingConnection',
     'JSJaCHttpBindingConnection',
     'JSJaCConsoleLogger',
     'JSJaCFBApplication',
     'JSJaCWebSocketConnection'
     ];
    var scripts = document.getElementsByTagName("script");
    var path = './', i;
    for (i=0; i<scripts.length; i++) {
      if (scripts.item(i).src && scripts.item(i).src.match(/JSJaC\.js$/)) {
        path = scripts.item(i).src.replace(/JSJaC.js$/,'');
        break;
      }
    }
    for (i=0; i<includes.length; i++)
      this.require(path+includes[i]+'.js');
  },
  bind: function(fn, obj, optArg) {
    return function(arg) {
      return fn.apply(obj, [arg, optArg]);
    };
  }
};

if (typeof JSJaCConnection == 'undefined')
  JSJaC.load();

var CrocSDK = {};

(function(CrocSDK) {

	// Private variables
	// Default Croc object configuration
	var defaultConfig = {
		acceptTimeout : 300,
		autostart: true,
		capabilities : {},
		capability : {
			refreshPeriod : 15
		},
		data : {
			idleTimeout : 300
		},
		expiresTime : 600,
		features: ['audio', 'video', 'pagedata'],
		register : false,
		requireMatchingVersion : false,
		useTLS : true,
		iceServers : [ {
			url : 'stun:stun.l.google.com:19302'
		} ]
	};

	var crocNetworkDefaultConfig = {
		sipProxySet: ['edge00.crocodilertc.net', 'edge01.crocodilertc.net'],
		xmppProxySet: ['cm.crocodilertc.net'],
		turnManagerUrl: 'https://hub.crocodilertc.net:8443/crocodile-sdk-hub/rest/1.0/ephemeral',
		msrpManagerUrl: 'https://hub.crocodilertc.net:8443/crocodile-sdk-hub/rest/1.0/ephemeral'
	};

	// Acceptable properties/types for Croc object configuration
	var configTypes = {
		acceptTimeout : [ 'number' ],
		address : [ 'string' ],
		apiKey : [ 'string' ],
		authorizationUser : [ 'string' ],
		autostart : [ 'boolean' ],
		capabilities : [ 'object' ],
		capability : [ 'object' ],
		data : [ 'object' ],
		displayName : [ 'string' ],
		expiresTime : [ 'number' ],
		features: ['string[]'],
		iceServers : [ 'object[]' ],
		jQuery : [ 'function' ],
		media : [ 'object' ],
		msrpManagerUrl : [ 'string' ],
		msrpManagerUsername : [ 'string' ],
		msrpRelaySet : [ 'string', 'string[]' ],
		onConnected : [ 'function' ],
		onDisconnected : [ 'function' ],
		onRegistered : [ 'function' ],
		onUnregistered : [ 'function' ],
		onRegistrationFailed : [ 'function' ],
		password : [ 'string' ],
		presence : [ 'object' ],
		register : [ 'boolean' ],
		requireMatchingVersion : [ 'boolean' ],
		sipProxySet : [ 'string', 'string[]' ],
		turnManagerUrl : [ 'string' ],
		turnManagerUsername : [ 'string' ],
		useTLS : [ 'boolean' ],
		xmppProxySet : [ 'string[]' ],
		xmppResource : [ 'string' ]
	};

	// Acceptable properties/types for Croc.capability object configuration
	var subConfigTypes = {
		capability : {
			refreshPeriod : 'number',
			onWatchRequest : 'function',
			onWatchChange : 'function'
		},
		data : {
			idleTimeout : 'number',
			onDataSession : 'function',
			onData : 'function',
			onXHTMLReceived: 'function'
		},
		media : {
			onMediaSession : 'function'
		},
		presence : {
			onConnected : 'function',
			onContactsReceived: 'function',
			onDirectNotify: 'function',
			onDisconnected: 'function',
			onNewContact: 'function',
			onSelfNotify: 'function',
			onWatchRequest: 'function'
		}
	};

	// Private functions
	/**
	 * Used to check that the configuration object specified on creation of the
	 * {@link CrocSDK.Croc Croc} Object contains configurable properties.
	 * 
	 * @private
	 * @param config
	 */
	function checkConfig(config) {
		var prop = null;

		if (!config) {
			throw new CrocSDK.Exceptions.ValueError(
					"Configuration object missing");
		}

		// Loop through each of the provided config properties
		for (prop in config) {
			var allowedTypes = configTypes[prop];

			// Check it's a defined property
			if (!allowedTypes) {
				throw new CrocSDK.Exceptions.ValueError(
						"Unexpected config property: " + prop);
			}

			// Check the property is one of the accepted types
			var propValue = config[prop];
			var validType = false;
			for ( var i = 0, len = allowedTypes.length; i < len; i++) {
				if (CrocSDK.Util.isType(propValue, allowedTypes[i])) {
					validType = true;
					break;
				}
			}

			if (!validType) {
				throw new TypeError(prop + " is not set to a valid type");
			}
		}

		// Confirm that any exclusions or dependencies are satisfied
		if (config.apiKey) {
			if (config.sipProxySet) {
				throw new CrocSDK.Exceptions.ValueError(
						"Both apiKey and sipProxySet are configured");
			}
			if (config.msrpRelaySet) {
				throw new CrocSDK.Exceptions.ValueError(
						"Both apiKey and msrpRelaySet are configured");
			}
		} else if (config.sipProxySet) {
			if (config.sipProxySet instanceof Array && config.sipProxySet.length === 0) {
				throw new CrocSDK.Exceptions.ValueError("sipProxySet is empty");
			}
		} else {
			throw new CrocSDK.Exceptions.ValueError(
					"Either apiKey or sipProxySet must be configured");
		}

		// Check config for the various APIs
		for ( var api in subConfigTypes) {
			for (prop in config[api]) {
				var allowedType = subConfigTypes[api][prop];

				// Check it's a defined property
				if (!allowedType) {
					throw new CrocSDK.Exceptions.ValueError(
							"Unexpected config property: " + api + '.' + prop);
				}

				// Check the property is the accepted type
				if (!CrocSDK.Util.isType(config[api][prop], allowedType)) {
					throw new TypeError(api + '.' + prop + " is not set to a valid type");
				}
			}
		}
	}

	/**
	 * Gets the initial capabilities, based on the croc config.
	 * 
	 * @private
	 * @param config
	 * @returns {CrocSDK.Croc~Capabilities}
	 */
	function initialCapabilities(config) {
		var cap = {
			"sip.audio": true,
			"sip.video": true,
			"sip.text": true,
			"sip.data": true,
			"croc.sdkversion": "1"
		};
		var features = config.features;

		if (features) {
			// Update capabilities to reflect application's desired features
			cap["sip.audio"] = features.indexOf(CrocSDK.C.FEATURES.AUDIO) >= 0;
			cap["sip.video"] = features.indexOf(CrocSDK.C.FEATURES.VIDEO) >= 0;
		}

		if (!config.apiKey && !config.msrpRelaySet) {
			cap["sip.text"] = false;
			cap["sip.data"] = false;
		}

		if (!JsSIP.WebRTC.getUserMedia) {
			cap["sip.audio"] = false;
			cap["sip.video"] = false;
		}

		return cap;
	}

	/**
	 * Used to set up a JsSIP User Agent
	 * 
	 * @private
	 * @param {CrocSDK.Croc}
	 *            croc
	 */
	function initJsSip(croc) {
		// Override the reported User-Agent
		if (JsSIP.C.USER_AGENT.indexOf('Crocodile') === -1) {
			JsSIP.C.USER_AGENT = 'Crocodile SDK v1.0; '.concat(
					JsSIP.C.USER_AGENT, '; ', navigator.userAgent);
		}

		// Restructure sipProxySet as array of URIs
		var sipProxySet = croc.sipProxySet;
		var apiKey = croc.apiKey || '';

		if (CrocSDK.Util.isType(croc.sipProxySet, 'string')) {
			sipProxySet = [ sipProxySet ];
		}
		var scheme = 'ws';
		if (croc.useTLS) {
			scheme = 'wss';
		}
		for ( var i = 0, len = sipProxySet.length; i < len; i++) {
			sipProxySet[i] = scheme.concat('://', sipProxySet[i], '/', apiKey);
		}

		// Check for an existing UUID instance id in local storage
		var instance = localStorage['croc.rtc.sip.instance'];
		if (!instance) {
			instance = JsSIP.Utils.newUUID();
			localStorage['croc.rtc.sip.instance'] = instance;
		}

		// Configuration object to use for JsSIP user agent
		var sipConfig = {
			ws_servers : sipProxySet,
			register : croc.register,
			register_expires : croc.expiresTime,
			uri : 'sip:' + (croc.address || 'anonymous@anonymous.invalid'),
			password : croc.password,
			authorization_user : croc.authorizationUser,
			display_name : croc.displayName,
			no_answer_timeout : croc.acceptTimeout,
			handle_media : false,
			instance_id: instance
		};

		// Create the JsSIP User Agent
		croc.sipUA = new JsSIP.UA(sipConfig);

		// Handle events for JsSIP
		croc.sipUA.on('connected', function() {
			/**
			 * Dispatched when the croc object has successfully connected to the
			 * network.
			 * <p>
			 * No action is taken when this event occurs if the event handler is
			 * not defined.
			 * 
			 * @event CrocSDK.Croc#onConnected
			 * @param {CrocSDK.Croc~ConnectedEvent} event
			 * The event object associated with this event.
			 */
			CrocSDK.Util.fireEvent(croc, 'onConnected', {});
		});
		croc.sipUA.on('disconnected', function(event) {
			/**
			 * Dispatched when the croc object has disconnected from the
			 * network, or a connection attempt has failed.
			 * <p>
			 * The croc object will automatically attempt to re-establish
			 * dropped connections as long as it is still running.
			 * 
			 * @event CrocSDK.Croc#onDisconnected
			 * @param {CrocSDK.Croc~DisconnectedEvent} event
			 * The event object associated with this event.
			 */
			CrocSDK.Util.fireEvent(croc, 'onDisconnected', {
				status : CrocSDK.Util.websocketCauseToSdkStatus(event.data.code)
			});
		});
		croc.sipUA.on('registered', function(event) {
			/**
			 * Dispatched when the croc object has successfully registered on
			 * the network.
			 * 
			 * @event CrocSDK.Croc#onRegistered
			 * @param {CrocSDK.Croc~RegisteredEvent} event
			 * The event object associated with this event.
			 */
			var response = event.data.response;
			var numContacts = response.countHeader('contact');
			var idx, contactHeader;
			var gruus = [];
			for (idx = 0; idx < numContacts; idx++) {
				contactHeader = response.parseHeader('contact', idx);
				if (contactHeader.uri.user !== croc.sipUA.contact.uri.user) {
					var gruu = contactHeader.getParam('pub-gruu');
					if (gruu) {
						gruus.push(gruu.replace(/"/g,''));
					}
				}
			}
			CrocSDK.Util.fireEvent(croc, 'onRegistered', {
				instanceAddresses: gruus
			});
		});
		croc.sipUA.on('unregistered', function(event) {
			/**
			 * Dispatched when the croc object has unregistered from the
			 * network, or a periodic re-register attempt has failed.
			 * <p>
			 * If registration fails due to an authentication error, the croc
			 * object will automatically stop; no further connection attempts
			 * will be made.
			 * 
			 * @event CrocSDK.Croc#onUnregistered
			 * @param {CrocSDK.Croc~UnregisteredEvent} event
			 * The event object associated with this event.
			 */
			CrocSDK.Util.fireEvent(croc, 'onUnregistered', {});

			// Auth failures should trigger croc object to stop
			switch (event.data.cause) {
			case JsSIP.C.causes.AUTHENTICATION_ERROR:
			case JsSIP.C.causes.REJECTED:
				console.log('Registration authentication failed - stopping');
				croc.stop();
				break;
			}
		});
		croc.sipUA.on('registrationFailed', function(event) {
			var cause = 'other';

			switch (event.data.cause) {
			case JsSIP.C.causes.REQUEST_TIMEOUT:
				cause = 'timeout';
				break;
			case JsSIP.C.causes.AUTHENTICATION_ERROR:
			case JsSIP.C.causes.REJECTED:
				cause = 'auth';
				break;
			}

			/**
			 * Dispatched when the croc object has failed to register on the
			 * network.
			 * <p>
			 * If registration fails due to an authentication error, the croc
			 * object will automatically stop; no further connection attempts
			 * will be made.
			 * 
			 * @event CrocSDK.Croc#onRegistrationFailed
			 * @param {CrocSDK.Croc~RegistrationFailedEvent} event
			 * The event object associated with this event.
			 */
			CrocSDK.Util.fireEvent(croc, 'onRegistrationFailed', {
				cause : cause
			});

			// Auth failures should trigger croc object to stop
			switch (event.data.cause) {
			case JsSIP.C.causes.AUTHENTICATION_ERROR:
			case JsSIP.C.causes.REJECTED:
				console.log('Registration authentication failed - stopping');
				croc.stop();
				break;
			}
		});

		// We've customised the newRTCSession event behaviour so that we can
		// get first dibs on the SDP.
		croc.sipUA.on('newRTCSession', function(event) {
			var data = event.data;

			if (data.originator === 'remote') {
				// Add our capabilities to contact in the new JsSIP session
				data.session.contact += croc.capability
						.createFeatureTags(croc.capabilities);

				// JsSIP has not yet processed the SDP
				// Examine SDP to distinguish between data and media sessions
				var sdp = new CrocSDK.Sdp.Session(data.request.body);
				if (!sdp) {
					// SDP parsing failed
					data.sdpInvalid();
					return;
				}

				// Check for an MSRP m-line
				for ( var i = 0, len = sdp.media.length; i < len; i++) {
					var mLine = sdp.media[i];
					if (mLine.media === 'message') {
						switch (mLine.proto) {
						case 'TCP/MSRP':
						case 'TCP/TLS/MSRP':
							// Pass on to the Data API
							croc.data.init_incoming(data.session, data.request,
									mLine, data.sdpValid, data.sdpInvalid);
							return;
						default:
							break;
						}
					}
				}

				// Doesn't look like data - pass on to the Media API
				croc.media.init_incoming(data.session, data.request, sdp,
						data.sdpValid, data.sdpInvalid);
			}
		});
	}

	function initJsJac(croc) {
		if (!croc.xmppProxySet || croc.xmppProxySet.length < 1) {
			// XMPP proxy not configured
			return;
		}
		if (!croc.address) {
			// Cannot use XMPP anonymously
			return;
		}

		var randomIndex = Math.floor(Math.random() * croc.xmppProxySet.length);
		var selectedRelay = croc.xmppProxySet[randomIndex];
		var scheme = 'ws';
		if (croc.useTLS) {
			scheme = 'wss';
		}
		var path = '';
		if (croc.apiKey) {
			var addrParts = croc.address.split('@');
			path = croc.apiKey.concat('/', addrParts[1], '/', addrParts[0]);
		}
		var url = scheme.concat('://', selectedRelay, '/', path);

		croc.xmppCon = new JSJaCWebSocketConnection({
			httpbase : url
		});

		if (!croc.xmppResource) {
			// Set a random string as the resource to avoid conflicts
			croc.xmppResource = CrocSDK.Util.randomAlphanumericString(10);
		}
	}

	/**
	 * Handles ephemeral credential management through a REST API.
	 * 
	 * @private
	 * @see {@link https://rfc5766-turn-server.googlecode.com/svn/trunk/docs/TURNServerRESTAPI.pdf}
	 * @param {jQuery} jQuery
	 * @param {string} url - The URL of the REST API.
	 * @param {string} service - The service to send as the query parameter.
	 * @param {string} username - The username to use in the REST calls.
	 * @param {number} retryPeriod - The number of seconds to wait between
	 * retries if a query fails.
	 */
	function EphemeralCredentialsManager(jQuery, url, service, username, retryPeriod) {
		this.jQuery = jQuery;
		this.service = service;
		this.url = url;
		this.username = username;
		this.retryPeriod = retryPeriod;
		this.timerId = null;
	}
	EphemeralCredentialsManager.prototype.start = function() {
		if (this.url && !this.timerId) {
			this.query();
		}
	};
	EphemeralCredentialsManager.prototype.stop = function() {
		if (this.timerId !== null) {
			clearTimeout(this.timerId);
			this.timerId = null;
		}
	};
	EphemeralCredentialsManager.prototype.query = function() {
		var manager = this;
		var queryParams = {
			'service': this.service
		};

		if (this.username) {
			queryParams.username = this.username;
		}

		if (this.timerId !== null) {
			clearTimeout(this.timerId);
			this.timerId = null;
		}

		this.jQuery.getJSON(this.url, queryParams).done(function(response) {
			var nextAttemptDelay = Math.max(response.ttl - 5, 60);

			console.log('Next credential refresh in', nextAttemptDelay, 'seconds');
			manager.timerId = setTimeout(function() {
				manager.timerId = null;
				manager.query();
			}, nextAttemptDelay * 1000);
			CrocSDK.Util.fireEvent(manager, 'onUpdate', response);
		}).fail(function(jqxhr, textStatus, error) {
			console.warn('Ephemeral credential request failed:', textStatus, error);
			manager.timerId = setTimeout(function() {
				manager.timerId = null;
				manager.query();
			}, manager.retryPeriod * 1000);
		});
	};

	/**
	 * Handles authentication with the Crocodile REST API, so that the
	 * application can use other REST calls (such as getting balance).
	 * 
	 * @private
	 * @param {jQuery}
	 *            jQuery
	 * @param {string}
	 *            username - The username to use in the REST calls.
	 * @param {string}
	 *            password - The username to use in the REST calls.
	 * @param {number}
	 *            retryPeriod - The number of seconds to wait between retries if
	 *            a query fails.
	 */
	function RestAuthManager(jQuery, username, password, retryPeriod) {
		this.jQuery = jQuery;
		this.path = '/crocodile-sdk-hub/rest/1.0/browser/login';
		this.url = 'https://hub.crocodilertc.net:8443' + this.path;
		this.username = username;
		this.password = password;
		this.retryPeriod = retryPeriod || 60;
		this.timerId = null;
	}
	RestAuthManager.prototype.start = function() {
		if (!this.timerId) {
			this.auth();
		}
	};
	RestAuthManager.prototype.stop = function() {
		if (this.timerId) {
			clearTimeout(this.timerId);
			this.timerId = null;
		}
	};
	RestAuthManager.prototype.auth = function() {
		var auth = this;
		var md5 = JsSIP.Utils.calculateMD5;
		var handleFail = function(jqxhr, textStatus, error) {
			console.warn('Auth nonce request failed:', textStatus, error);

			auth.timerId = setTimeout(function() {
				auth.auth();
			}, auth.retryPeriod * 1000);
		};

		// Get the challenge
		this.jQuery.ajax(this.url, {
			dataType : 'json',
			cache : false
		}).done(
				function(json) {
					var nc = '00000001';
					var cnonce = CrocSDK.Util.randomAlphanumericString(10);
					var ha1 = md5(auth.username.concat(':', json.realm, ':',
							auth.password));
					var ha2 = md5('POST:' + auth.path);
					var response = md5(ha1.concat(':', json.nonce, ':', nc,
							':', cnonce, ':auth:', ha2));

					if (json.qop !== 'auth') {
						console.warn('Unexpected qop value:', json.qop);
						return;
					}

					var data = {
						username : auth.username,
						realm : json.realm,
						nonce : json.nonce,
						cnonce : cnonce,
						nc : nc,
						qop : json.qop,
						uri : auth.path,
						response : response
					};

					// Send our response
					auth.jQuery.ajax(this.url, {
						type : 'POST',
						dataType : 'json',
						data : JSON.stringify(data),
						contentType : 'application/json; charset=UTF-8',
						xhrFields: {withCredentials: true}
					}).done(
							function(json) {
								var nextAuth = Math.max(json.ttl - 5,
										auth.retryPeriod);
								auth.timerId = setTimeout(function() {
									auth.auth();
								}, nextAuth * 1000);
								console.log('Next auth refresh in', nextAuth,
										'seconds');
							}).fail(handleFail);
				}).fail(handleFail);
	};

	/**
	 * <p>
	 * The Croc object is the linchpin of the Crocodile RTC JavaScript Library.
	 * An application's first interaction with the Crocodile RTC JavaScript
	 * Library is to create an instance of the Croc object. Further interactions
	 * will be through the created instance.
	 * </p>
	 * 
	 * <p>
	 * An example of instantiating the Crocodile RTC JavaScript Library:
	 *   <pre>
	 *   <code>
	 *     var crocObject = $.croc({
	 *       apiKey: "API_KEY_GOES_HERE",
	 *       onConnected: function () {
	 *         // Some code
	 *       }
	 *     });
	 *   </code>
	 *   </pre>
	 * </p>
	 * 
	 * @constructor
	 * @param {CrocSDK~Config} config - A configuration object containing any
	 * properties/event handlers you wish to configure; any that are not
	 * provided will be set to their default value.
	 * <p>
	 * To use the Crocodile network, you must at least provide the
	 * <code>apiKey</code> property.
	 * </p>
	 */
	CrocSDK.Croc = function(config) {
		var croc = this;
		this.started = false;
		/**
		 * @type JSJaCWebSocketConnection
		 * @private
		 */
		this.xmppCon = null;
		this.turnManager = null;
		this.authManager = null;

		// Check for apiKey or sipProxySet
		checkConfig(config);

		// Squash address/username to make it case insensitive in the auth hash
		if (config.address) {
			config.address = config.address.toLowerCase();
		}

		var initialConfig = {
			capabilities : initialCapabilities(config),
			register : !!config.address
		};

		// Merge the configuration objects together.
		var mergedConfig;
		if (config.apiKey) {
			mergedConfig = config.jQuery.extend(true, {}, defaultConfig,
					crocNetworkDefaultConfig, initialConfig, config);
		} else {
			mergedConfig = config.jQuery.extend(true, {}, defaultConfig, initialConfig, config);
		}
		// We don't want to merge the arrays in provided config with arrays in
		// the default config; override them instead.
		if (config.sipProxySet) {
			mergedConfig.sipProxySet = config.sipProxySet;
		}
		if (config.msrpRelaySet) {
			mergedConfig.msrpRelaySet = config.msrpRelaySet;
		}
		if (config.xmppProxySet) {
			mergedConfig.xmppProxySet = config.xmppProxySet;
		}
		if (config.iceServers) {
			mergedConfig.iceServers = config.iceServers;
		}
		if (config.features) {
			mergedConfig.features = config.features;
		}

		// Initialise underlying APIs
		var apis = {
			/**
			 * @memberof CrocSDK.Croc
			 * @type CrocSDK.CapabilityAPI
			 * @instance
			 */
			capability : new CrocSDK.CapabilityAPI(this, mergedConfig),
			/**
			 * @memberof CrocSDK.Croc
			 * @type CrocSDK.DataAPI
			 * @instance
			 */
			data : new CrocSDK.DataAPI(this, mergedConfig),
			/**
			 * @memberof CrocSDK.Croc
			 * @type CrocSDK.MediaAPI
			 * @instance
			 */
			media : new CrocSDK.MediaAPI(this, mergedConfig),
			/**
			 * @memberof CrocSDK.Croc
			 * @type CrocSDK.XmppPresenceAPI
			 * @instance
			 */
			presence : new CrocSDK.XmppPresenceAPI(this, mergedConfig)
		};

		// Merge the apis and config into this Croc object instance
		config.jQuery.extend(this, mergedConfig, apis);

		// Kick off media capability detection (async)
		this._detectCapabilities();

		// Initialise JsSIP
		initJsSip(this);

		// Initialise JSJaC
		initJsJac(this);

		// Initialise REST auth manager
		if (this.apiKey && this.address) {
			this.authManager = new RestAuthManager(this.jQuery, this.address, this.password);
		}

		// Initialise TURN credentials manager
		if (this.turnManagerUrl) {
			if (!this.turnManagerUsername) {
				// Generate TURN manager username
				var turnUser = config.apiKey.concat('+');
				if (config.address) {
					turnUser += config.address.concat('+');
				}
				turnUser += CrocSDK.Util.randomAlphanumericString(8);
				this.turnManagerUsername = turnUser;
			}

			this.turnManager = new EphemeralCredentialsManager(this.jQuery,
					this.turnManagerUrl, 'turn', this.turnManagerUsername, 3600);
			this.turnManager.onUpdate = function (response) {
				console.log('Received TURN config:', response);

				var iceServers = [];
				for ( var i = 0; i < response.uris.length; ++i) {
					var uri = response.uris[i];
					// URL-encoded username is not decoded before being passed to
					// the TURN server in Chrome 26; see:
					// https://code.google.com/p/webrtc/issues/detail?id=1508
					// Thus our TURN will not work with this version
					var m = navigator.userAgent.match(/Chrome\/([0-9]*)/);
					if (m && parseInt(m[1], 10) < 28) {
						// Embed the username in the URL
						var username = encodeURIComponent(response.username);
						uri = uri.replace(':', ':'.concat(username, '@'));
					}
					iceServers.push({
						"url" : uri,
						// The username is specified as a separate property in
						// Chrome 29+
						"username" : response.username,
						"credential" : response.password
					});
				}
				croc.dynamicIceServers = iceServers;

				// Update any current media sessions
				croc.media._updateIceServers();
			};
		}

		// Initialise MSRP credentials manager
		if (this.msrpManagerUrl) {
			if (!this.msrpManagerUsername) {
				// Generate MSRP manager username
				var msrpUser = config.apiKey.concat('+');
				if (config.address) {
					msrpUser += config.address.concat('+');
				}
				msrpUser += CrocSDK.Util.randomAlphanumericString(8);
				this.msrpManagerUsername = msrpUser;
			}

			this.msrpManager = new EphemeralCredentialsManager(this.jQuery,
					this.msrpManagerUrl, 'msrp', this.msrpManagerUsername, 3600);
			this.msrpManager.onUpdate = function (response) {
				console.log('Received MSRP config:', response);

				if (!croc.msrpRelaySet) {
					croc.msrpRelaySet = response.relays;
				}

				croc.data.initMsrp(croc, response.username, response.password);
			};
		}

		// Run init configuration for apis
		this.capability.init();
		this.data.init();
		this.media.init();
		this.presence.init();

		if (this.autostart) {
			// Start a connection to the service
			this.start();
		}
	};

	CrocSDK.Croc.prototype._detectCapabilities = function() {
		var cap = this.capabilities;
		var mst = window.MediaStreamTrack;

		if (mst && mst.getSources) {
			// Check capabilities without requesting access to media
			var detectedSourceTypes = {
				audio: false,
				video: false
			};

			try {
				mst.getSources(function(sources) {
					for (var idx = 0, len = sources.length; idx < len; idx++) {
						detectedSourceTypes[sources[idx].kind] = true;
					}

					cap["sip.audio"] = cap["sip.audio"] && detectedSourceTypes.audio;
					cap["sip.video"] = cap["sip.video"] && detectedSourceTypes.video;
				});
				return;
			} catch (e) {
				// Fall back to getUserMedia
			}
		}

		if (JsSIP.WebRTC.getUserMedia) {
			// Check capabilities by requesting access to media
			var stopStream = function(stream) {
				stream.stop();
			};
			var detectMicrophone = function() {
				if (cap["sip.audio"]) {
					JsSIP.WebRTC.getUserMedia({
						audio: true
					}, stopStream, function() {
						cap["sip.audio"] = false;
					});
				}
			};

			if (cap["sip.video"]) {
				// Request access to webcam to determine whether one is present
				JsSIP.WebRTC.getUserMedia({
					video: true,
					audio: true
				}, stopStream, function() {
					cap["sip.video"] = false;
					// Fall back to microphone check
					detectMicrophone();
				});
			} else {
				detectMicrophone();
			}
		}
	};

	// Public methods
	/**
	 * Starts the croc object.
	 * <p>
	 * This will create the connection to the network, and retry failed
	 * connections, until the croc object is stopped.
	 * <p>
	 * By default, the croc object automatically starts when it is constructed,
	 * so this method does not need to be called.
	 * <p>
	 * This method replaces the deprecated <code>connect</code> method.
	 */
	CrocSDK.Croc.prototype.start = function() {
		// Start a connection using JsSIP
		if (!this.started) {
			var croc = this;

			this.started = true;

			/*
			 * This attempt at unloading, after much testing, seems to be the
			 * best we can manage for now. At least the net effect is consistent
			 * between Chrome 26 and Firefox 20.
			 */
			this.beforeunload = function() {
				// Start a graceful disconnect, so we at least try to clean
				// up properly. We can't wait for responses, so no chance of
				// ACKs or authorising requests. :-(
				croc.stop();
				// Force the WS close now, so the WS server at least sees a
				// Connection Close frame.
				croc.sipUA.transport.disconnect();
			};
			window.addEventListener('beforeunload', this.beforeunload, false);

			this.sipUA.start();
			this.capability.start();
			if (this.authManager) {
				this.authManager.start();
			}
			if (this.turnManager) {
				this.turnManager.start();
			}
			if (this.msrpManager) {
				this.msrpManager.start();
			}
			if (croc.features.indexOf(CrocSDK.C.FEATURES.PRESENCE) >= 0) {
				this.presence.start();
			}
		}
	};

	/**
	 * Synonym for the {@link CrocSDK.Croc#start start} method.
	 * @deprecated
	 */
	CrocSDK.Croc.prototype.connect = function() {
		this.start();
	};

	/**
	 * Stops the croc object.
	 * <p>
	 * This will close any outstanding sessions, unregister from the network
	 * network, and disconnect any WebSockets. No further connection attempts
	 * will be made unless the croc object is started again.
	 * <p>
	 * The library registers a <code>beforeunload</code> handler which should
	 * call this method automatically if the user closes or navigates away from
	 * the current page. Where possible, it is preferable to call this method
	 * at an earlier stage, so these actions have more time to complete
	 * successfully.
	 * <p>
	 * This method replaces the deprecated <code>disconnect</code> method.
	 */
	CrocSDK.Croc.prototype.stop = function() {
		// Stop a connection using JsSIP
		if (this.started) {
			this.started = false;
			window.removeEventListener('beforeunload', this.beforeunload, false);

			if (this.authManager) {
				this.authManager.stop();
			}
			if (this.turnManager) {
				this.turnManager.stop();
			}
			if (this.msrpManager) {
				this.msrpManager.stop();
			}
			this.capability.stop();
			this.presence.stop();
			this.data.close();
			this.media.close();
			this.sipUA.stop();
		}
	};

	/**
	 * Synonym for the {@link CrocSDK.Croc#stop stop} method.
	 * @deprecated
	 */
	CrocSDK.Croc.prototype.disconnect = function() {
		this.stop();
	};

	/**
	 * Returns <code>true</code> if the Crocodile RTC JavaScript Library
	 * object is connected to the network.
	 * 
	 * @returns Boolean
	 */
	CrocSDK.Croc.prototype.isConnected = function() {
		// Check whether a connection has been established
		return this.sipUA.isConnected();
	};

	/**
	 * Explicitly registers the Crocodile RTC JavaScript Library object with the
	 * network. If the <code>register</code> property is set to
	 * <code>true</code>, the object will be automatically registered when the
	 * croc object starts.
	 * <p>
	 * The Crocodile RTC JavaScript Library object must be registered with the
	 * network to receive inbound out-of-session requests.
	 */
	CrocSDK.Croc.prototype.reregister = function() {
		// Register to a service using JsSIP
		this.sipUA.register();
	};

	/**
	 * Explicitly un-registers the Crocodile RTC JavaScript Library object from
	 * the network.
	 * <p>
	 * The Crocodile RTC JavaScript Library object must be registered with the
	 * network to receive inbound out-of-session requests.
	 */
	CrocSDK.Croc.prototype.unregister = function() {
		// Unregister from a service using JsSIP
		this.sipUA.unregister();
	};

	/* Further Documentation */
	// Members
	/**
	 * @memberof CrocSDK.Croc
	 * @member {String} apiKey
	 * @instance
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @member {CrocSDK.Croc~Capabilities} capabilities
	 * @instance
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @member {String} address
	 * @instance
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @member {String} password
	 * @instance
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @member {String} authorizationUser
	 * @instance
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @member {String} displayName
	 * @instance
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @member {Boolean} register
	 * @instance
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @member {String|Array<string>} sipProxySet
	 * @instance
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @member {String|Array<string>} msrpRelaySet
	 * @instance
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @member {Number} expiresTime
	 * @instance
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @member {Boolean} requireMatchingVersion
	 * @instance
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @member {Number} acceptTimeout
	 * @instance
	 */
	// Type Definitions
	/**
	 * <p>
	 * A {@link CrocSDK.Croc~Capabilities Capabilities} object is a plain 
	 * Javascript object, but with the key names matching the capabilities 
	 * defined in {@link CrocSDK.Croc~Capabilities Capabilities}. For instance,
	 * with the default values defined in that section, the 
	 * {@link CrocSDK.Croc~Capabilities Capabilities} object for a 
	 * WebRTC-capable browser with a webcam, and on the Crocodile network, 
	 * would be as follows:
	 *   <pre>
	 *   <code>
	 *     {
	 *       "sip.audio": true,
	 *       "sip.data": true,
	 *       "sip.text": true,
	 *       "sip.video": true,
	 *       "croc.sdkversion": "1.0",
	 *       "custom.myNameSpace: 'nameSpaceContent'"
	 *     }
	 *   </code>
	 *   </pre>
	 * </p> 
	 *
	 * @memberof CrocSDK.Croc
	 * @typedef CrocSDK.Croc~Capabilities
	 * @property {Boolean} [sip.audio=detected] <code>true</code> if the
	 *           browser supports PeerConnection. Even if there is no microphone
	 *           it might be possible to receive audio.
	 * @property {Boolean} [sip.data=detected] <code>true</code> if MSRP
	 *           relays are configured.
	 * @property {Boolean} [sip.text=detected] <code>true</code> if MSRP
	 *           relays are configured.
	 * @property {Boolean} [sip.video=detected] <code>true</code> if the
	 *           browser supports PeerConnection. Even if there is no web-cam it
	 *           might be possible to receive video.
	 * @property {String} [croc.sdkversion='1'] Cannot be changed or overridden.
	 * @property [custom.<String>] Web-app developers can create their own
	 *           capabilities within the <code>custom.</code> namespace.
	 *           Custom capabilities may be simple present/not-present tags or
	 *           attribute value pairs.
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @typedef CrocSDK.Croc~ConnectedEvent
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @typedef CrocSDK.Croc~DisconnectedEvent
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @typedef CrocSDK.Croc~RegisteredEvent
	 * @property {Array.<JsSIP.URI>} instanceAddresses
	 * An array containing the unique addresses of other client instances
	 * currently registered on the network as this user. If the user is not
	 * logged in on any other clients, the array will be empty.
	 * <p>
	 * The instance addresses can be used to target a request at specific client
	 * instance.  Currently they can be used with the following:
	 * <ul>
	 * <li>Capabilities requests (using the
	 * {@link CrocSDK.CapabilityAPI#query query} method)</li>
	 * <li>MSRP data sessions</li>
	 * </ul>
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @typedef CrocSDK.Croc~UnregisteredEvent
	 */
	/**
	 * @memberof CrocSDK.Croc
	 * @typedef CrocSDK.Croc~RegistrationFailedEvent
	 * @property {String} cause The message stating why the registration 
	 * process failed.
	 */

}(CrocSDK));

(function(CrocSDK) {
	// Base tags are sip tags that don't need the sip. prefix
	var baseTags = {
		audio : 'boolean',
		video : 'boolean',
		text : 'boolean',
		data : 'boolean'
	};
	var allowedTags = {
		croc : {
			sdkversion : 'string'
		}
	};

	// Private functions
	/**
	 * Used to set the initial cache object to default value null.
	 * 
	 * @private
	 */
	function WatchData() {
		this.status = null;
		this.capabilities = null;
		this.userAgent = null;
		this.instanceAddress = null;
	}

	/**
	 * Fires when an options request is sent out to the recipient. This will
	 * process the request and send an appropriate response.
	 * 
	 * @private
	 * @param {CrocSDK.CapabilityAPI}
	 *            capabilityApi An instance of the Capability API
	 * @param {JsSIP.IncomingRequest}
	 *            request The incoming request object
	 * @param extraHeaders
	 *            Optional headers that can be added to a request
	 * @fires CrocSDK.CapabilityAPI#onWatchRequest
	 */
	function processOptionsRequest(capabilityApi, request, extraHeaders) {
		// On incoming OPTIONs message
		var crocObject = capabilityApi.crocObject;
		var status = "normal";
		var responseCode = 200;
		var contactHeader = 'Contact: ';
		var customCapabilities = null;

		contactHeader += crocObject.sipUA.contact.toString();

		// Fire onWatchRequest event, allow app to change status
		CrocSDK.Util.fireEvent(capabilityApi, "onWatchRequest", {
			address : request.parseHeader('from', 0).uri.toAor().replace(/^sip:/, ''),
			setWatchStatus : function(setStatus) {
				if (CrocSDK.Util.isType(setStatus, "string")) {
					switch (setStatus) {
					case "normal":
					case "blocked":
					case "offline":
					case "notfound":
						status = setStatus;
						break;
					default:
						throw new CrocSDK.Exceptions.ValueError(
								'Invalid status:', setStatus);
					}
				} else {
					throw new TypeError(setStatus + " is not set to a valid type");
				}
			},
			setCapabilities: function(capabilities) {
				customCapabilities = capabilities;
			}
		});

		// Reply
		switch (status) {
		case "normal":
			var caps;
			if (customCapabilities) {
				caps = {};
				CrocSDK.Util.shallowCopy(caps, crocObject.capabilities);
				CrocSDK.Util.shallowCopy(caps, customCapabilities);
			} else {
				caps = crocObject.capabilities;
			}
			contactHeader += capabilityApi.createFeatureTags(caps);
			break;
		case "blocked":
			responseCode = 403;
			break;
		case "notfound":
			responseCode = 404;
			break;
		case "offline":
			responseCode = 480;
			break;
		}

		extraHeaders.push(contactHeader);
		request.reply(responseCode, null, extraHeaders);
	}

	/**
	 * Fires when a reply is sent back from an options request. This will 
	 * process the reply and create a response.
	 * 
	 * @private
	 * @param {CrocSDK.CapabilityAPI}
	 *            capabilityApi An instance of the Capability API
	 * @param watchData
	 * @param {JsSIP.IncomingResponse}
	 *            response An instance of a JsSIP.IncomingResponse class
	 * @returns {Boolean} <code>true</code> if watchData has changed from the
	 * last observed response.
	 */
	function processOptionsResponse(capabilityApi, watchData, response) {
		var previousStatus = watchData.status;
		var previousCapabilities = watchData.capabilities;

		switch (response.status_code) {
		case 200:
			watchData.status = "normal";
			break;
		case 403:
			watchData.status = "blocked";
			break;
		case 404:
			watchData.status = "notfound";
			break;
		case 408:
		case 480:
			watchData.status = "offline";
			break;
		default:
			watchData.status = "error";
			break;
		}

		if (response.hasHeader('contact')) {
			var parsedContact = response.parseHeader('contact', 0);
			watchData.instanceAddress = parsedContact.uri.toString();
			watchData.capabilities = capabilityApi.parseFeatureTags(parsedContact.parameters);
		}

		watchData.userAgent = response.getHeader('user-agent');

		var fireEvent = false;
		if (previousStatus !== watchData.status) {
			fireEvent = true;
		} else if (previousCapabilities && response.hasHeader('contact')) {
			var cache = watchData.capabilities;

			for (var prop in cache) {
				if (previousCapabilities.hasOwnProperty(prop)) {
					if (previousCapabilities[prop] !== cache[prop]) {
						fireEvent = true;
					}
				} else {
					fireEvent = true;
				}
			}
		}

		return fireEvent;
	}

	/**
	 * Calculates whether or not a refresh of the capabilities for users on the
	 * watch list is necessary. This will fire according to the refresh period
	 * set for an instance of the Capability API.
	 * 
	 * @private
	 * @param {CrocSDK.CapabilityAPI}
	 *            capabilityApi An instance of the Capability API
	 */
	function refreshWatchList(capabilityApi) {
		var i = capabilityApi.nextRefreshIndex;
		var watchList = capabilityApi.watchList;
		var len = watchList.length;
		var numToSend = Math.ceil(len / capabilityApi.refreshPeriod);

		if (capabilityApi.lastRefreshStart === 0) {
			capabilityApi.lastRefreshStart = Date.now();
			i = capabilityApi.nextRefreshIndex = len;
		}

		if (i >= len) {
			var refreshAge = Date.now() - capabilityApi.lastRefreshStart;
			if (refreshAge < capabilityApi.refreshPeriod * 1000) {
				// Wait until the next refresh period
				return;
			}

			// Reset to the start of the watch list
			i = 0;
			capabilityApi.lastRefreshStart = Date.now();
		}

		for ( var sent = 0; i < len && sent < numToSend; i++, sent++) {
			capabilityApi.refresh(watchList[i]);
		}

		capabilityApi.nextRefreshIndex = i;
	}

	/**
	 * The capability features of the Crocodile RTC JavaScript Library allow a
	 * web-app to query the capabilities of other instances connected to the
	 * Crocodile RTC Network. This is useful for discovering the existence of,
	 * status of, and features supported by other users of the Crocodile RTC
	 * Network.
	 * <p>
	 * Once the {@link CrocSDK.Croc Croc} Object is instantiated it will contain
	 * an instance of the {@link CrocSDK.CapabilityAPI Capability} object named
	 * <code>capability</code>.
	 * <p>
	 * For example, given a {@link CrocSDK.Croc Croc} Object named
	 * <code>crocObject</code> the <code>Capability.refreshPeriod</code>
	 * property would be accessed as
	 * <code>crocObject.capability.refreshPeriod</code>.
	 * <p>
	 * An example using the Capability API:
	 *   <pre>
	 *   <code>
	 *     var crocObject = $.croc({
	 *       apiKey: "API_KEY_GOES_HERE",
	 *       onConnected: function () {
	 *         // Some code
	 *       },
	 *       
	 *       capability: {
	 *         refreshPeriod: 15,
	 *         onWatchRequest: function(event) {
	 *           // Some code
	 *         },
	 *         onWatchChange: function(event) {
	 *           // Some code
	 *         }
	 *       }
	 *     });
	 *   </code>
	 *   </pre>
	 * 
	 * @constructor
	 * @memberof CrocSDK
	 * @param {CrocSDK.Croc} crocObject - The parent Croc object
	 * @param {CrocSDK~Config} config - The Croc object configuration.
	 */
	CrocSDK.CapabilityAPI = function(crocObject, config) {
		this.crocObject = crocObject;
		// List of addresses being watched
		this.watchList = [];
		this.nextRefreshIndex = 0;
		this.lastRefreshStart = 0;
		// Map of watched addresses to cached data
		this.watchDataCache = {};
		this.refreshIntervalId = null;
		config.jQuery.extend(this, config.capability);
	};

	/**
	 * Used to add a 'newOptions' event handler to the JsSIP user agent.
	 * 
	 * @private
	 */
	CrocSDK.CapabilityAPI.prototype.init = function() {
		var capability = this;
		this.crocObject.sipUA.on('newOptions', function(event) {
			var data = event.data;
			if (data.originator === 'remote') {
				processOptionsRequest(capability, data.request, data.extraHeaders);
			}
		});
	};

	/**
	 * Starts the refresh task if the watch list is not empty, and the task is
	 * not already running.
	 * 
	 * @private
	 */
	CrocSDK.CapabilityAPI.prototype.start = function() {
		var capabilityApi = this;

		if (this.refreshIntervalId === null && this.watchList.length > 0) {
			// Start the refresh task
			this.refreshIntervalId = setInterval(function() {
				refreshWatchList(capabilityApi);
			}, 1000);
		}
	};

	/**
	 * Stops the refresh task if it is running.
	 * 
	 * @private
	 */
	CrocSDK.CapabilityAPI.prototype.stop = function() {
		if (this.refreshIntervalId) {
			clearInterval(this.refreshIntervalId);
			this.refreshIntervalId = null;
		}
	};

	/**
	 * Encodes a capabilities object as feature tags to append as Contact header
	 * parameters, as described in RFC 3840 section 9.
	 * 
	 * @param {Object}
	 *            capabilities
	 * @returns {string} The encoded feature tags.
	 * @see CrocSDK.CapabilityAPI#parseFeatureTags
	 * @private
	 */
	CrocSDK.CapabilityAPI.prototype.createFeatureTags = function(capabilities) {
		var featureTags = '';

		for ( var cap in capabilities) {
			var split = cap.split('.');
			if (split.length === 2) {
				var tree = split[0];
				var tag = split[1];
				var type = null;
				var value = capabilities[cap];

				if (tree === 'sip') {
					type = baseTags[tag];
				}

				if (!type) {
					if (allowedTags[tree]) {
						type = allowedTags[tree][tag];
						tag = '+' + cap;
					} else if (tree === 'custom') {
						type = typeof value;
						tag = '+' + cap;
					}
				}

				if (type) {
					if (CrocSDK.Util.isType(value, type)) {
						switch (type) {
						case 'boolean':
							if ((capabilities[cap]) && (tree !== 'custom')) {
								featureTags += ';' + tag;
							} else if ((capabilities[cap]) && (tree === 'custom')) {
								featureTags += ';' + tag + '="TRUE"';
							} else if ((!capabilities[cap]) && (tree === 'custom')) {
								featureTags += ';' + tag + '="FALSE"';
							}
							break;
						case 'string':
							featureTags += ';' + tag + '="<' + value + '>"';
							break;
						default:
							console.warn('Unsupported capability type:', cap, type);
							break;
						}
					} else {
						console.warn('Unexpected capability value:', cap, value);
					}
				} else {
					console.warn('Ignoring unknown capability:', cap);
				}
			} else {
				console.warn('Ignoring invalid capability:', cap);
			}
		}

		return featureTags;
	};

	/**
	 * Parses the feature tags in the parameters of a Contact header, and
	 * returns them as a capabilities object.
	 * 
	 * @param {Object}
	 *            contactHeaderParams The contact header parameters object, as
	 *            created by JsSIP's parsing engine.
	 * @returns {Object} The parsed capabilities.
	 * @see CrocSDK.CapabilityAPI#createFeatureTags
	 * @private
	 */
	CrocSDK.CapabilityAPI.prototype.parseFeatureTags = function(contactHeaderParams) {
		var capabilities = {};
		var tag = null;

		// Initialise boolean base tag capabilities
		// (assumes all supported base tags are booleans)
		for (tag in baseTags) {
			capabilities['sip.' + tag] = false;
		}

		for (tag in contactHeaderParams) {
			if (tag.charAt(0) === '+') {
				var value = contactHeaderParams[tag];
				var cap = tag.slice(1);
				var split = cap.split('.');

				if (split.length === 2) {
					var tree = split[0];
					tag = split[1];
					var type = null;

					if (allowedTags.hasOwnProperty(tree)) {
						type = allowedTags[tree][tag];
						if (type) {
							switch (type) {
							case 'string':
								if (value.slice(0, 2) === '"<' && value.slice(-2) === '>"') {
									capabilities[cap] = value.slice(2, -2);
								} else {
									console.warn('Unexpected string format in feature tag:', value);
								}
								break;
							}
						}
					} else if (tree === 'custom') {
						if (typeof value === 'string') {
							if (value.slice(0, 2) === '"<' && value.slice(-2) === '>"') {
								capabilities[cap] = value.slice(2, -2);
							} else if (value === '"TRUE"') {
								capabilities[cap] = true;
							} else if (value === '"FALSE"') {
								capabilities[cap] = false;
							} else {
								console.warn('Unexpected string format in feature tag:', value);
							}
						}
					} else {
						console.warn('Invalid feature tag:', tag);
					}
				} else {
					console.warn('Invalid feature tag:', tag);
				}
			} else {
				if (tag in baseTags) {
					// (assumes all supported base tags are booleans)
					capabilities['sip.' + tag] = true;
				}
			}
		}

		return capabilities;
	};

	/**
	 * Add <code>address</code> to the watch list. Crocodile RTC JavaScript
	 * Library will periodically query the capabilities of each of the addresses
	 * on the watch list. A capabilities query is sent automatically when a new
	 * address is added to the list.
	 * <p>
	 * Exceptions: TypeError, {@link CrocSDK.Exceptions#ValueError ValueError}
	 * 
	 * @param {String}
	 *            address The address to add to the watch List.
	 */
	CrocSDK.CapabilityAPI.prototype.watch = function(address) {
		var uri = CrocSDK.Util.normaliseAddress(address);
		address = uri.toAor().replace(/^sip:/, '');

		if (!this.watchDataCache[address]) {
			this.watchList.push(address);
			this.watchDataCache[address] = new WatchData();

			// Trigger an immediate refresh
			this.refresh(address);

			// Make sure the refresh task is running
			this.start();
		}
	};

	/**
	 * Remove <code>address</code> from the watch list.
	 * <p>
	 * Exceptions: TypeError, {@link CrocSDK.Exceptions#ValueError ValueError}
	 * 
	 * @param {String}
	 *            address The address to remove from the watch List.
	 */
	CrocSDK.CapabilityAPI.prototype.unwatch = function(address) {
		var uri = CrocSDK.Util.normaliseAddress(address);
		address = uri.toAor().replace(/^sip:/, '');

		if (this.watchDataCache[address]) {
			var index = this.watchList.indexOf(address);
			this.watchList.splice(index, 1);

			delete this.watchDataCache[address];
		}

		if (this.watchList.length === 0) {
			this.stop();
		}
	};

	/**
	 * Send an immediate query for the capabilities of <code>address</code>.
	 * <code>address</code> must be on the watch list before calling this
	 * method.
	 * 
	 * @param {String} address The address to refresh in the watch List.
	 * @throws {CrocSDK.Exceptions.ValueError} If the address is not on the
	 * watch list.
	 */
	CrocSDK.CapabilityAPI.prototype.refresh = function(address) {
		var capabilityApi = this;
		var uri = CrocSDK.Util.normaliseAddress(address);
		address = uri.toAor().replace(/^sip:/, '');

		var watchData = this.watchDataCache[address];
		if (!watchData) {
			throw new CrocSDK.Exceptions.ValueError('Address not in watch list');
		}

		var applicant = {
			request : new JsSIP.OutgoingRequest(JsSIP.C.OPTIONS, uri, this.crocObject.sipUA),
			receiveResponse : function(response) {
				if (processOptionsResponse(capabilityApi, watchData, response)) {
					CrocSDK.Util.fireEvent(capabilityApi, "onWatchChange", {
						address: address,
						instanceAddress: watchData.instanceAddress,
						status: watchData.status,
						capabilities: watchData.capabilities
					});
				}

				if (CrocSDK.Util.isAuthFailure(response.status_code)) {
					console.log('Request authentication failed - stopping');
					capabilityApi.crocObject.stop();
				}
			},
			onRequestTimeout : function() {
				console.log("request timeout");
				watchData.status = 'offline';
			},
			onTransportError : function() {
				console.warn("request transport error");
			}
		};

		var requestSender = new JsSIP.RequestSender(applicant, this.crocObject.sipUA);
		requestSender.send();
	};

	/**
	 * Send an immediate query for the capabilities of <code>address</code>.
	 * This is a one-off query; <code>address</code> does not have to be on the
	 * watch list before calling this method.
	 * 
	 * @param {String|JsSIP.URI} address
	 * The address to query.
	 * <p>
	 * A client instance's unique address may be used if you wish to target only
	 * that instance.
	 * @param {Function} callback
	 * The callback function to run when the result is received. The callback
	 * function is passed an
	 * {@link CrocSDK.CapabilityAPI~WatchChangeEvent WatchChangeEvent} object as
	 * the first parameter.
	 */
	CrocSDK.CapabilityAPI.prototype.query = function(address, callback) {
		var capabilityApi = this;
		var watchData = new WatchData();
		var uri = CrocSDK.Util.normaliseAddress(address);
		address = uri.toAor().replace(/^sip:/, '');

		var applicant = {
			request : new JsSIP.OutgoingRequest(JsSIP.C.OPTIONS, uri, this.crocObject.sipUA),
			receiveResponse : function(response) {
				processOptionsResponse(capabilityApi, watchData, response);
				callback({
					address: address,
					instanceAddress: watchData.instanceAddress,
					status: watchData.status,
					capabilities: watchData.capabilities
				});

				// Auth failures should trigger croc object to stop
				if (CrocSDK.Util.isAuthFailure(response.status_code)) {
					console.log('Request authentication failed - stopping');
					capabilityApi.crocObject.stop();
				}
			},
			onRequestTimeout : function() {
				console.log("request timeout");
				callback(null);
			},
			onTransportError : function() {
				console.warn("request transport error");
				callback(null);
			}
		};

		var requestSender = new JsSIP.RequestSender(applicant, this.crocObject.sipUA);
		requestSender.send();
	};

	/**
	 * Returns a Capabilities object containing the capabilities cached for
	 * <code>address</code>. Returns <code>null</code> if
	 * <code>address</code> is not on the watch list or if a capabilities
	 * query response for <code>address</code> has not yet been received.
	 * <p>
	 * Exceptions: TypeError, {@link CrocSDK.Exceptions#ValueError ValueError}
	 * 
	 * @param {String}
	 *            address The address to refresh in the watch List.
	 * @returns {CrocSDK.Croc~Capabilities} Capabilities
	 */
	CrocSDK.CapabilityAPI.prototype.getCapabilities = function(address) {
		var uri = CrocSDK.Util.normaliseAddress(address);
		address = uri.toAor().replace(/^sip:/, '');

		var watchData = this.watchDataCache[address];
		if (watchData) {
			return watchData.capabilities;
		}

		return null;
	};

	/**
	 * Returns the cached watch {@link CrocSDK.CapabilityAPI~status status} for
	 * <code>address</code>.
	 * <p>
	 * Returns <code>null</code> if <code>address</code> is not on the watch
	 * list or if a capabilities query response for <code>address</code> has
	 * not yet been received.
	 * 
	 * @param {String} address - The target address.
	 * @returns {CrocSDK.CapabilityAPI~status} watchStatus
	 */
	CrocSDK.CapabilityAPI.prototype.getWatchStatus = function(address) {
		var uri = CrocSDK.Util.normaliseAddress(address);
		address = uri.toAor().replace(/^sip:/, '');

		var watchData = this.watchDataCache[address];
		if (watchData) {
			return watchData.status;
		}

		return null;
	};

	/**
	 * Retrieves all cached data for <code>address</code>.
	 * <p>
	 * Returns <code>null</code> if <code>address</code> is not on the watch
	 * list.
	 * 
	 * @private
	 * @param {String} address - The target address.
	 * @returns The cached watch data
	 */
	CrocSDK.CapabilityAPI.prototype.getWatchData = function(address) {
		var uri = CrocSDK.Util.normaliseAddress(address);
		address = uri.toAor().replace(/^sip:/, '');

		return this.watchDataCache[address] || null;
	};

	/**
	 * Dispatched when Crocodile RTC JavaScript Library receives a capabilities
	 * query from another instance.
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * automatically respond based on the capabilities set in the
	 * {@link CrocSDK.Croc Croc} Object instance.
	 * 
	 * @memberof CrocSDK.CapabilityAPI
	 * @param {CrocSDK.CapabilityAPI~WatchRequestEvent} event
	 * The event object associated with this event.
	 * @event CrocSDK.CapabilityAPI#onWatchRequest
	 */
	CrocSDK.CapabilityAPI.prototype.onWatchRequest = function() {
		// Do nothing
	};

	/**
	 * Dispatched when Crocodile RTC JavaScript Library receives a capabilities
	 * query response.
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * cache the capabilities.
	 * 
	 * @memberof CrocSDK.CapabilityAPI
	 * @param {CrocSDK.CapabilityAPI~WatchChangeEvent} event
	 * The event object associated with this event.
	 * @event CrocSDK.CapabilityAPI#onWatchChange
	 */
	CrocSDK.CapabilityAPI.prototype.onWatchChange = function() {
		// Do nothing
	};

	/* Further Documentation */

	// Members

	/**
	 * @memberof CrocSDK.CapabilityAPI
	 * @member {Number} refreshPeriod
	 * @instance
	 */

	// Type Definitions

	/**
	 * Valid status are:
	 * <ul>
	 * <li><code>normal</code> - <code>address</code> is online and has
	 * provided capabilities information. </li>
	 * <li><code>blocked</code> - <code>address</code> has blocked you.
	 * </li>
	 * <li><code>offline</code> - <code>address</code> is offline or wants
	 * to appear offline. </li>
	 * <li><code>notfound</code> - <code>address</code> does not exist or
	 * wants to appear as if he/she does not exist. </li>
	 * <li><code>error</code> - the response code did not fit into any of the
	 * above categories.</li>
	 * </ul>
	 * 
	 * @memberof CrocSDK.CapabilityAPI
	 * @typedef {String} CrocSDK.CapabilityAPI~status
	 */

	/**
	 * @memberof CrocSDK.CapabilityAPI
	 * @typedef CrocSDK.CapabilityAPI~WatchRequestEvent
	 * @property {String} [address] The <code>address</code> of the user that
	 *           sent this capabilities query.
	 * @property {Function} [setWatchStatus] Sets the &#34;watch
	 *            {@link CrocSDK.CapabilityAPI~status status}&#34; to return in
	 *            response to the capabilities query that generated this event.        
	 */

	/**
	 * @memberof CrocSDK.CapabilityAPI
	 * @typedef CrocSDK.CapabilityAPI~WatchChangeEvent
	 * @property {String} address
	 * The address of the user being watched, and whose data has changed.
	 * @property {JsSIP.URI} instanceAddress
	 * The unique address assigned to the client instance that sent the
	 * response.
	 * @property {CrocSDK.CapabilityAPI~status} status
	 * The watch status of the user indicated by the response.
	 * @property {CrocSDK.Croc~Capabilities} capabilities
	 * The reported capabilities of the remote user's client instance.
	 * If these are not reported (i.e. if the <code>status</code> is not
	 * <code>normal</code>) this property will be <code>null</code>.
	 */

}(CrocSDK));

(function (CrocSDK) {
	CrocSDK.C = {
		FEATURES: {
			AUDIO: 'audio',
			VIDEO: 'video',
			PAGEDATA: 'pagedata',
			PRESENCE: 'presence',
			TRANSFER: 'transfer'
		},
		NS: {
			XHTML: 'http://www.w3.org/1999/xhtml',
			XMPP_XHTML_IM: 'http://jabber.org/protocol/xhtml-im',
			XMPP_RECEIPTS: 'urn:xmpp:receipts',
			XMPP_REACH: 'urn:xmpp:reach:0'
		},
		MT: {
			XHTML: 'application/xhtml+xml',
			IS_COMPOSING: 'application/im-iscomposing+xml'
		},
		states: {
			dataSession: {
				PENDING: 'pending',
				ESTABLISHED: 'established',
				CLOSED: 'closed'
			},
			rfcComposing: {
				ACTIVE: 'active',
				IDLE: 'idle'
			},
			sdkComposing: {
				COMPOSING: 'composing',
				IDLE: 'idle'
			},
			xmppChatState: {
				ACTIVE: 'active',
				COMPOSING: 'composing',
				PAUSED: 'paused',
				INACTIVE: 'inactive',
				GONE: 'gone'
			}
		},
		COMPOSING_TIMEOUT: 15
	};
}(CrocSDK));

(function (CrocSDK) {
	/**
	 * The CustomHeaders object can be used 
	 * to define headers to send in an outbound session request. Likewise, if any 
	 * custom headers are found in an inbound session request, these are available
	 * to the application in the same format.
	 * <p>
	 * There are no prescribed properties on a CustomHeaders object. Each
	 * property name that exists in the object will be mapped to a header name
	 * in the request, and each property value will be used as the associated
	 * header value.
	 * <p>
	 * All custom header keys <b><i>MUST</i></b> start with &#34;X-&#34;.
	 * Keys that do not start &#34;X-&#34; will be ignored.
	 * <p>
	 * When specifying custom headers to send, the header name can be provided
	 * with any chosen capitalisation, as long as it only uses valid characters
	 * (sticking to alphanumeric characters and dashes is recommended). However,
	 * the names of received custom headers are always provided in a specific
	 * format: with only the first character, and each character following
	 * a dash, in uppercase. For instance, a header sent as
	 * &#34;x-lowercase&#34; will be received as &#34;X-Lowercase&#34;.
	 * 
	 * @memberof CrocSDK
	 * @typedef CrocSDK~CustomHeaders
	 */
	CrocSDK.CustomHeaders = function (input) {
		if (input instanceof JsSIP.IncomingRequest) {
			this.fromJsSipHeaders(input.headers);
		} else if (input instanceof JsSIP.OutgoingRequest) {
			this.fromExtraHeaders(input.extraHeaders);
		} else if (input) {
			var name, value;
			for (name in input) {
				value = input[name];
				if (this.isValidCustomHeader(name, value)) {
					this[name] = value;
				} else {
					console.warn('Ignored custom header:', name, value);
				}
			}
		}
	};

	CrocSDK.CustomHeaders.prototype.isValidCustomHeader = function (name, value) {
		var token = /[^a-zA-Z0-9\-\.!%\*_\+`'~]/;
		if (name.slice(0, 2).toUpperCase() !== 'X-') {
			return false;
		}

		if (name.match(token)) {
			return false;
		}
		
		if (!CrocSDK.Util.isType(value, 'string')) {
			return false;
		}
		
		// Though they can be valid, ban new lines/carriage returns for safety
		if (value.match(/[\r\n]/)) {
			return false;
		}

		return true;
	};

	CrocSDK.CustomHeaders.prototype.equals = function (customHeaders) {
		var keys = Object.keys(this); 
		if (keys.length !== Object.keys(customHeaders).length) {
			return false;
		}

		for (var i = 0, len = keys.length; i < len; i++) {
			var name = keys[i];

			if (customHeaders[name] !== this[name]) {
				return false;
			}
		}

		return true;
	};

	CrocSDK.CustomHeaders.prototype.fromJsSipHeaders = function (headers) {
		for (var name in headers) {
			if (name.slice(0, 2).toUpperCase() === 'X-') {
				// We only grab the first instance of a given header name
				var value = headers[name][0].raw;
				if (this.isValidCustomHeader(name, value)) {
					this[name] = value;
				} else {
					console.warn('Ignored custom header:', name, value);
				}
			}
		}
	};

	/**
	 * Processes an array of "extra headers" as used by JsSIP.
	 * @private
	 */
	CrocSDK.CustomHeaders.prototype.fromExtraHeaders = function (extraHeaders) {
		for (var i = 0, len = extraHeaders.length; i < len; i++) {
			var header = extraHeaders[i];
			var match = header.match(/([^:]*)\s*:\s*(.*)/);
			var name = match[1];
			var value = match[2];
			if (name.slice(0, 2).toUpperCase() === 'X-' &&
					this.isValidCustomHeader(name, value)) {
				this[name] = value;
			}
		}
	};

	/**
	 * Produces an array of "extra headers" as used by JsSIP.
	 * @returns {Array}
	 * @private
	 */
	CrocSDK.CustomHeaders.prototype.toExtraHeaders = function () {
		var extraHeaders = [];
		var keys = Object.keys(this);
		
		for (var i = 0, len = keys.length; i < len; i++) {
			var name = keys[i];
			var value = this[name];
			
			if (this.isValidCustomHeader(name, value)) {
				extraHeaders.push(name + ': ' + value);
			} else {
				console.warn('Ignored invalid custom header:', name, value);
			}
		}
		
		return extraHeaders;
	};

	CrocSDK.CustomHeaders.prototype.isEmpty = function () {
		var keys = Object.keys(this);
		return keys.length === 0;
	};

}(CrocSDK));

(function(CrocSDK) {
	/**
	 * Send data to address via page mode.
	 * 
	 * @private
	 * @param {CrocSDK.DataAPI} dataApi
	 * @param {String} address
	 * @param {String} data
	 * @param {Object} [sendConfig]
	 * @returns {DataSession}
	 */
	function pageSend(dataApi, address, data, sendConfig) {
		var session = dataApi.sipDataSessions[address];
		var capabilityApi = dataApi.crocObject.capability;

		if (!session || session.getState === 'closed') {
			// No suitable session - create a new one
			session = new CrocSDK.SipDataSession(dataApi, address);

			// Start with cached capabilities if we have them
			session.capabilities = capabilityApi.getCapabilities(address);
			session.customHeaders = new CrocSDK.CustomHeaders(sendConfig.customHeaders);

			if (!dataApi.checkSessionsIntervalId) {
				dataApi.checkSessionsIntervalId = window.setInterval(
						function() {
							checkSessions(dataApi);
						}, 10000);
			}

			dataApi.sipDataSessions[address] = session;
		}

		session.send(data, sendConfig);
		return session;
	}

	/**
	 * Send data to address via MSRP.
	 * 
	 * @private
	 * @param {CrocSDK.DataAPI} dataApi
	 * @param {String} address
	 * @param {String} data
	 * @param {Object} [sendConfig]
	 * @returns {CrocSDK.MsrpDataSession}
	 */
	function msrpSend(dataApi, address, data, sendConfig) {
		var uri = CrocSDK.Util.normaliseAddress(address);
		var bareAddress = uri.toAor().replace(/^sip:/, '');
		var session = null;

		// Check for suitable existing sessions to reuse
		if (!sendConfig.customHeaders && !sendConfig.fileTransfer &&
				address === bareAddress) {
			session = dataApi.reusableMsrpDataSessions[address];
		}

		if (session && session.getState !== 'closed') {
			session.send(data, sendConfig);
		} else {
			// No sessions suitable - create a new one
			session = new CrocSDK.OutgoingMsrpSession(dataApi, uri, data, sendConfig);

			if (!dataApi.checkSessionsIntervalId) {
				dataApi.checkSessionsIntervalId = window.setInterval(
						function() {
							checkSessions(dataApi);
						}, 10000);
			}

			if (!sendConfig.customHeaders && !sendConfig.fileTransfer &&
					address === bareAddress) {
				dataApi.reusableMsrpDataSessions[address] = session;
			}
			dataApi.msrpDataSessions.push(session);
		}

		return session;
	}

	/**
	 * Send data to address via XMPP.
	 * 
	 * @private
	 * @param {CrocSDK.DataAPI} dataApi
	 * @param {String} address
	 * @param {String} data
	 * @param {Object} [sendConfig]
	 * @returns {DataSession}
	 */
	function xmppSend(dataApi, address, data, sendConfig) {
		var croc = dataApi.crocObject;
		var xmppCon = croc.xmppCon;

		if (!xmppCon) {
			throw new CrocSDK.Exceptions.StateError('XMPP not configured');
		}
		if (!xmppCon.connected()) {
			throw new CrocSDK.Exceptions.StateError('XMPP not connected');
		}

		// Check mandatory parameters
		if (!CrocSDK.Util.isType(address, 'string')) {
			throw new TypeError('Unexpected address:', address);
		}
		if (!CrocSDK.Util.isType(data, 'string') &&
				sendConfig.contentType !== CrocSDK.C.MT.XHTML) {
			throw new TypeError('Unexpected data:', data);
		}

		var dataSession = dataApi.xmppDataSessions[address];
		if (!dataSession || dataSession.getState() === 'closed') {
			// Create a new data session
			dataSession = new CrocSDK.XmppDataSession(dataApi, address);
			dataApi.xmppDataSessions[address] = dataSession;

			if (!dataApi.checkSessionsIntervalId) {
				dataApi.checkSessionsIntervalId = window.setInterval(
						function() {
							checkSessions(dataApi);
						}, 10000);
			}
		}

		if (sendConfig.contentType === CrocSDK.C.MT.XHTML) {
			dataSession.sendXHTML(data, sendConfig);
		} else {
			dataSession.send(data, sendConfig);
		}
		return dataSession;
	}

	/**
	 * Used to check sessions are being used. Any sessions that have been idle
	 * and exceed the idle timeout period; the session will be closed.
	 * 
	 * @private
	 * @param {CrocSDK.DataAPI} dataApi
	 */
	function checkSessions(dataApi) {
		var i = 0;
		var session;
		var idleThreshold = Date.now() - (dataApi.idleTimeout * 1000);
		var msrpSessions = dataApi.msrpDataSessions;
		var xmppSessions = dataApi.xmppDataSessions;
		var sipSessions = dataApi.sipDataSessions;
		var sessionsActive = false;

		while (i < msrpSessions.length) {
			session = msrpSessions[i];

			if (session._isIdle(idleThreshold)) {
				console.log('Closing idle session:', session);
				session.close();
			}

			if (session.getState() === 'closed') {
				// Remove current session
				msrpSessions.splice(i, 1);
				if (dataApi.reusableMsrpDataSessions[session.address] === session) {
					delete dataApi.reusableMsrpDataSessions[session.address];
				}
				// Repeat loop with same index (but shorter length)
			} else {
				// Move on to next index
				i++;
			}
		}

		var sessionMaps = [xmppSessions, sipSessions];
		for (i = 0; i < sessionMaps.length; i++) {
			var sessionMap = sessionMaps[i];
			for (var address in sessionMap) {
				session = sessionMap[address];

				if (session._isIdle(idleThreshold)) {
					console.log('Closing idle session:', session);
					session.close();
				}

				if (session.getState() === 'closed') {
					delete sessionMap[address];
				} else {
					sessionsActive = true;
				}
			}
		}

		if (msrpSessions.length < 1 && !sessionsActive) {
			window.clearInterval(dataApi.checkSessionsIntervalId);
			dataApi.checkSessionsIntervalId = null;
		}
	}

	/**
	 * Creates an MSRP connection object from the provided configuration.
	 * 
	 * @param {String}
	 *            msrpRelay The MSRP relay (DNS name or IP address).
	 * @param {CrocMSRP.ConnectionConfig}
	 *            msrpConfig The connection configuration object to use.
	 * @param {Boolean}
	 *            useTLS Set to <code>true</code> to use secure connections.
	 * @param {String}
	 *            apiKey The API key.
	 * @returns CrocMSRP.Connection
	 * @private
	 */
	function createMSRPConnection(msrpRelay, msrpConfig, useTLS, apiKey) {
		apiKey = apiKey || '';
		var wsUri = "ws://".concat(msrpRelay, '/', apiKey);
		var msrpUri = "msrp://".concat(msrpRelay, ";tcp");

		if (useTLS) {
			wsUri = wsUri.replace('ws:', 'wss:');
			msrpUri = msrpUri.replace('msrp:', 'msrps:');
		}

		return new CrocMSRP.Connection(wsUri, msrpUri, msrpConfig);
	}

	/**
	 * <p>
	 * The data features of the Crocodile RTC JavaScript Library allow a web-app
	 * to exchange data (for example, instant messages, files, or other
	 * arbitrary data) with other instances connected to the Crocodile RTC
	 * Network
	 * </p>
	 * 
	 * <p>
	 * Once the {@link CrocSDK.Croc Croc} Object is instantiated it will contain
	 * an instance of the {@link CrocSDK.DataAPI Data} object named <code>data</code>.
	 * </p>
	 * 
	 * <p>
	 * For example, given a {@link CrocSDK.Croc Croc} Object named
	 * <code>crocObject</code> the <code>Data.acceptTimeout</code> property
	 * would be accessed as <code>crocObject.data.acceptTimeout</code>
	 * </p>
	 * 
	 * <p>
	 * An example using the Data API:
	 *   <pre>
	 *   <code>
	 *   var crocObject = $.croc({
	 *     apiKey: "API_KEY_GOES_HERE",
	 *     onConnected: function () {
	 *       // Some code
	 *     },
	 *     
	 *     // General configuration
	 *     acceptTimeout: 300,   // Incoming sessions will be rejected if not accepted within this time (seconds)
	 *     
	 *     // Data API configuration
	 *     data: {
	 *       // Optional parameters
	 *       idleTimeout: 300,     // Idle sessions will be closed if not reused within this time (seconds)
	 *       
	 *       // Optional event handlers
	 *       onDataSession: function(event) {
	 *         // Handle incoming session
	 *         event.session.accept();
	 *       },
	 *       onData: function(event) {
	 *         // Handle incoming data (simple case, where SDK handles sessions)
	 *       }
	 *     }
	 *   });
	 *   
	 *   var dataSession = crocObject.data.send(address, data, config);
	 *   </code>
	 *   </pre>
	 * </p>
	 * 
	 * @constructor
	 * @memberof CrocSDK
	 * @param {CrocSDK.Croc} crocObject
	 * The parent {@link CrocSDK.Croc Croc} object.
	 * @param {CrocSDK~Config} config - The Croc object configuration.
	 */
	CrocSDK.DataAPI = function(crocObject, config) {
		this.crocObject = crocObject;
		config.jQuery.extend(this, config.data);

		this.nextMsrpConnection = 0;
		this.msrpConnections = [];
		this.checkSessionsIntervalId = null;
		this.reusableMsrpDataSessions = {};
		this.msrpDataSessions = [];
		this.xmppDataSessions = {};
		this.sipDataSessions = {};
		this.initMsrp(config);
	};

	/**
	 * Used to create message events for JsSIP. This event is wrapped in the
	 * onData event of the SDK.
	 * 
	 * @private
	 * @fires CrocSDK.DataAPI#onData
	 */
	CrocSDK.DataAPI.prototype.init = function() {
		var croc = this.crocObject;
		var xmppCon = croc.xmppCon;

		if (croc.features.indexOf(CrocSDK.C.FEATURES.PAGEDATA) >= 0) {
			// Handle SIP MESSAGE requests
			croc.sipUA.on('newMessage', this._handleSipMessage.bind(this));
		}

		if (xmppCon) {
			// Process incoming XMPP message stanzas
			xmppCon.registerHandler('message', '*', '*', 'error',
					this._handleXmppMessageError.bind(this));
			xmppCon.registerHandler('message', this._handleXmppMessage.bind(this));
		}
	};

	/**
	 * Initialise the MSRP connection(s).
	 * 
	 * @private
	 * @param config The configuration to use.
	 * @param {string} username The ephemeral username to use.
	 * @param {string} password The ephemeral password to use.
	 */
	CrocSDK.DataAPI.prototype.initMsrp = function(config, username, password) {
		var i, len;
		var msrpConfig = {
			// Prefer the ephemeral credentials if provided
			username : (username || config.authorizationUser || config.address),
			password : (password || config.password)
		};

		var msrpConns = this.msrpConnections;
		if (msrpConns.length === 0) {
			// Set up the connection objects
			// This should only happen once; adding relays without restarting
			// is not supported.
			var msrpRelaySet = config.msrpRelaySet || [];
			if (CrocSDK.Util.isType(msrpRelaySet, "string")) {
				msrpRelaySet = [ msrpRelaySet ];
			}

			for (i = 0, len = msrpRelaySet.length; i < len; i++) {
				msrpConns.push(createMSRPConnection(msrpRelaySet[i], msrpConfig,
						config.useTLS, config.apiKey));
			}
		} else {
			// We've already set up the connections, but we can update the
			// ephemeral credentials when necessary.
			for (i = 0, len = msrpConns.length; i < len; i++) {
				var connConfig = msrpConns[i].config;
				connConfig.username = msrpConfig.username;
				connConfig.password = msrpConfig.password;
			}
		}
	};

	/**
	 * Used to create a new CrocSDK.IncomingMsrpSession class.
	 * 
	 * @private
	 * @param sipSession
	 * @param sipRequest
	 * @param mLine
	 * @param sdpValid
	 * @param sdpInvalid
	 * @fires {CrocSDK.DataAPI#onDataSession} onDataSession
	 */
	CrocSDK.DataAPI.prototype.init_incoming = function(sipSession, sipRequest, mLine, sdpValid, sdpInvalid) {
		if (this.hasOwnProperty('onDataSession')) {
			var session = new CrocSDK.IncomingMsrpSession(this, sipSession, sipRequest);

			if (!this.checkSessionsIntervalId) {
				var dataApi = this;
				this.checkSessionsIntervalId = window.setInterval(function() {
					checkSessions(dataApi);
				}, 10000);
			}

			this.msrpDataSessions.push(session);

			var fileTransferInfo = null;
			var fileParams = mLine.parseFileAttributes();
			if (fileParams) {
				fileTransferInfo = {
					name : fileParams.selector.name,
					description : fileParams.description,
					disposition : fileParams.disposition,
					size : fileParams.selector.size
				};
			}

			// We're happy with the SDP, send provisional response now
			sdpValid();

			if (session.customHeaders.isEmpty() && !fileTransferInfo) {
				// Add it as a reusable session for this address
				this.reusableMsrpDataSessions[session.address] = session;
			}

			CrocSDK.Util.fireEvent(this, 'onDataSession', {
				session : session,
				fileTransfer : fileTransferInfo
			});
		} else {
			// If this handler is not defined, we reject incoming data sessions
			sdpInvalid();
		}
	};

	/**
	 * Handles incoming SIP MESSAGE requests.
	 * 
	 * @private
	 * @param event - The JsSIP "newMessage" event
	 */
	CrocSDK.DataAPI.prototype._handleSipMessage = function (event) {
		if (event.data.originator !== 'remote') {
			return;
		}

		var request = event.data.request;
		var address = request.parseHeader('from', 0).uri.toAor().replace(/^sip:/, '');
		var contentType = request.headers['Content-Type'][0].parsed;
		var dataSession = this.sipDataSessions[address];
		var parsedContactHeader = request.parseHeader('contact', 0);
		var caps = null;
		if (parsedContactHeader) {
			caps = this.crocObject.capability.parseFeatureTags(
					parsedContactHeader.parameters);
		}
		var displayName = request.from.display_name;

		if (!dataSession || dataSession.getState() === 'closed') {
			// Create a new data session
			dataSession = new CrocSDK.SipDataSession(this, address);
			this.sipDataSessions[address] = dataSession;

			// Set the new session properties
			dataSession.capabilities = caps;
			dataSession.customHeaders = new CrocSDK.CustomHeaders(request);
			dataSession.displayName = displayName;

			if (!this.checkSessionsIntervalId) {
				var dataApi = this;
				this.checkSessionsIntervalId = window.setInterval(function() {
					checkSessions(dataApi);
				}, 10000);
			}

			// If the session is immediately closed, reject the message.
			// Do this by setting a temporary close() method, overriding the
			// prototype method.
			var rejected = false;
			dataSession.close = function () {
				rejected = true;
			};

			CrocSDK.Util.fireEvent(this, 'onDataSession', {
				session: dataSession,
				fileTransfer: null
			});

			// Remove the temporary close method
			delete dataSession.close;

			if (rejected) {
				event.data.message.reject();
				// Call the real close method
				dataSession.close();
				return;
			} else {
				event.data.message.accept();
			}
		} else {
			// Update session properties
			dataSession.capabilities = caps;
			dataSession.customHeaders = new CrocSDK.CustomHeaders(request);
			dataSession.displayName = displayName;
		}

		// Let the session handle the rest
		dataSession._receiveMessage(address, contentType, request.body);
	};

	/**
	 * Handles incoming XMPP message stanzas.
	 * 
	 * @private
	 * @param {JSJaCMessage} message
	 * @returns {boolean} 'true' to prevent bubbling of the event
	 */
	CrocSDK.DataAPI.prototype._handleXmppMessage = function (message) {
		var instanceAddress = message.getFrom();
		var address = message.getFromJID().getBareJID();
		var dataSession = this.xmppDataSessions[address];

		if (!dataSession || dataSession.getState() === 'closed') {
			// Create a new data session
			dataSession = new CrocSDK.XmppDataSession(this, address, instanceAddress);
			this.xmppDataSessions[address] = dataSession;

			if (!this.checkSessionsIntervalId) {
				var dataApi = this;
				this.checkSessionsIntervalId = window.setInterval(function() {
					checkSessions(dataApi);
				}, 10000);
			}

			CrocSDK.Util.fireEvent(this, 'onDataSession', {
				session: dataSession,
				fileTransfer: null
			});
		}

		// Let the session handle the rest
		dataSession._receiveMessage(message);
		return true;
	};

	/**
	 * Handles incoming XMPP message stanzas where type='error'.
	 * 
	 * @private
	 * @param {JSJaCMessage} message
	 * @returns {boolean} 'true' to prevent bubbling of the event
	 */
	CrocSDK.DataAPI.prototype._handleXmppMessageError = function (message) {
		var address = message.getFromJID().getBareJID();
		var dataSession = this.xmppDataSessions[address];

		if (dataSession && dataSession.getState() !== 'closed') {
			// Let the session handle the rest
			dataSession._receiveMessageError(message);
		} else {
			console.log('Unhandled XMPP error: ', message.xml());
		}

		return true;
	};

	/*
	 * Public methods
	 */

	/**
	 * Send <code>data</code> to <code>address</code>.
	 * <p>
	 * Returns the session used for the send.  This can be ignored if you want
	 * to let the SDK handle session management.
	 * 
	 * @memberof CrocSDK.DataAPI
	 * @param {String|JsSIP.URI} address
	 * The target address for this data.
	 * <p>
	 * A client instance's unique address may be used if you wish to target only
	 * that instance, but this is an advanced feature: it is only designed to
	 * work for MSRP data sessions, and relies on the application to handle
	 * session management.
	 * @param {ArrayBuffer|Blob|File|String} data
	 * The data to send.  This can be string/binary data, or an entire file.
	 * @param {CrocSDK.DataAPI~SendConfig} [sendConfig]
	 * Optional extra configuration that can be provided when sending data. If
	 * this object is omitted, the defaults will be used.
	 * @returns {CrocSDK.MsrpDataSession} DataSession
	 * @throws {TypeError}
	 * @throws {CrocSDK.Exceptions#ValueError}
	 * @throws {CrocSDK.Exceptions#VersionError}
	 * @throws {CrocSDK.Exceptions#StateError}
	 */
	CrocSDK.DataAPI.prototype.send = function(address, data, sendConfig) {
		sendConfig = sendConfig || {};
		CrocSDK.Util.checkSendConfig(sendConfig);

		// Use appropriate session type if specified
		if (!sendConfig.type) {
			// TODO: make intelligent selection of default transport
			sendConfig.type = 'page';
		}

		switch (sendConfig.type) {
		case 'msrp':
			return msrpSend(this, address, data, sendConfig);
		case 'page':
			return pageSend(this, address, data, sendConfig);
		case 'xmpp':
			return xmppSend(this, address, data, sendConfig);
		default:
			throw new CrocSDK.Exceptions.ValueError(
					"Invalid type value");
		}
	};

	/**
	 * Send the provided XHTML <code>body</code> to <code>address</code>.
	 * <p>
	 * Returns the session used for the send.  This can be ignored if you want
	 * to let the SDK handle session management.
	 * 
	 * @memberof CrocSDK.DataAPI
	 * @param {string} address - The destination address.
	 * @param {DocumentFragment|string} body - The body of the message.
	 * @param {CrocSDK.DataAPI~SendConfig} [sendConfig] - Optional extra
	 * configuration that can be provided when sending data.  If this object is
	 * omitted, the defaults will be used.
	 * @returns {CrocSDK.MsrpDataSession} DataSession
	 * @throws {TypeError}
	 * @throws {CrocSDK.Exceptions#ValueError}
	 * @throws {CrocSDK.Exceptions#VersionError}
	 * @throws {CrocSDK.Exceptions#StateError}
	 */
	CrocSDK.DataAPI.prototype.sendXHTML = function(address, body, sendConfig) {
		var xhtml;

		sendConfig = sendConfig || {};
		CrocSDK.Util.checkSendConfig(sendConfig);

		// Use appropriate session type if specified
		if (!sendConfig.type) {
			// TODO: make intelligent selection of default transport
			sendConfig.type = 'page';
		}

		sendConfig.contentType = CrocSDK.C.MT.XHTML;
		if (sendConfig.type !== 'xmpp') {
			xhtml = CrocSDK.Util.createValidXHTMLDoc(body);
		}

		switch (sendConfig.type) {
		case 'msrp':
			return msrpSend(this, address, xhtml, sendConfig);
		case 'page':
			return pageSend(this, address, xhtml, sendConfig);
		case 'xmpp':
			// XMPP is handled differently; just pass through what we've been given
			return xmppSend(this, address, body, sendConfig);
		default:
			throw new CrocSDK.Exceptions.ValueError(
					"Invalid type value");
		}
	};

	/**
	 * <p>
	 * Explicitly close all current data sessions. You should not need to call
	 * this as sessions will automatically be closed, reused, and timed-out by
	 * the Crocodile RTC JavaScript Library.
	 * </p>
	 * 
	 * <p>
	 * Data transfers in progress will be aborted when this method is called.
	 * </p>
	 * 
	 * @memberof CrocSDK.DataAPI
	 */
	CrocSDK.DataAPI.prototype.close = function() {
		var address = null;
		// Close down all MSRP data sessions
		for (var i = 0, len = this.msrpDataSessions.length; i < len; i++) {
			this.msrpDataSessions[i].close();
		}
		// Close down all SIP data sessions
		for (address in this.sipDataSessions) {
			this.sipDataSessions[address].close();
		}
		// Note: XMPP is tied to presence.stop() instead.
	};

	/**
	 * <p>
	 * Dispatched when Crocodile RTC JavaScript Library receives a request for a
	 * new session from another party on the Crocodile RTC Network.
	 * </p>
	 * 
	 * <p>
	 * An instance of Crocodile RTC JavaScript Library cannot receive inbound
	 * sessions unless the {@link CrocSDK.Croc#register register} property was
	 * set to <code>true</code> when the {@link CrocSDK.Croc Croc} Object was
	 * instantiated.
	 * </p>
	 * 
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * automatically reject inbound sessions.
	 * </p>
	 * 
	 * @memberof CrocSDK.DataAPI
	 * @event CrocSDK.DataAPI#onDataSession
	 * @param {CrocSDK.DataAPI~DataSessionEvent}
	 *            [onDataSessionEvent] The event object assocated with this
	 *            event.
	 */
	CrocSDK.DataAPI.prototype.onDataSession = function() {
		// Do nothing
	};

	/**
	 * Dispatched when data is received on a
	 * {@link CrocSDK.MsrpDataSession DataSession} that does not
	 * have an <code>onData</code> handler.
	 * <p>
	 * This event is generated once per call to <code>send()</code> by the
	 * remote party.
	 * <p>
	 * If you need to get progress updates during large transfers, you must add
	 * an event handler for the <code>onDataStart</code> event of the
	 * {@link CrocSDK.MsrpDataSession DataSession} object to get
	 * access to the associated
	 * {@link CrocSDK.MsrpDataSession~TransferProgress TransferProgress}
	 * object instance.
	 * <p>
	 * If this event is not handled the received data will be discarded.
	 * 
	 * @memberof CrocSDK.DataAPI
	 * @event CrocSDK.DataAPI#onData
	 * @param {CrocSDK.DataAPI~DataEvent}
	 *            [event] The event object assocated with this event.
	 */
	CrocSDK.DataAPI.prototype.onData = function() {
		// Do nothing
	};

	/**
	 * Dispatched when an XHTML body (rich text) is received on a
	 * {@link CrocSDK.MsrpDataSession DataSession} that does not
	 * have an <code>onXHTMLReceived</code> handler.
	 * <p>
	 * This event is generated once per call to <code>sendXHTML()</code> by the
	 * remote party.
	 * <p>
	 * If this event is not handled the received data will be discarded.
	 * 
	 * @memberof CrocSDK.DataAPI
	 * @event CrocSDK.DataAPI#onXHTMLReceived
	 * @param {CrocSDK.DataAPI~XHTMLReceivedEvent} [event] The event object
	 * assocated with this event.
	 */

	/* Further Documentation */
	// Members
	/**
	 * @memberof CrocSDK.DataAPI
	 * @member {Number} idleTimeout
	 * @instance
	 */

	// Type Definitions
	/**
	 * @memberof CrocSDK.DataAPI
	 * @typedef CrocSDK.DataAPI~SendConfig
	 * @property {String} type
	 *           <p>
	 *           Forces the Crocodile RTC JavaScript Library to use the
	 *           specified type of data connection. Valid types are
	 *           <code>msrp</code> or <code>page</code>.
	 *           </p>
	 * 
	 * <p>
	 * <code>msrp</code> is session-based and best-suited for large data
	 * transfers, but sessions take time to establish. <code>page</code> data
	 * requires no session establishment but is only suitable for small,
	 * infrequent chunks.
	 * </p>
	 * 
	 * <p>
	 * If <code>type</code> is not specified the Crocodile RTC JavaScript
	 * Library will automatically choose the best mechanism based on the
	 * capabilities cached for the remote party.
	 * </p>
	 * 
	 * <p>
	 * This property is ignored by the
	 * {@link CrocSDK.MsrpDataSession~DataSession#send DataSession.send()} as it
	 * is only relevant when establishing new sessions/transfers.
	 * </p>
	 * @property {CrocSDK~CustomHeaders} customHeaders
	 *           <p>
	 *           This enables the web-app to specify custom headers that will be
	 *           included in the session creation request. The key names
	 *           provided will be used as the header names and the associated
	 *           String values will be used as the header values.
	 *           </p>
	 * 
	 * <p>
	 * All custom header keys <i>MUST</i> start with &#34;X-&#34;. Keys that do
	 * not start &#34;X-&#34; will be ignored.
	 * </p>
	 * 
	 * <p>
	 * These custom headers will be available to the local and remote party in
	 * the
	 * {@link CrocSDK.MsrpDataSession#customHeaders DataSession.customHeaders}
	 * property.
	 * </p>
	 * 
	 * <p>
	 * This property is ignored by the
	 * {@link CrocSDK.MsrpDataSession#send DataSession.send()} as it
	 * is only relevant when establishing new sessions/transfers.
	 * </p>
	 * @property {String} contentType The MIME type for the data transfer. This
	 *           may be determined automatically when transferring Blob or File
	 *           objects.
	 * @property {CrocSDK.DataAPI~FileTransferInfo} fileTransfer Details of the
	 *           file to be sent (in the case that the data transfer is a file
	 *           transfer). Some of these details may be determined
	 *           automatically for Blob or File objects.
	 * @property {CrocSDK.MsrpDataSession~TransferProgress#event:onSuccess} onSuccess
	 * <p>
	 * Dispatched when the data transfer has completed successfully.
	 * </p>
	 * 
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * continue on without error.
	 * </p>
	 * @property {CrocSDK.MsrpDataSession~TransferProgress#event:onFailure} onFailure
	 * <p>
	 * Dispatched when the data transfer has been aborted (either locally or
	 * remotely).
	 * </p>
	 * 
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * continue on without error.
	 * </p>
	 * @property {CrocSDK.MsrpDataSession~TransferProgress#event:onProgress} onProgress
	 * <p>
	 * Dispatched when a chunk of data has been sent.
	 * </p>
	 * 
	 * <p>
	 * The event handler can call <code>this.abort()</code> to abort the
	 * remainder of the file transfer.
	 * </p>
	 * 
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * continue on without error.
	 * </p> 
	 */

	/**
	 * @memberof CrocSDK.DataAPI
	 * @typedef CrocSDK.DataAPI~DataEvent
	 * @property {String} address The address of the user that sent the data.
	 * @property {String} contentType The MIME type of the data.
	 * @property {ArrayBuffer|Blob|String} data The received data. Text data
	 *           will be presented as String. Binary data will be presented as
	 *           ArrayBuffer or Blob, depending on the size of the data.
	 */

	/**
	 * @memberof CrocSDK.DataAPI
	 * @typedef CrocSDK.DataAPI~XHTMLReceivedEvent
	 * @property {String} address The address of the user that sent the data.
	 * @property {DocumentFragment} body - The received body.
	 * @see http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-B63ED1A3
	 */

	/**
	 * @memberof CrocSDK.DataAPI
	 * @typedef CrocSDK.DataAPI~DataSessionEvent
	 * @property {CrocSDK.MsrpDataSession} session The DataSession
	 *           representing the inbound session.
	 * @property {CrocSDK.DataAPI~FileTransferInfo} fileTransfer Details of the
	 *           file to be transfered (where provided in the
	 *           {@link CrocSDK.DataAPI#send Data.send()} by the remote party).
	 *           If file details are not provided (for example, this is an
	 *           instant messaging session) this property will be
	 *           <code>null</code>.
	 */

	/**
	 * All of these properties will be <code>null</code> if not provided.
	 * 
	 * @memberof CrocSDK.DataAPI
	 * @typedef CrocSDK.DataAPI~FileTransferInfo
	 * @property {String} name The name of the file.
	 * @property {String} description The description of the file.
	 * @property {String} disposition The disposition of the file.
	 * @property {Number} size The size of the file (in bytes).
	 */

}(CrocSDK));

(function(CrocSDK) {

	/**
	 * @namespace
	 */
	CrocSDK.Exceptions = {};

	/**
	 * Base exception object.
	 * @constructor Error
	 * @property {String} name
	 * The exception name.
	 * @property {String} message
	 * The message provided when the exception was created.
	 * @property {String} stack
	 * The execution stack at the time the exception was created.
	 */

	/**
	 * This exception indicates that a parameter supplied to a method had an
	 * unexpected value.
	 * 
	 * @constructor
	 * @alias CrocSDK.Exceptions.ValueError
	 * @extends Error
	 * @param {String} [message] The message to display.
	 */
	var ValueError = function(message) {
		var err = new Error();
		if (err.stack) {
			this.stack = err.stack;
		}
		this.message = message || "Unexpected value error";
	};
	ValueError.prototype = new Error();
	ValueError.prototype.constructor = ValueError;
	ValueError.prototype.name = 'ValueError';

	/**
	 * This exception indicates that a method was called at an inappropriate
	 * time. For example, calling the <code>accept()</code> method on a
	 * {@link CrocSDK.MsrpDataSession DataSession} object where the
	 * inbound session has already been accepted would result in this exception
	 * being raised.
	 * 
	 * @constructor
	 * @alias CrocSDK.Exceptions.StateError
	 * @extends Error
	 * @param {String} [message] The message to display.
	 */
	var StateError = function(message) {
		var err = new Error();
		if (err.stack) {
			this.stack = err.stack;
		}
		this.message = message || "Unexpected state error";
	};
	StateError.prototype = new Error();
	StateError.prototype.constructor = StateError;
	StateError.prototype.name = 'StateError';

	/**
	 * This exception indicates that the Crocodile RTC JavaScript Library
	 * versions of the local and remote parties do not match.
	 * 
	 * @constructor
	 * @alias CrocSDK.Exceptions.VersionError
	 * @extends Error
	 * @param {String} [message] The message to display.
	 */
	var VersionError = function(message) {
		var err = new Error();
		if (err.stack) {
			this.stack = err.stack;
		}
		this.message = message || "Version error";
	};
	VersionError.prototype = new Error();
	VersionError.prototype.constructor = VersionError;
	VersionError.prototype.name = 'VersionError';

	/**
	 * This exception indicates that a method was called at an inappropriate
	 * time. For example, calling the <code>accept()</code> method on a
	 * {@link CrocSDK.MsrpDataSession DataSession} object where the
	 * inbound session has already been accepted would result in this exception
	 * being raised.
	 * 
	 * @constructor
	 * @alias CrocSDK.Exceptions.UnsupportedError
	 * @extends Error
	 * @param {String} [message] The message to display.
	 */
	var UnsupportedError = function(message) {
		var err = new Error();
		if (err.stack) {
			this.stack = err.stack;
		}
		this.message = message || "Unsupported error";
	};
	UnsupportedError.prototype = new Error();
	UnsupportedError.prototype.constructor = UnsupportedError;
	UnsupportedError.prototype.name = 'UnsupportedError';

	CrocSDK.Exceptions.ValueError = ValueError;
	CrocSDK.Exceptions.StateError = StateError;
	CrocSDK.Exceptions.VersionError = VersionError;
	CrocSDK.Exceptions.UnsupportedError = UnsupportedError;
}(CrocSDK));

(function(CrocSDK) {
	/**
	 * The media features of the Crocodile RTC JavaScript Library allow a
	 * web-app to exchange media (for example, audio or video streams) with
	 * other instances connected to the Crocodile RTC Network.
	 * <p>
	 * Once the {@link CrocSDK.Croc Croc} Object is instantiated it will contain
	 * an instance of the {@link CrocSDK.MediaAPI Media} object named
	 * <code>media</code>.
	 * <p>
	 * For example, given a {@link CrocSDK.Croc Croc} Object named
	 * <code>crocObject</code> the <code>Media.connect</code> method would
	 * be accessed as <code>crocObject.media.connect</code>.
	 * <p>
	 * An example using the Media API: 
	 *   <pre>
	 *   <code>
	 *   // Basic API configuration
	 *   var crocObject = $.croc({
	 *     apiKey: "API_KEY_GOES_HERE",
	 *     onConnected: function () {
	 *       // Some code
	 *     },
	 *   
	 *     // General configuration
	 *     acceptTimeout: 30,   // Incoming sessions will be rejected if not accepted within this time (seconds)
	 *     
	 *     // Media API configuration
	 *     media: {
	 *       // Optional event handlers
	 *       onMediaSession: function(event) {
	 *         // Handle new incoming session
	 *       }
	 *     }
	 *   });
	 *   
	 *   // Basic audio session set-up example
	 *   function startCall(address) {
	 *     var session = crocObject.media.connect(address);
	 *     session.remoteAudioElement = $('#audio');
	 *     session.onProvisional = function (event) {
	 *     $('#state').html('Ringing');
	 *     };
	 *     session.onConnect = function (event) {
	 *       $('#state').html('Connected');
	 *     };
	 *     session.onClose = function (event) {
	 *       $('#state').html('Disconnected');
	 *     };
	 *   }
	 *   </code>
	 *   </pre>
	 * 
	 * @constructor
	 * @alias CrocSDK.MediaAPI
	 * @param {CrocSDK.Croc} crocObject - The parent {@link CrocSDK.Croc Croc}
	 * object.
	 * @param {CrocSDK~Config} config - The Croc object configuration.
	 */
	var MediaAPI = function(crocObject, config) {
		this.crocObject = crocObject;
		this.mediaSessions = [];
		config.jQuery.extend(this, config.media);
	};

	MediaAPI.prototype.init = function() {
		var croc = this.crocObject;
		if (croc.features.indexOf(CrocSDK.C.FEATURES.TRANSFER) >= 0) {
			croc.sipUA.on('newRefer', this._handleRefer.bind(this));
		}
	};

	/**
	 * Process an incoming request to establish a media session.
	 * 
	 * @private
	 * @param sipSession
	 * @param sipRequest
	 * @param sdp
	 * @param sdpValid
	 * @param sdpInvalid
	 * @fires onMediaSession
	 */
	MediaAPI.prototype.init_incoming = function(sipSession, sipRequest,
			sdp, sdpValid, sdpInvalid) {
		if (this.hasOwnProperty('onMediaSession')) {
			var mediaApi = this;
			var crocObject = this.crocObject;
			var capabilityApi = crocObject.capability;
			var address = sipSession.remote_identity.uri.toAor().replace(
					/^sip:/, '');
			var mediaSession = new CrocSDK.MediaSession(this, sipSession, address);

			// Process the sdp offer - this should kick off the ICE agent
			var onSuccess = function() {
				console.log('Remote offer set');
				sdpValid();

				CrocSDK.Util.fireEvent(mediaApi, 'onMediaSession', {
					session : mediaSession
				});
			};
			var onFailure = function(error) {
				console.warn('setRemoteDescription failed:', error);
				sdpInvalid();
				mediaSession.close();
			};
			mediaSession._handleInitialInvite(sipRequest.body, sdp, onSuccess, onFailure);

			// Set MediaSession properties
			mediaSession.displayName = sipSession.remote_identity.display_name;
			mediaSession.customHeaders = new CrocSDK.CustomHeaders(sipRequest);
			// Process remote capabilities
			var parsedContactHeader = sipRequest.parseHeader('contact', 0);
			mediaSession.capabilities = capabilityApi
					.parseFeatureTags(parsedContactHeader.parameters);

			this.mediaSessions.push(mediaSession);

			if (crocObject.requireMatchingVersion && (mediaSession.capabilities['croc.sdkversion'] !== crocObject.capabilities['croc.sdkversion'])) {
				console.log('Remote client SDK version does not match');
				sdpInvalid();
				mediaSession.close();
			}
		} else {
			// If this handler is not defined, we reject incoming data sessions
			sdpInvalid();
		}
	};

	/**
	 * @private
	 */
	MediaAPI.prototype._updateIceServers = function() {
		var croc = this.crocObject;
		var iceServers = croc.iceServers;
		if (croc.dynamicIceServers) {
			// Put the managed TURN servers first in the list, but still include
			// any other configured STUN/TURN servers.
			iceServers = croc.dynamicIceServers.concat(iceServers);
		}

		for ( var i = 0, len = this.mediaSessions.length; i < len; i++) {
			this.mediaSessions[i]._updateIceServers(iceServers);
		}
	};

	/**
	 * Handles the JsSIP <code>newRefer</code> event.
	 * @private
	 * @param {Object} event - The JsSIP event object.
	 */
	MediaAPI.prototype._handleRefer = function(event) {
		var data = event.data;
		if (data.originator !== 'remote') {
			return;
		}

		// Check the refer had a known target session
		var referredSession = data.session;
		if (!referredSession) {
			data.refer.reject({
				status_code: 403,
				reason_phrase: 'Missing Target-Session Header'
			});
			return;
		}

		// Check that the refer is to a SIP URI
		if (data.refer.refer_uri.scheme !== JsSIP.C.SIP) {
			data.refer.reject({
				status_code: 416,
				reason_phrase: 'Unsupported Refer URI Scheme'
			});
		}

		// Find the target session
		var mediaSessions = this.mediaSessions;
		var mediaSession = null;
		for (var idx = 0, len = mediaSessions.length; idx < len; idx++) {
			mediaSession = mediaSessions[idx];
			if (mediaSession.sipSession === referredSession) {
				mediaSession._handleRefer(data.refer);
				return;
			}
		}

		// Could not find the target session
		data.refer.reject({
			status_code: 481,
			reason_phrase: 'Target Session Does Not Exist'
		});
	};

	/*
	 * Public methods
	 */

	/**
	 * Initiate a media session to <code>address</code>. Defaults to a
	 * bi-directional audio session unless specified otherwise using the
	 * <code>config</code> parameter.
	 * <p>
	 * Returns a {@link CrocSDK.MediaAPI~MediaSession MediaSession} object which
	 * the required event handlers should be registered with immediately to
	 * avoid missing events.
	 * 
	 * @param {String} address - The target address for the media session.
	 * @param {CrocSDK.MediaAPI~ConnectConfig} [connectConfig]
	 * Optional configuration properties.
	 * @returns CrocSDK.MediaAPI~MediaSession
	 * @throws {TypeError}
	 * @throws {CrocSDK.Exceptions#ValueError}
	 * @throws {CrocSDK.Exceptions#VersionError}
	 * @throws {CrocSDK.Exceptions#StateError}
	 */
	MediaAPI.prototype.connect = function(address, connectConfig) {
		var crocObject = this.crocObject;
		var capabilityApi = crocObject.capability;
		var sipSession = new JsSIP.RTCSession(crocObject.sipUA);
		var watchData = capabilityApi.getWatchData(address);

		if (!connectConfig) {
			connectConfig = {};
		}

		// Disable DTLS by default until network supports it
		var constraints = connectConfig.constraints || {};
		if (!constraints.mandatory) {
			constraints.mandatory = {};
		}
		constraints.mandatory.DtlsSrtpKeyAgreement = false;

		// Force DTLS-SRTP if Chrome is calling Firefox.
		// We don't turn this on by default to avoid problems with Asterisk.
		if (watchData) {
			if (/Chrome/.test(navigator.userAgent) &&
					/Firefox/.test(watchData.userAgent)) {
				constraints.mandatory.DtlsSrtpKeyAgreement = true;
				console.log('Enabling DTLS for Firefox compatibility');
			}
		}

		var mediaSession = new CrocSDK.MediaSession(this, sipSession, address, constraints);

		// Set MediaSession properties
		mediaSession.customHeaders = new CrocSDK.CustomHeaders(connectConfig.customHeaders);
		// Start with cached capabilities if we have them
		mediaSession.capabilities = watchData ? watchData.capabilities : null;
		mediaSession.streamConfig = connectConfig.streamConfig || new CrocSDK.StreamConfig();

		mediaSession._connect();

		this.mediaSessions.push(mediaSession);
		return mediaSession;
	};

	/**
	 * Closes all current media sessions.
	 */
	MediaAPI.prototype.close = function() {
		for ( var i = 0, len = this.mediaSessions.length; i < len; i++) {
			this.mediaSessions[i].close();
		}
	};

	/* Further Documentation in JSDoc */

	// Documented Type Definitions

	/**
	 * @typedef CrocSDK.MediaAPI~ConnectConfig
	 * @property {CrocSDK~CustomHeaders} customHeaders
	 * Custom headers that to include in the session creation request.
	 * <p>
	 * These custom headers will be available to the local and remote party in
	 * the
	 * {@link CrocSDK.MediaAPI~MediaSession#customHeaders MediaSession.customHeaders}
	 * property and to the remote party in the
	 * {@link CrocSDK.MediaAPI~MediaSession~RenegotiateRequestEvent RenegotiateRequestEvent.customHeaders}
	 * property during session renegotiation.
	 * @property {CrocSDK.MediaAPI~StreamConfig} streamConfig The media stream
	 *           configuration.
	 */

	/**
	 * @typedef CrocSDK.MediaAPI~MediaSessionEvent
	 * @property {CrocSDK.MediaAPI~MediaSession} session
	 * The MediaSession object representing the inbound session.
	 */

	// Documented Events

	/**
	 * Dispatched when Crocodile RTC JavaScript Library receives a request 
	 * for a new session from another party on the Crocodile RTC Network.
	 * <p>
	 * An instance of Crocodile RTC JavaScript Library cannot receive inbound
	 * sessions unless the <code>register</code> property was set to
	 * <code>true</code> when the {@link CrocSDK.Croc Croc} Object was
	 * instantiated.
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * automatically reject inbound sessions.
	 * 
	 * @event CrocSDK.MediaAPI#onMediaSession
	 * @param {CrocSDK.MediaAPI~MediaSessionEvent}
	 * [event] The event object associated with this event.
	 */

	CrocSDK.MediaAPI = MediaAPI;
}(CrocSDK));

(function(CrocSDK) {
	var mediaSessionState = {
		PENDING : 'pending',
		ESTABLISHED : 'established',
		CLOSED : 'closed'
	};

	function fixLocalDescription(sessionDescription, streamConfig) {
		var parsedSdp = new CrocSDK.Sdp.Session(sessionDescription.sdp);
		var directions = [ 'sendrecv', 'sendonly', 'recvonly', 'inactive' ];
		var oldDirection, newDirection;
		var sdpChanged = false;

		for ( var index in parsedSdp.media) {
			var mLine = parsedSdp.media[index];
			var config = streamConfig[mLine.media];

			if (mLine.media === 'application') {
				// Don't modify the DataChannel stream
				continue;
			}

			if (!config) {
				// Don't want this stream at all
				mLine.port = 0;
				sdpChanged = true;
			} else {
				// Find the existing direction attribute
				oldDirection = null;
				for ( var i in directions) {
					if (mLine.attributes[directions[i]]) {
						oldDirection = directions[i];
					}
				}
				if (oldDirection === null) {
					// Implicit sendrecv, make it explicit
					oldDirection = 'sendrecv';
					mLine.addAttribute(oldDirection, null);
					sdpChanged = true;
				}

				// Decide new direction
				if (config.send) {
					if (config.receive) {
						newDirection = 'sendrecv';
					} else {
						newDirection = 'sendonly';
					}
				} else {
					if (config.receive) {
						newDirection = 'recvonly';
					} else {
						newDirection = 'inactive';
					}
				}

				if (oldDirection !== newDirection) {
					mLine.replaceAttribute(oldDirection, newDirection, null);
					sdpChanged = true;
				}
			}
		}

		if (sdpChanged) {
			sessionDescription.sdp = parsedSdp.toString();
		}
	}

	function awaitIceCompletion(pc, onComplete) {
		// Firefox 20 never calls this - ICE completion is done before
		// createOffer/createAnswer returns. Chrome 26-28 don't call
		// onicecandidate with a null candidate if using a TURN
		// server and more than 10 candidates are collected:
		// https://code.google.com/p/webrtc/issues/detail?id=1680

		// To work around this, we set up a timer that is reset with each
		// candidate, and will proceed if it fires.
		var startTime = Date.now();
		var timerId = null;
		var complete = false;
		var proceed = function() {
			console.log('Proceeding without null candidate!', Date.now() - startTime);
			complete = true;
			timerId = null;
			onComplete();
		};
		var m = navigator.userAgent.match(/Chrome\/([0-9]*)/);
		if (m && parseInt(m[1], 10) < 29) {
			// Bugged version - start the proceed timer
			timerId = setTimeout(proceed, 5000);
		}

		pc.onicecandidate = function(event) {
			console.log('onicecandidate', Date.now() - startTime, event.candidate,
					this.iceGatheringState, this.iceConnectionState);
			if (timerId) {
				clearTimeout(timerId);
			}

			if (event.candidate) {
				if (timerId) {
					// Reset timer
					timerId = setTimeout(proceed, 5000);
				}
			} else {
				// ICE candidate collection complete
				this.onicecandidate = null;
				if (!complete) {
					onComplete();
				}
			}
		};
	}

	function configureRemoteMediaDetection(mediaSession) {
		var fireEvent = function() {
			// Make sure we only fire the event once
			if (mediaSession.remoteMediaReceived) {
				return;
			}
			mediaSession.remoteMediaReceived = true;
			// Decouple event from this thread, in case we have not yet handed
			// the media session to the higher-level app.
			setTimeout(function() {
				CrocSDK.Util.fireEvent(mediaSession, 'onRemoteMediaReceived', {});
			}, 0);
		};

		var checkTrackLive = function(track) {
			if (track.readyState === 'live') {
				// Fire event now
				fireEvent();
			} else {
				// Wait for the track to unmute
				track.onunmute = fireEvent;
			}
		};

		// Wait for onaddstream event, which should fire when the remote
		// session description has been provided.
		mediaSession.peerConnection.onaddstream = function(event) {
			if (mediaSession.remoteMediaReceived) {
				return;
			}

			// We only expect one stream, with a maximum of one audio track
			// and/or one video track
			var stream = event.stream;
			var audioTracks = stream.getAudioTracks();
			var videoTracks = stream.getVideoTracks();

			if (audioTracks.length > 0) {
				checkTrackLive(audioTracks[0]);
			}
			if (videoTracks.length > 0) {
				checkTrackLive(videoTracks[0]);
			}
		};
	}

	function configurePeerConnectionDebug(pc) {
		var onSigStateChange = function() {
			console.log('PC: signalling state change:', this.signalingState);
		};
		// Official event, according to latest spec
		if ('onsignalingstatechange' in pc) {
			pc.onsignalingstatechange = onSigStateChange;
		}
		// What Chrome 26 and Mozilla 20 use
		if ('onstatechange' in pc) {
			pc.onstatechange = onSigStateChange;
		}

		var onIceConStateChange = function() {
			console.log('PC: ICE connection state change:', this.iceConnectionState);
		};
		// Official event, according to latest spec
		if ('oniceconnectionstatechange' in pc) {
			pc.oniceconnectionstatechange = onIceConStateChange;
		}
		// What Chrome 26 and Mozilla 20 use
		if ('onicechange' in pc) {
			pc.onicechange = onIceConStateChange;
		}
	}

	/**
	 * MediaSession objects allow control and monitoring of media sessions with
	 * other instances of the Crocodile RTC JavaScript Library, or other SIP
	 * clients on the Crocodile network.
	 * <p>
	 * Instances of this object are provided as the return value of the
	 * {@link CrocSDK.MediaAPI#connect Media.connect()} method, the
	 * {@link CrocSDK.MediaAPI~MediaSession#acceptTransfer MediaSession.acceptTransfer()}
	 * method, and are also contained within the
	 * {@link CrocSDK.MediaAPI~MediaSessionEvent MediaSessionEvent} object
	 * provided as an argument to the the
	 * {@link CrocSDK.MediaAPI#event:onMediaSession Media.onMediaSession} event
	 * handler.
	 * 
	 * @constructor
	 * @alias CrocSDK.MediaAPI~MediaSession
	 * @classdesc Represents a media session with a remote party.
	 */
	var MediaSession = function(mediaApi, sipSession, address, constraints) {
		var croc = mediaApi.crocObject;
		var iceServers = croc.iceServers;
		if (croc.dynamicIceServers) {
			// Put the managed TURN servers first in the list, but still include
			// any other configured STUN/TURN servers.
			iceServers = croc.dynamicIceServers.concat(iceServers);
		}
		console.log('Using ICE servers:', iceServers);

		// Internal state
		this.mediaApi = mediaApi;
		this.sipSession = sipSession;
		this.state = mediaSessionState.PENDING;
		this.peerConnection = new JsSIP.WebRTC.RTCPeerConnection({
			iceServers : iceServers
		}, constraints);
		this.videoConstraints = null;
		this.audioConstraints = null;
		this.localStream = null;
		this.oldLocalStream = null;
		this.screenStream = null;
		this.oldScreenStream = null;
		this.remoteMediaReceived = false;
		this.accepted = false;
		this.offerOutstanding = false;
		this.remoteHold = false;
		this.remoteHoldStreams = null;
		this.localHold = false;
		this.localHoldStreams = null;
		this.dtmfSender = null;
		this.transferFeedback = null;

		// Public properties
		/**
		 * The <code>address</code> of the remote party. For outbound sessions
		 * this is the address provided to the
		 * {@link CrocSDK.MediaAPI#connect Media.connect()}. For inbound
		 * sessions this is the <code>address</code> received from the remote
		 * party when the session was created.
		 * 
		 * @type {String}
		 */
		this.address = address;
		/**
		 * The display name of the remote party. For outbound sessions this is
		 * not set. For inbound sessions this is the display name received from
		 * the remote party when the session was created.
		 * 
		 * @type {String}
		 */
		this.displayName = null;
		/**
		 * Any custom headers provided during session initiation.
		 * <p>
		 * For inbound sessions these are provided by the remote party and for
		 * outbound sessions these are specified in the
		 * {@link CrocSDK.MediaAPI~ConnectConfig ConnectConfig} object used as a
		 * parameter to the {@link CrocSDK.MediaAPI#connect Media.connect()}
		 * method.
		 * <p>
		 * The header names are used as the key names in this object and the
		 * header contents are mapped to the key values.
		 * 
		 * @type {CrocSDK~CustomHeaders}
		 */
		this.customHeaders = null;
		/**
		 * The capabilities reported by the remote party. These are available
		 * immediately for inbound sessions and sessions to parties that are on
		 * the capabilities watch list (and for which a capabilities query
		 * response has been received). Capabilties for outbound sessions to
		 * addresses that are not on the capabilities watch list will not be
		 * available until the session has been accepted by the remote party.
		 * 
		 * @type {CrocSDK.Croc~Capabilities}
		 */
		this.capabilities = null;
		/**
		 * The current stream configuration for the session.
		 * 
		 * @type {CrocSDK.MediaAPI~StreamConfig}
		 */
		this.streamConfig = null;
		/**
		 * The DOM audio element to use for playing the remote party's audio.
		 * Only needed for audio-only calls.
		 * 
		 * @type {Object}
		 */
		this.remoteAudioElement = null;
		/**
		 * The DOM video element to use for displaying the remote party's video.
		 * Only needed for video calls.
		 * 
		 * @type {Object}
		 */
		this.remoteVideoElement = null;
		/**
		 * The DOM video element to use for displaying the local party's video.
		 * Only needed for video calls.
		 * 
		 * @type {Object}
		 */
		this.localVideoElement = null;

		configureRemoteMediaDetection(this);
		configurePeerConnectionDebug(this.peerConnection);
		this.peerConnection.onnegotiationneeded = this._handleNegotiationNeeded.bind(this);

		// Configure JsSIP event handlers
		var mediaSession = this;
		sipSession.on('progress', function() {
			CrocSDK.Util.fireEvent(mediaSession, 'onProvisional', {});
		});
		sipSession.on('started', this._handleStarted.bind(this));
		sipSession.on('ended', function(event) {
			var edata = event.data;
			if (edata.originator !== 'local') {
				var status = CrocSDK.Util.jsSipCauseToSdkStatus(edata.cause);
				// SIP session has already ended
				mediaSession.sipSession = null;
				// Clean up everything else, then notify app
				mediaSession.close(status);
			}
		});
		sipSession.on('failed', function(event) {
			var status = CrocSDK.Util.jsSipCauseToSdkStatus(event.data.cause);
			// SIP session has already ended
			mediaSession.sipSession = null;
			// Clean up everything else, then notify app
			mediaSession.close(status);
			// Auth failures should trigger croc object to stop
			if (event.data.cause === JsSIP.C.causes.AUTHENTICATION_ERROR) {
				croc.stop();
			}
		});
		sipSession.on('reinvite', this._handleReinvite.bind(this));
		sipSession.on('refresh', this._handleRefresh.bind(this));
	};

	/**
	 * Gets the local stream and adds it to the RTCPeerConnection.
	 * 
	 * @private
	 * @param streamConfig
	 * @param onSuccess
	 */
	MediaSession.prototype._getUserMedia = function(streamConfig, onSuccess) {
		var mediaSession = this;
		var sc = streamConfig || this.streamConfig;
		var constraints = {
			audio: !!sc.audio && sc.audio.send,
			video: !!sc.video && sc.video.send
		};
		var screencapture = false;
		var removeOldStream = function() {
			var oldStream = mediaSession.localStream;
			if (oldStream) {
				mediaSession.oldLocalStream = oldStream;
				mediaSession.peerConnection.removeStream(oldStream);
				mediaSession.localStream = null;
			}
		};
		var mediaSuccess = function(stream) {
			if (mediaSession.state === mediaSessionState.CLOSED) {
				// Oops, too late
				stream.stop();
				return;
			}

			console.log('Got local media stream');
			removeOldStream();
			mediaSession.localStream = stream;
			mediaSession.peerConnection.addStream(stream);
			if (constraints.video && mediaSession.localVideoElement) {
				mediaSession.localVideoElement.src = window.URL.createObjectURL(stream);
				mediaSession.localVideoElement.muted = true;
			}

			mediaSession._getScreenMedia(screencapture, onSuccess);
		};
		var mediaFailure = function(error) {
			console.warn('getUserMedia failed:', error);
			mediaSession.close();
		};

		// Handle media constraints
		if (constraints.audio) {
			if (this.audioConstraints &&
					CrocSDK.Util.isType(constraints.audio, 'boolean')) {
				// Keep previous constraints
				constraints.audio = this.audioConstraints;
			} else if (CrocSDK.Util.isType(constraints.audio, 'object')) {
				// Save the requested constraints
				this.audioConstraints = constraints.audio;
			}
		}
		if (constraints.video){
			if (this.videoConstraints &&
					CrocSDK.Util.isType(constraints.video, 'boolean')) {
				// Keep previous constraints
				constraints.video = this.videoConstraints;
			} else if (CrocSDK.Util.isType(constraints.video, 'object')) {
				// Save the requested constraints
				this.videoConstraints = constraints.video;
			}
		}

		var v = constraints.video;
		if (v && v.mandatory && v.mandatory.chromeMediaSource === 'screen') {
			// Screen capture video is being requested - that's handled in the
			// next step, as we can't request audio at the same time.
			constraints.video = false;
			screencapture = true;
		}

		if (!constraints.audio && !constraints.video) {
			removeOldStream();

			// Might want screen media instead
			this._getScreenMedia(screencapture, onSuccess);
			return;
		}

		console.log('Requesting user media:', constraints);
		JsSIP.WebRTC.getUserMedia(constraints, mediaSuccess, mediaFailure);
	};

	MediaSession.prototype._getScreenMedia = function(enabled, onSuccess) {
		var mediaSession = this;
		var constraints = {
			audio: false,
			video: {mandatory: {chromeMediaSource: 'screen'}}
		};
		var removeOldStream = function() {
			var oldStream = mediaSession.screenStream;
			if (oldStream) {
				mediaSession.oldScreenStream = oldStream;
				mediaSession.peerConnection.removeStream(oldStream);
				mediaSession.screenStream = null;
			}
		};
		var mediaSuccess = function(stream) {
			if (mediaSession.state === mediaSessionState.CLOSED) {
				// Oops, too late
				stream.stop();
				return;
			}

			console.log('Got local screen stream');
			mediaSession.screenStream = stream;
			mediaSession.peerConnection.addStream(stream);
			if (onSuccess) {
				onSuccess();
			}
		};
		var mediaFailure = function(error) {
			console.warn('getUserMedia failed:', error);
			mediaSession.close();
		};

		if (!enabled) {
			// Don't want screen sharing
			removeOldStream();
		} else if (this.screenStream && !this.screenStream.ended) {
			// We don't need to request media again
			enabled = false;
		}

		if (enabled) {
			console.log('Requesting user media:', constraints);
			JsSIP.WebRTC.getUserMedia(constraints, mediaSuccess, mediaFailure);
		} else {
			// Ensure calling function finishes before calling onSuccess to
			// avoid unexpected behaviour.
			if (onSuccess) {
				setTimeout(function() {
					onSuccess();
				}, 0);
			}
		}
	};

	/**
	 * Performs the steps needed to create a complete SDP offer: Request offer
	 * from RTCPeerConnection describing our current streams. Set offer as the
	 * local description (unmodified). Waits for ICE candidate collection to
	 * complete. Runs callback with completed offer.
	 * 
	 * @private
	 * @param streamConfig
	 * The MediaSession object for which we are creating an offer.
	 * @param onSuccess
	 * Callback to execute when the SDP offer is complete.
	 */
	MediaSession.prototype._createOffer = function(streamConfig, onSuccess) {
		var self = this;
		var pc = this.peerConnection;
		var sc = streamConfig || this.streamConfig;

		var setLocalSuccess = function() {
			console.log('Local description set, ice gathering state:', pc.iceGatheringState);
			// Local description set, now wait for ICE completion
			if (pc.iceGatheringState === 'complete') {
				onSuccess();
			} else {
				awaitIceCompletion(pc, onSuccess);
			}
		};
		var setLocalFailure = function(error) {
			console.warn('setLocalDescription failed:', error);
			self.close();
		};
		var offerSuccess = function(sessionDescription) {
			console.log('Offer created');
			// We've got a template offer, set it as the local description
			fixLocalDescription(sessionDescription, sc);
			pc.setLocalDescription(sessionDescription, setLocalSuccess, setLocalFailure);
		};
		var offerFailure = function(error) {
			console.warn('createOffer failed:', error);
			self.close();
		};

		// These constraints can add m-lines for streams that we have not added
		// to the PeerConnection, in case we want to receive but not send.
		// However, they do not seem to change added streams to sendonly when
		// set to false, so we have to mess with the SDP ourselves.
		var constraints = {
			mandatory : {
				OfferToReceiveAudio : !!sc.audio && sc.audio.receive,
				OfferToReceiveVideo : !!sc.video && sc.video.receive
			}
		};

		// Start by requesting an offer
		try {
			pc.createOffer(offerSuccess, offerFailure, constraints);
		} catch (e) {
			console.warn('createOffer failed:', e.stack);
			self.close();
		}
	};

	/**
	 * Performs the steps needed to create a complete SDP answer: Request answer
	 * from RTCPeerConnection describing our current streams. Set answer as the
	 * local description (unmodified). Waits for ICE candidate collection to
	 * complete. Runs callback with completed answer.
	 * 
	 * @private
	 * @param onSuccess
	 *            Callback to execute when the SDP answer is complete.
	 */
	MediaSession.prototype._createAnswer = function(onSuccess) {
		var mediaSession = this;
		var pc = this.peerConnection;

		var setLocalSuccess = function() {
			console.log('Local description set, ice gathering state:',
					pc.iceGatheringState);
			// Local description set, now wait for ICE completion
			if (pc.iceGatheringState === 'complete') {
				onSuccess();
			} else {
				awaitIceCompletion(pc, onSuccess);
			}
		};
		var setLocalFailure = function(error) {
			console.warn('setLocalDescription failed:', error);
			mediaSession.close();
		};
		var answerSuccess = function(sessionDescription) {
			console.log('Answer created');
			// We've got a template answer, set it as the local description
			fixLocalDescription(sessionDescription, mediaSession.streamConfig);
			pc.setLocalDescription(sessionDescription, setLocalSuccess, setLocalFailure);
		};
		var answerFailure = function(error) {
			console.warn('createOffer failed:', error);
			mediaSession.close();
		};
		var sc = this.streamConfig;

		// I don't think these are effective when creating an answer - we have
		// to mess with the SDP ourselves.
		var constraints = {
			'mandatory' : {
				'OfferToReceiveAudio' : !!sc.audio && sc.audio.receive,
				'OfferToReceiveVideo' : !!sc.video && sc.video.receive
			}
		};

		// Start by requesting an offer
		pc.createAnswer(answerSuccess, answerFailure, constraints);
	};

	/**
	 * @private
	 */
	MediaSession.prototype._updateIceServers = function(iceServers) {
		this.peerConnection.updateIce({
			iceServers: iceServers
		});
	};

	/**
	 * @private
	 */
	MediaSession.prototype._setRemoteStreamOutput = function() {
		var streams, stream, audioTracks, videoTracks;
		var pc = this.peerConnection;

		if (pc.getRemoteStreams) {
			// Latest spec uses a method
			streams = pc.getRemoteStreams();
		} else {
			// Older spec used a property (still used by Firefox 22)
			streams = pc.remoteStreams;
		}

		for (var idx = 0, len = streams.length; idx < len; idx++) {
			stream = streams[idx];
			audioTracks = stream.getAudioTracks();
			videoTracks = stream.getVideoTracks();

			if (videoTracks.length > 0) {
				if (this.remoteVideoElement) {
					this.remoteVideoElement.src = window.URL.createObjectURL(stream);
				} else {
					console.warn('Video received, but no remoteVideoElement provided');
				}
			} else if (audioTracks.length > 0) {
				if (this.remoteAudioElement) {
					this.remoteAudioElement.src = window.URL.createObjectURL(stream);
				} else {
					console.warn('Audio stream received, but no remoteAudioElement provided');
				}
			}
		}
	};

	/**
	 * @private
	 */
	MediaSession.prototype._connect = function() {
		var self = this;
		this._getUserMedia(null, function() {
			self._sendInvite();
		});
	};

	/**
	 * @private
	 */
	MediaSession.prototype._sendInvite = function() {
		var self = this;
		var crocObject = this.mediaApi.crocObject;
		var capabilityApi = crocObject.capability;

		this._createOffer(null, function() {
			var sipOptions = {};
			sipOptions.sdp = self.peerConnection.localDescription.sdp;
			sipOptions.extraHeaders = self.customHeaders.toExtraHeaders();
			sipOptions.featureTags = capabilityApi.createFeatureTags(
					crocObject.capabilities);

			// Add Call-Info header as per
			// draft-ivov-xmpp-cusax-05
			sipOptions.extraHeaders.push('Call-Info: <xmpp:' +
					crocObject.address + '> ;purpose=impp');

			self.sipSession.connect(self.address, sipOptions);

			CrocSDK.Util.fireEvent(self, 'onConnecting', {});
		});
	};

	/**
	 * @private
	 */
	MediaSession.prototype._sendReinvite = function(streamConfig, customHeaders) {
		var self = this;

		customHeaders = customHeaders || this.customHeaders;

		this._createOffer(streamConfig, function() {
			self.sipSession.sendReinvite({
				sdp: self.peerConnection.localDescription.sdp,
				extraHeaders: customHeaders.toExtraHeaders()
			});
			// The appropriate event handlers get added to the reinvite object
			// when the JsSIP 'reinvite' event fires.
		});
	};

	/**
	 * @private
	 */
	MediaSession.prototype._handleNegotiationNeeded = function() {
		if (this.state !== mediaSessionState.ESTABLISHED) {
			console.log('Ignoring negotiationneeded event - session not established');
			return;
		}

		if (this.offerOutstanding) {
			console.log('Ignoring negotiationneeded event - already due');
			return;
		}

		console.log('Starting O/A negotiation at PC\'s request');
		this._sendReinvite();
	};

	/**
	 * @private
	 */
	MediaSession.prototype._handleInitialInvite = function(rawSdp,
			parsedSdp, onSuccess, onFailure) {
		var sessionDesc = new JsSIP.WebRTC.RTCSessionDescription({
			type : 'offer',
			sdp : rawSdp
		});

		this.peerConnection.setRemoteDescription(sessionDesc, onSuccess, onFailure);
		this.streamConfig = new CrocSDK.StreamConfig(parsedSdp);
		// Now we wait for the application/user to accept or reject the session
	};

	/**
	 * Handles "started" events from JsSIP.
	 * @private
	 */
	MediaSession.prototype._handleStarted = function(event) {
		var response = event.data.response;

		this.state = mediaSessionState.ESTABLISHED;

		if (response) {
			// We've got the response to an outgoing session
			var mediaSession = this;

			var onSuccess = function() {
				console.log('Remote answer set');
				CrocSDK.Util.fireEvent(mediaSession, 'onConnect', {});
				mediaSession._setRemoteStreamOutput();
			};
			var onFailure = function(error) {
				console.warn('setRemoteDescription failed:', error);
				mediaSession.sipSession.terminate({
					status_code: 488
				});
				// SIP session has already ended
				mediaSession.sipSession = null;
				// Clean up everything else, then notify app
				mediaSession.close();
			};
			var sdp = response.body;

			console.log('Setting remote description');
			// Update session streamConfig based on the answer
			this.streamConfig = new CrocSDK.StreamConfig(new CrocSDK.Sdp.Session(sdp));
			if (this.streamConfig.video && this.screenStream) {
				this.streamConfig.video.source = 'screen';
			}
			var description = new JsSIP.WebRTC.RTCSessionDescription({
				type : 'answer',
				sdp : sdp
			});
			this.peerConnection.setRemoteDescription(
					description, onSuccess, onFailure);
		}
	};

	/**
	 * Handles "reinvite" events from JsSIP.
	 * @private
	 */
	MediaSession.prototype._handleReinvite = function(event) {
		var self = this;
		var data = event.data;
		var i, len;

		if (data.originator === 'remote') {
			this.offerOutstanding = true;

			var rawSdp = data.sdp;
			var parsedSdp = new CrocSDK.Sdp.Session(rawSdp);
			var streamsChanged = false;
			var headersChanged = false;

			if (!parsedSdp) {
				data.reinvite.sdpInvalid();
			}

			var streamConfig = new CrocSDK.StreamConfig(parsedSdp);
			var customHeaders = new CrocSDK.CustomHeaders(data.request);

			// Reject any unacceptable stream changes early on - checking this
			// before altering the PeerConnection state avoids having to
			// terminate the session (due to lack of PeerConnection rollback
			// feature).
			if (this.remoteHold && streamConfig.isSending()) {
				// We're coming off hold. Make sure we're only resuming sending
				// of previously-agreed streams - we should not be asked to
				// send anything extra.
				var heldStreams = this.remoteHoldStreams;
				var sendingStreams = streamConfig.getSendingStreams();
				for (i = 0, len = sendingStreams.length; i < len; i++) {
					if (heldStreams.indexOf(sendingStreams[i]) === -1) {
						// Denied
						console.warn('Remote UA tried to activate additional stream during resume:',
								sendingStreams[i]);
						data.reinvite.sdpInvalid();
					}
				}
			} else {
				// Check for significant changes in the re-INVITE.
				// Significant changes include changes to media streams, or
				// changes to custom headers.
				if (!streamConfig.equals(this.streamConfig)) {
					console.log('re-INVITE changing stream configuration');
					streamsChanged = true;
				}
				if (!customHeaders.equals(this.customHeaders)) {
					console.log('re-INVITE changing custom headers');
					headersChanged = true;
				}
			}

			// Submit the new remote SDP to RTCPeerConnection
			var sessionDesc = new JsSIP.WebRTC.RTCSessionDescription({
				type: 'offer',
				sdp: rawSdp
			});
			var onSuccess = function() {
				var oldStreamConfig = self.streamConfig;
				console.log('Remote offer set');
				data.reinvite.sdpValid();

				var accept = function(acceptStreamConfig) {
					if (acceptStreamConfig) {
						self.streamConfig = new CrocSDK.StreamConfig(acceptStreamConfig);
					} else {
						// Accepting the offered stream configuration
						self.streamConfig = streamConfig;
					}
					self.customHeaders = customHeaders;

					var answer = function() {
						self._createAnswer(function() {
							data.reinvite.accept({
								sdp: self.peerConnection.localDescription.sdp
							});
							self._setRemoteStreamOutput();
						});
					};

					if (self.remoteHold ||
							self.streamConfig.sendingStreamsEqual(oldStreamConfig)) {
						// Don't need to update user media
						answer();
					} else {
						self._getUserMedia(null, answer);
					}
				};

				// Notify the application
				if (oldStreamConfig.isSending() && !streamConfig.isSending()) {
					// Remote hold
					self.remoteHold = true;
					self.remoteHoldStreams = oldStreamConfig.getSendingStreams();
					accept();
					CrocSDK.Util.fireEvent(self, 'onHold', {});
				} else if (self.remoteHold && streamConfig.isSending()) {
					// Remote resume
					accept();
					self.remoteHold = false;
					CrocSDK.Util.fireEvent(self, 'onResume', {});
				} else {
					// Generic renegotiation
					var reject = function() {
						data.reinvite.reject({status_code: 488});
					};
					var safe = true;
					if (headersChanged ||
							!oldStreamConfig.isSafeChange(streamConfig)) {
						safe = false;
					}

					CrocSDK.Util.fireEvent(self, 'onRenegotiateRequest', {
						streamConfig: streamsChanged ? streamConfig : null,
						customHeaders: headersChanged ? customHeaders : null,
						safe: safe,
						accept: accept,
						reject: reject
					}, true);
				}
			};
			var onFailure = function(error) {
				console.warn('setRemoteDescription failed:', error);
				data.reinvite.sdpInvalid();
				// We're happy to continue, though the remote end is likely to
				// end the session after this.
			};

			this.peerConnection.setRemoteDescription(sessionDesc, onSuccess, onFailure);
		} else {
			// Outgoing re-INVITE
			data.reinvite.on('succeeded', function(event) {
				var onSuccess = function() {
					console.log('Remote answer set');
					self._setRemoteStreamOutput();
				};
				var onFailure = function(error) {
					console.warn('setRemoteDescription failed:', error);
					self.sipSession.terminate({
						status_code: 488
					});
					// SIP session has already ended
					self.sipSession = null;
					// Clean up everything else, then notify app
					self.close();
				};
				var sdp = event.data.sdp;

				console.log('Setting remote description');
				// Update session streamConfig based on the answer
				self.streamConfig = new CrocSDK.StreamConfig(
						new CrocSDK.Sdp.Session(sdp));
				self.customHeaders = new CrocSDK.CustomHeaders(data.request);
				var description = new JsSIP.WebRTC.RTCSessionDescription({
					type : 'answer',
					sdp : sdp
				});
				self.peerConnection.setRemoteDescription(
						description, onSuccess, onFailure);

				CrocSDK.Util.fireEvent(self, 'onRenegotiateResponse', {
					accepted: true
				});
			});

			data.reinvite.on('failed', function(event) {
				// Not sure how to get the RTCPeerConnection back into a stable
				// state; the simplest option here is to end the session.
				console.log('Reinvite failed, closing session', event.data);
				CrocSDK.Util.fireEvent(self, 'onRenegotiateResponse', {
					accepted: false
				});
				self.close();
			});
		}

		data.reinvite.on('completed', function() {
			self.offerOutstanding = false;
			if (self.oldLocalStream) {
				self.oldLocalStream.stop();
				self.oldLocalStream = null;
			}
			if (self.oldScreenStream) {
				self.oldScreenStream.stop();
				self.oldScreenStream = null;
			}
			CrocSDK.Util.fireEvent(self, 'onRenegotiateComplete', {});
		});
	};

	/**
	 * Handles "refresh" events from JsSIP.
	 * @private
	 */
	MediaSession.prototype._handleRefresh = function() {
		if (this.sipSession.isMethodAllowed(JsSIP.C.UPDATE, false)) {
			this.sipSession.sendUpdate();
		} else {
			this._sendReinvite();
		}
	};

	/**
	 * Handles out-of-dialog "newRefer" events from JsSIP that targetted this
	 * session.
	 * @private
	 * @param {JsSIP.Refer} refer - The object representing the incoming refer.
	 */
	MediaSession.prototype._handleRefer = function(refer) {
		var event = new TransferRequestEvent(this, refer);
		CrocSDK.Util.fireEvent(this, 'onTransferRequest', event, true);
	};

	/*
	 * Public methods
	 */

	/**
	 * Accept this new, incoming media session. The optional config parameter
	 * may be used to selectively accept or modify the offered streams; if 
	 * this is not provided the offered stream configuration is accepted.
	 * 
	 * @param {CrocSDK.MediaAPI~StreamConfig} [config]
	 * May be used to selectively accept or modify the offered streams.
	 * 
	 * @fires CrocSDK.MediaAPI~MediaSession#onConnect
	 * 
	 * @throws {TypeError}
	 * @throws {CrocSDK.Exceptions#ValueError}
	 * @throws {CrocSDK.Exceptions#StateError}
	 */
	MediaSession.prototype.accept = function(config) {
		var mediaSession = this;

		if (config) {
			if (config instanceof CrocSDK.StreamConfig) {
				this.streamConfig = config;
			} else {
				this.streamConfig = new CrocSDK.StreamConfig(config);
			}
		}

		if (this.state !== mediaSessionState.PENDING) {
			throw new CrocSDK.Exceptions.StateError('Session cannot be accepted in state', this.state);
		}

		if (this.sipSession.direction !== 'incoming') {
			throw new CrocSDK.Exceptions.StateError('Cannot call accept() on outgoing sessions');
		}

		this._getUserMedia(null, function() {
			mediaSession._createAnswer(function() {
				// Check that we haven't received a CANCEL in the meanwhile
				if (mediaSession.state === mediaSessionState.PENDING) {
					mediaSession.sipSession.answer({
						sdp : mediaSession.peerConnection.localDescription.sdp
					});
					CrocSDK.Util.fireEvent(mediaSession, 'onConnect', {});
				}
			});
		});
		this._setRemoteStreamOutput();
	};

	/**
	 * Put the session on-hold. Media streams are renegotiated to
	 * &#34;sendonly&#34; to stop inbound media, and local media is muted.
	 * <p>
	 * Note: due to current limitations of WebRTC, if the renegotiation fails
	 * the session will be closed.
	 * 
	 * @throws {CrocSDK.Exceptions#StateError} If a renegotiation is already in
	 * progress.
	 */
	MediaSession.prototype.hold = function() {
		if (this.localHold) {
			// Don't need to do anything
			return;
		}
		if (this.offerOutstanding) {
			throw new CrocSDK.Exceptions.StateError('Existing renegotiation still in progress');
		}
		this.localHold = true;
		this.offerOutstanding = true;

		// Mute all local streams
		var videoTracks = this.localStream.getVideoTracks();
		var audioTracks = this.localStream.getAudioTracks();
		var screenTracks;
		if (this.screenStream) {
			screenTracks = this.screenStream.getVideoTracks();
		} else {
			screenTracks = [];
		}
		var allTracks = videoTracks.concat(audioTracks, screenTracks);
		for (var i = 0, len = allTracks.length; i < len; i++) {
			allTracks[i].enabled = false;
		}

		// Request that the remote party stop sending all streams
		var newStreamConfig = new CrocSDK.StreamConfig(this.streamConfig);
		this.localHoldStreams = newStreamConfig.hold();
		this._sendReinvite(newStreamConfig);
	};

	/**
	 * Resume an on-hold session. Media streams are renegotiated with the
	 * configuration that was in effect before <code>hold()</code> was called
	 * and the local media is unmuted.
	 * <p>
	 * Note: due to current limitations of WebRTC, if the renegotiation fails
	 * the session will be closed.
	 * 
	 * @throws {CrocSDK.Exceptions#StateError} If a renegotiation is already in
	 * progress.
	 */
	MediaSession.prototype.resume = function() {
		if (!this.localHold) {
			// Don't need to do anything
			return;
		}
		if (this.offerOutstanding) {
			throw new CrocSDK.Exceptions.StateError('Existing renegotiation still in progress');
		}
		this.offerOutstanding = true;

		// Request that the remote party resumes sending media
		var newStreamConfig = new CrocSDK.StreamConfig(this.streamConfig);
		newStreamConfig.resume(this.localHoldStreams);
		this._sendReinvite(newStreamConfig);

		// Unmute the local media
		var videoTracks = this.localStream.getVideoTracks();
		var audioTracks = this.localStream.getAudioTracks();
		var screenTracks;
		if (this.screenStream) {
			screenTracks = this.screenStream.getVideoTracks();
		} else {
			screenTracks = [];
		}
		var allTracks = videoTracks.concat(audioTracks, screenTracks);
		for (var i = 0, len = allTracks.length; i < len; i++) {
			allTracks[i].enabled = true;
		}

		this.localHold = false;
	};

	/**
	 * Attempt to renegotiate the session. This is used to change the media
	 * streams mid-session by adding or removing video or audio. The remote
	 * party must accept the changes before they will take effect.
	 * <p>
	 * Note: due to current limitations of WebRTC, if the renegotiation fails
	 * the session will be closed.  To reduce the likelihood of rejected
	 * negotiation attempts, applications should avoid stream modifications
	 * that demand new media from the remote party.  For instance, to add video
	 * to an existing audio-only session, enable a send-only video stream
	 * instead of a send/receive video stream; the remote party is then free
	 * to choose whether they enable their own video, which would be done in
	 * a subsequent renegotiation initiated from their end.
	 * 
	 * @param {CrocSDK.MediaAPI~ConnectConfig} [connectConfig]
	 * Optional new configuration to use in the negotiation.
	 * 
	 * @throws {TypeError} If a parameter is set to an unexpected type.
	 * @throws {CrocSDK.Exceptions#ValueError} If a parameter is set to an
	 * unexpected value.
	 * @throws {CrocSDK.Exceptions#StateError} If a renegotiation is already in
	 * progress, or if streams are being modified whilst the call is on-hold.
	 */
	MediaSession.prototype.renegotiate = function(connectConfig) {
		if (!connectConfig) {
			connectConfig = {};
		}
		var streamConfig = connectConfig.streamConfig;
		var customHeaders = connectConfig.customHeaders;

		if (streamConfig) {
			streamConfig = new CrocSDK.StreamConfig(streamConfig);
		}
		if (customHeaders) {
			customHeaders = new CrocSDK.CustomHeaders(customHeaders);
		}

		if ((this.localHold || this.remoteHold) && streamConfig) {
			throw new CrocSDK.Exceptions.StateError('Cannot modify streams whilst on hold');
		}
		if (this.offerOutstanding) {
			throw new CrocSDK.Exceptions.StateError('Existing renegotiation still in progress');
		}
		this.offerOutstanding = true;

		if (streamConfig && !streamConfig.sendingStreamsEqual(this.streamConfig)) {
			var self = this;
			this._getUserMedia(streamConfig, function() {
				self._sendReinvite(streamConfig, customHeaders);
			});
		} else {
			this._sendReinvite(streamConfig, customHeaders);
		}
	};

	/**
	 * Mutes the local microphone.
	 * <p>
	 * Mute may be preferable to hold if you still want to receive the remote
	 * party's media, or if you want to avoid media renegotiation (which is not
	 * currently supported in Firefox).
	 * <p>
	 * Due to the logical and functional overlap, not to mention potential user
	 * confusion, mixing mute and hold is not recommended.
	 */
	MediaSession.prototype.mute = function() {
		var audioTracks = this.localStream.getAudioTracks();
		for (var i = 0, len = audioTracks.length; i < len; i++) {
			audioTracks[i].enabled = false;
		}
	};

	/**
	 * Unmutes the local microphone.
	 * 
	 * @throws {CrocSDK.Exceptions#StateError} If the remote party is currently
	 * on-hold.
	 */
	MediaSession.prototype.unmute = function() {
		if (this.localHold) {
			throw new CrocSDK.Exceptions.StateError('Cannot unmute a held call');
		}

		var audioTracks = this.localStream.getAudioTracks();
		for (var i = 0, len = audioTracks.length; i < len; i++) {
			audioTracks[i].enabled = true;
		}
	};

	/**
	 * Sends DTMF tones to the remote party.
	 * <p>
	 * If DTMF playout is already in progress, the provided tone(s) will be
	 * appended to the existing queue.
	 * 
	 * @param {String|Number} tones
	 * One or more DTMF symbols to send.  Valid symbols include the numbers 0 to
	 * 9, and the characters *, #, and A through D.  A comma is also valid,
	 * which will insert a two-second gap in the played tones.
	 * @param {Object} [config]
	 * Optional extra configuration.
	 * @param {Number} [config.duration]
	 * The duration, in milliseconds, to play each DTMF tone. Defaults to 200ms
	 * if not provided. Valid values range from 70ms to 6000ms.
	 * @param {Number} [config.interToneGap]
	 * The amount of time to leave, in milliseconds, between each DTMF tone.
	 * Defaults to 50ms.
	 * 
	 * @throws {CrocSDK.Exceptions#ValueError} If sending of DTMF is attempted
	 * when no audio stream is being sent.
	 */
	MediaSession.prototype.sendDTMF = function(tones, config) {
		config = config || {};
		var type = config.type || 'pc';
		var duration = config.duration || 200;
		var interToneGap = config.interToneGap || type === 'info' ? 500: 50;
		var self = this;

		tones = tones.toString().toUpperCase();
		if (/[^0-9A-D\*#,]/.test(tones)) {
			throw new CrocSDK.Exceptions.ValueError(
					'Invalid characters in DTMF tones:', tones);
		}

		duration = Math.max(duration, 70);
		duration = Math.min(duration, 6000);
		interToneGap = Math.max(interToneGap, 50);

		switch (type) {
		default:
		case 'pc':
			var sender = this.dtmfSender;
			if (sender) {
				// Append to the existing tone buffer, using the existing
				// duration and gap settings.
				sender.insertDTMF(sender.toneBuffer + tones, sender.duration,
						sender.interToneGap);
				return;
			}

			var audioTracks = this.localStream.getAudioTracks();
			if (audioTracks.length < 1) {
				throw new CrocSDK.Exceptions.ValueError(
						'Cannot send DTMF without an audio track');
			}
			sender = this.peerConnection.createDTMFSender(audioTracks[0]);
			sender.insertDTMF(tones, duration, interToneGap);
			sender.ontonechange = function(event) {
				if (!event.tone) {
					// Playout has completed - discard the sender
					self.dtmfSender = null;
				}
			};
			this.dtmfSender = sender;
			break;	
		case 'info':
			this.sipSession.sendDTMF(tones, {
				duration: duration,
				interToneGap: interToneGap
			});
			break;
		}
	};

	/**
	 * Request that the remote party be transferred to the target address.
	 * <p>
	 * To ensure a standard call transfer experience, the following behaviour
	 * is recommended for applications using this functionality:
	 * <ol>
	 * <li>Put the session on hold.
	 * <li>Request the transfer.
	 * <li>If the transfer is successful, close the session; otherwise resume
	 * the session.
	 * </ol>
	 * 
	 * @param {String} address - The target address of the transfer.
	 * @returns {CrocSDK.MediaAPI~MediaSession~TransferFeedback}
	 * @throws {CrocSDK.Exceptions#StateError}
	 * If the current session is not established, or a previous transfer attempt
	 * is still in progress.
	 * @throws {CrocSDK.Exceptions#UnsupportedError}
	 * If the remote party does not support transfer.
	 */
	MediaSession.prototype.transfer = function(address) {
		if (this.state !== mediaSessionState.ESTABLISHED) {
			throw new CrocSDK.Exceptions.StateError(
					'Media session not established: ' + this.state);
		}
		if (this.transferFeedback) {
			throw new CrocSDK.Exceptions.StateError(
					'Previous transfer outstanding');
		}

		var feedback = new TransferFeedback(this);
		var options = {};
		options.eventHandlers = feedback._getJsSipHandlers();

		try {
			this.sipSession.sendRefer(address, options);
		} catch (e) {
			if (e instanceof JsSIP.Exceptions.RemoteSupportError) {
				throw new CrocSDK.Exceptions.UnsupportedError(
						'Remote party does not support transfers');
			}
		}
		this.transferFeedback = feedback;
		return feedback;
	};

	/**
	 * Explicitly close this media session.
	 * <p>
	 * If <code>accept()</code> has not been called the session will be
	 * rejected.
	 * <p>
	 * If the <code>status</code> argument is not provided it will default to
	 * <code>normal</code>.
	 * 
	 * @method
	 * @param {CrocSDK.MediaAPI~MediaSession~status} status
	 */
	MediaSession.prototype.close = function(status) {
		if (this.state === mediaSessionState.CLOSED) {
			return;
		}

		var oldState = this.state;
		this.state = mediaSessionState.CLOSED;

		if (!status) {
			status = 'normal';
		}

		if (this.peerConnection) {
			this.peerConnection.close();
		}

		if (this.screenStream) {
			this.screenStream.stop();
		}

		if (this.localStream) {
			this.localStream.stop();
		}

		if (this.sipSession) {
			var terminateOptions = null;
			if (oldState === mediaSessionState.PENDING && this.sipSession.direction === 'incoming') {
				// Rejecting the session
				var sipStatus = CrocSDK.Util.sdkStatusToSipStatus('invite',
						status);
				terminateOptions = {
					status_code : sipStatus
				};
			}

			try {
				this.sipSession.terminate(terminateOptions);
			} catch (e) {
				console.error('Error terminating SIP session:\n', e.stack);
			}
		}

		// Remove from active session array
		var sessions = this.mediaApi.mediaSessions;
		sessions.splice(sessions.indexOf(this), 1);

		// Notify application
		CrocSDK.Util.fireEvent(this, 'onClose', {
			status : status
		});
	};

	/*
	 * Public events
	 */

	/**
	 * This event is dispatched when the Crocodile RTC JavaScript Library has 
	 * acquired the necessary media streams and has constructed the session 
	 * request.
	 * <p>
	 * If this event handler is not defined the session set-up will proceed 
	 * regardless.
	 * 
	 * @event
	 */
	MediaSession.prototype.onConnecting = function() {
		// Do nothing
	};

	/**
	 * This event is dispatched when the Crocodile RTC Javascript Library 
	 * receives a provisional response to a new media session set-up request or
	 * renegotiation.
	 * <p>
	 * If this event handler is not defined the session set-up will proceed 
	 * regardless.
	 *  
	 * @event
	 */
	MediaSession.prototype.onProvisional = function() {
		// Do nothing
	};

	/**
	 * This event is dispatched when the remote party accepts the session.
	 * <p>
	 * If this event handler is not defined the session set-up will complete 
	 * regardless.
	 * 
	 * @event
	 */
	MediaSession.prototype.onConnect = function() {
		// Do nothing
	};

	/**
	 * This event is dispatched when remote media is first received on a 
	 * session.
	 * <p>
	 * If this event handler is not defined the session set-up will proceed 
	 * regardless.
	 *   
	 * @event
	 */
	MediaSession.prototype.onRemoteMediaReceived = function() {
		// Do nothing
	};

	/**
	 * This event is dispatched when the remote party attempts to renegotiate
	 * the {@link CrocSDK.MediaAPI~MediaSession MediaSession}.
	 * <p>
	 * If this event is not handled, any changes that are not considered
	 * "safe" (due to possible privacy or billing implications) will be rejected
	 * automatically.
	 * 
	 * @event
	 * @param {CrocSDK.MediaAPI~MediaSession~RenegotiateRequestEvent}
	 * [event] The event object associated with this event.
	 */
	MediaSession.prototype.onRenegotiateRequest = function(event) {
		if (event.safe) {
			// Nothing significant changed - accept
			console.log('Auto-accepting re-INVITE (no significant changes)');
			event.accept();
			return;
		}

		// Something significant changed, and event not handled (so we can't
		// get user approval) - reject.
		console.log('Auto-rejecting re-INVITE (significant changes)');
		event.reject();
	};

	/**
	 * This event is fired when a request to transfer the session is received.
	 * The web-app is responsible for notifying the user and requesting
	 * permission to transfer (if appropriate), and then should call the
	 * <code>accept</code> or <code>reject</code> method on the event object.
	 * <p>
	 * If this event is not handled, or the response is not provided within the
	 * configured <code>acceptTimeout</code> period, the transfer request will
	 * be rejected automatically.
	 * 
	 * @event
	 * @param {CrocSDK.MediaAPI~MediaSession~TransferRequestEvent} event
	 * The event object associated with this event.
	 */
	MediaSession.prototype.onTransferRequest = function(event) {
		// Default handler rejects the request
		event.reject();
	};

	/**
	 * Dispatched when Crocodile RTC JavaScript Library detects that a 
	 * {@link CrocSDK.MediaAPI~MediaSession MediaSession} 
	 * has been closed by the Crocodile RTC Network or remote party.
	 * <p>
	 * Any references to the session within a web-app should be removed (to 
	 * allow garbage collection) when this event is run.
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will 
	 * clean up the session internally.
	 *  
	 * @event
	 * @param {CrocSDK.MediaAPI~MediaSession~CloseEvent}
	 * [event] The event object associated with this event.
	 */
	MediaSession.prototype.onClose = function() {
		// Do nothing
	};


	/**
	 * Provides feedback for an outgoing transfer/refer attempt.
	 *  
	 * @constructor
	 * @alias CrocSDK.MediaAPI~MediaSession~TransferFeedback
	 * @param {CrocSDK.MediaAPI~MediaSession} session
	 * The target session being transferred.
	 */
	var TransferFeedback = function(session) {
		this.session = session;
	};

	/**
	 * Event fired when the remote party accepts a transfer request.
	 * <p>
	 * If this event is not handled, the default behaviour is to close the
	 * session.
	 * @event
	 */
	TransferFeedback.prototype.onAccepted = function () {
		// Default behaviour is to close the session automatically (blind transfer)
		this.session.close();
	};

	/**
	 * Event fired when the remote party rejects a transfer request.
	 * <p>
	 * If this event is not handled, the default behaviour is to close the
	 * session.
	 * @event
	 */
	TransferFeedback.prototype.onRejected = function () {
		// Default behaviour is to close the session automatically (blind transfer)
		this.session.close();
	};

	/**
	 * Event fired when the transfer has completed successfully.
	 * <p>
	 * If this event is not handled, no special action is taken.
	 * @event CrocSDK.MediaAPI~MediaSession~TransferFeedback#onTransferSucceeded
	 */

	/**
	 * Event fired when the transfer attempt has failed.
	 * <p>
	 * If this event is not handled, no special action is taken.
	 * @event CrocSDK.MediaAPI~MediaSession~TransferFeedback#onTransferFailed
	 */

	/**
	 * Event fired when the result of the transfer attempt cannot be determined.
	 * <p>
	 * This may occur if the remote client does not support reporting of
	 * transfer progress, or if the result fails to reach us for some reason.
	 * <p>
	 * If this event is not handled, no special action is taken.
	 * @event CrocSDK.MediaAPI~MediaSession~TransferFeedback#onTransferResultUnknown
	 */

	/**
	 * @private
	 * @returns {Object} JsSIP event handlers for a Refer object
	 */
	TransferFeedback.prototype._getJsSipHandlers = function () {
		var self = this;
		return {
			accepted: function() {
				CrocSDK.Util.fireEvent(self, 'onAccepted', {}, true);
			},
			failed: function() {
				// Transfer attempt finished
				self.session.transferFeedback = null;
				CrocSDK.Util.fireEvent(self, 'onRejected', {}, true);
			},
			notify: function(event) {
				var data = event.data;
				if (!data.finalNotify) {
					return;
				}

				// Transfer attempt finished
				self.session.transferFeedback = null;
				switch (data.sessionEvent) {
				case 'started':
					CrocSDK.Util.fireEvent(self, 'onTransferSucceeded', {});
					break;
				case 'failed':
					CrocSDK.Util.fireEvent(self, 'onTransferFailed', {});
					break;
				default:
					CrocSDK.Util.fireEvent(self, 'onTransferResultUnknown', {});
					break;
				}
			}
		};
	};

	/**
	 * The event object for the
	 * {@link CrocSDK.MediaAPI~MediaSession#event:onTransferRequest onTransferRequest}
	 * event.
	 * @constructor
	 * @alias CrocSDK.MediaAPI~MediaSession~TransferRequestEvent
	 * @param {CrocSDK.MediaAPI~MediaSession} session
	 * @param {JsSIP.Refer} refer
	 */
	var TransferRequestEvent = function(session, refer) {
		var self = this;

		this.session = session;
		this.refer = refer;
		this.timer = setTimeout(function() {
			self.reject();
			self.timer = null;
		}, session.mediaApi.acceptTimeout * 1000);

		/**
		 * The <code>address</code> to which we are being transferred.
		 * @type {String}
		 */
		this.address = refer.refer_uri.toString().replace(/^sip:/, '');
	};

	/**
	 * Accept the incoming transfer request. Returns a new
	 * <code>MediaSession</code> object representing the media session with
	 * the transfer target.
	 * <p>
	 * The stream configuration of the new MediaSession will match that of the
	 * existing session unless it is specified in the <code>config</code>
	 * parameter.
	 * 
	 * @param {CrocSDK.MediaAPI~ConnectConfig} [config]
	 * Optional session configuration.
	 * @returns {CrocSDK.MediaAPI~MediaSession} The new session with the
	 * transfer target.
	 */
	TransferRequestEvent.prototype.accept = function(config) {
		if (this.timer === null) {
			return;
		}
		clearTimeout(this.timer);
		this.timer = null;

		config = config || {};
		if (!config.streamConfig) {
			config.streamConfig = this.session.streamConfig;
		} 

		var newSession = this.session.mediaApi.connect(this.address, config);
		this.refer.addSessionNotifyHandlers(newSession.sipSession);
		return newSession;
	};

	/**
	 * Reject the incoming transfer request.
	 */
	TransferRequestEvent.prototype.reject = function() {
		if (this.timer === null) {
			return;
		}
		clearTimeout(this.timer);
		this.timer = null;

		this.refer.reject({
			status_code: 603
		});
	};


	/* Further Documentation in JSDoc */
	// Documented Type Definitions
	/**
	 * Valid status are:
	 * <ul>
	 * <li><code>normal</code> - reject the session with a busy indication.</li>
	 * <li><code>blocked</code> - reject the session indicating the initiator
	 * of the session is on a block-list.</li>
	 * <li><code>offline</code> - reject the session indicating the instance
	 * of Crocodile RTC JavaScript Library is offline. The initiator of the
	 * session cannot distinguish between appearing offline and actually
	 * offline.</li>
	 * <li><code>notfound</code> - reject the session indicating the instance
	 * of Crocodile RTC JavaScript Library does not exist. The initiator of the
	 * session cannot distinguish between appearing to not exist and actually
	 * not existing.</li>
	 * </ul>
	 * 
	 * @typedef {String} CrocSDK.MediaAPI~MediaSession~status
	 */

	/**
	 * @memberof CrocSDK.MediaAPI~MediaSession
	 * @class CrocSDK.MediaAPI~MediaSession~RenegotiateRequestEvent
	 * @property {CrocSDK~CustomHeaders} customHeaders
	 * The new set of custom headers provided by the remote party when it
	 * started renegotiation. If the custom headers match those previously seen
	 * (available as a property of the MediaSession object), this property will
	 * be set to <code>null</code>.
	 * @property {CrocSDK.MediaAPI~StreamConfig} streamConfig
	 * The new configuration for the renegotiated media stream. If this matches
	 * the previously agreed configuration, this property will be set to
	 * <code>null</code>.
	 * @property {Boolean} safe
	 * A boolean value indicating whether the renegotiation is considered "safe".
	 * A "safe" renegotiation is one that does not change any custom headers,
	 * and that does not request any new media from the local party. This
	 * indicates that there should not be any billing or privacy implications
	 * in accepting the renegotiation.
	 */
	/**
	 * Accepts the renegotiation request.
	 * @method CrocSDK.MediaAPI~MediaSession~RenegotiateRequestEvent#accept
	 * @param {CrocSDK.MediaAPI~StreamConfig} [acceptStreamConfig]
	 * The accepted stream configuration. If not provided, the offered stream
	 * configuration will be accepted as-is.
	 */
	/**
	 * Rejects the renegotiation request. The session will continue with the
	 * previously-agreed streams.
	 * @method CrocSDK.MediaAPI~MediaSession~RenegotiateRequestEvent#reject
	 */

	/**
	 * @memberof CrocSDK.MediaAPI~MediaSession
	 * @typedef CrocSDK.MediaAPI~MediaSession~RenegotiateResponseEvent
	 * @property {Boolean} accepted
	 * Set to <code>true</code> if the remote party accepted the renegotiation
	 * request, <code>false</code> otherwise.
	 */

	/**
	 * @memberof CrocSDK.MediaAPI~MediaSession
	 * @typedef CrocSDK.MediaAPI~MediaSession~CloseEvent
	 * @property {String} status An indication of how the session ended.
	 * 
	 * Valid status are:
	 * <ul>
	 * <li><code>normal</code> - the session ended normally (including timed
	 * out).</li>
	 * <li><code>blocked</code> - the remote party has rejected the session
	 * because the local user is blocked.</li>
	 * <li><code>offline</code> - the remote party is offline or wants to
	 * appear offline.</li>
	 * <li><code>notfound</code> - the remote party does not exist or wants
	 * to appear to not exist.</li>
	 * </ul>
	 */

	// Documented Events

	/**
	 * This event is dispatched when the remote party has requested to put the
	 * session on hold.
	 * <p>
	 * Note that local and remote hold are independent - if the remote party
	 * puts the session on hold, the local party cannot reverse the action by
	 * calling the <code>resume()</code> method.
	 * <p>
	 * The session will automatically go on hold whether this event is handled
	 * or not.
	 * 
	 * @memberof CrocSDK.MediaAPI~MediaSession
	 * @event CrocSDK.MediaAPI~MediaSession#onHold
	 */

	/**
	 * This event is dispatched when the remote party has requested to resume
	 * the session, having previously placed it on hold.
	 * <p>
	 * The session will automatically resume whether this event is handled or
	 * not.
	 * 
	 * @memberof CrocSDK.MediaAPI~MediaSession
	 * @event CrocSDK.MediaAPI~MediaSession#onResume
	 */

	/**
	 * This event is dispatched when a response is received for an outgoing
	 * renegotiation request (including the special cases of hold/resume
	 * renegotiations).
	 * <p>
	 * No action is necessary on this event - the Crocodile RTC JavaScript
	 * Library will complete the renegotiation process regardless of whether
	 * a handler is registered.
	 * 
	 * @memberof CrocSDK.MediaAPI~MediaSession
	 * @event CrocSDK.MediaAPI~MediaSession#onRenegotiateResponse
	 * @param {CrocSDK.MediaAPI~MediaSession~RenegotiateResponseEvent}
	 * [event] The event object associated with this event.
	 */

	/**
	 * This event is dispatched when a renegotiation completes (including the
	 * special cases of hold/resume renegotiations).  The event fires
	 * regardless of which party started the renegotiation, thus indicating that
	 * it is possible to start a new renegotiation if required.
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * complete the renegotiation process automatically.
	 * 
	 * @memberof CrocSDK.MediaAPI~MediaSession
	 * @event CrocSDK.MediaAPI~MediaSession#onRenegotiateComplete
	 */

	CrocSDK.MediaSession = MediaSession;
}(CrocSDK));

(function(CrocSDK) {
	/**
	 * Determines the next MSRP connection to use (round-robin).
	 * 
	 * @private
	 * @param dataApi
	 *            The DataAPI instance.
	 * @returns {CrocMSRP.Connection} The MSRP connection to use.
	 */
	function getNextMsrpConnection(dataApi) {
		var numConnections = dataApi.msrpConnections.length;
		if (numConnections < 1) {
			throw new CrocSDK.Exceptions.StateError('MSRP relays not configured');
		}

		var thisConnection = dataApi.nextMsrpConnection++;

		if (dataApi.nextMsrpConnection >= numConnections) {
			dataApi.nextMsrpConnection = 0;
		}

		return dataApi.msrpConnections[thisConnection];
	}

	function addSharedMsrpEvents(dataSession, eventObj) {
		// General failure events
		eventObj.onAuthFailed = function() {
			console.warn('MSRP authentication failed - closing session');
			// MSRP session is dead
			dataSession.msrpSession = null;
			// Clean up and notify application
			dataSession.close();
		};
		eventObj.onError = function() {
			console.warn('MSRP error occurred - closing session');
			// MSRP session self-closes
			dataSession.msrpSession = null;
			// Clean up and notify application
			dataSession.close();
		};

		// Message sending events
		eventObj.onChunkSent = function(id, sentBytes) {
			var tp = dataSession.sendTransferProgress[id];
			if (tp) {
				var percentComplete = null;

				if (tp.size) {
					percentComplete = Math.floor(sentBytes * 100 / tp.size);
				}

				CrocSDK.Util.fireEvent(tp, 'onProgress', {
					bytesComplete : sentBytes,
					percentComplete : percentComplete
				});
			}

			dataSession.lastActivity = Date.now();
		};
		// Ignore onMessageSent; we're only interested when it's been delivered
		eventObj.onMessageDelivered = function(id) {
			var tp = dataSession.sendTransferProgress[id];
			if (tp) {
				CrocSDK.Util.fireEvent(tp, 'onSuccess', {
					data : null
				});
			}

			// We're done with this TransferProgress object
			delete dataSession.sendTransferProgress[id];
		};
		eventObj.onMessageSendFailed = function(id, status, comment) {
			var tp = dataSession.sendTransferProgress[id];
			if (tp) {
				CrocSDK.Util.fireEvent(tp, 'onFailure', {
					partialData : null
				});
			}

			// We're done with this TransferProgress object
			delete dataSession.sendTransferProgress[id];
			console.log('MSRP send failed: status=', status, 'comment=', comment);
		};

		// Message receiving events
		eventObj.onFirstChunkReceived = function(id, contentType, filename,
				size, description) {
			var tp = new TransferProgress(dataSession, id, false, contentType,
					size, filename, description);
			dataSession.recvTransferProgress[id] = tp;

			CrocSDK.Util.fireEvent(dataSession, 'onDataStart', {
				transferProgress : tp
			}, true);
		};
		eventObj.onChunkReceived = function(id, receivedBytes) {
			var tp = dataSession.recvTransferProgress[id];
			if (tp) {
				var percentComplete = null;

				if (tp.size) {
					percentComplete = Math.floor(receivedBytes * 100 / tp.size);
				}

				CrocSDK.Util.fireEvent(tp, 'onProgress', {
					bytesComplete : receivedBytes,
					percentComplete : percentComplete
				});
			}

			dataSession.lastActivity = Date.now();
		};
		eventObj.onMessageReceived = function(id, contentType, body) {
			// If a TransferProgress object exists, fire onSuccess there first
			var tp = dataSession.recvTransferProgress[id];
			if (tp) {
				CrocSDK.Util.fireEvent(tp, 'onSuccess', {
					data : body
				});
			}

			var prevSdkState = CrocSDK.C.states.sdkComposing.IDLE;

			if (dataSession.remoteActiveTimeoutId) {
				// We were expecting a message - clear the timeout
				clearTimeout(dataSession.remoteActiveTimeoutId);
				dataSession.remoteActiveTimeoutId = null;
				prevSdkState = CrocSDK.C.states.sdkComposing.COMPOSING;
			}

			// Then fire the appropriate onData event
			if (contentType === CrocSDK.C.MT.IS_COMPOSING &&
					dataSession.hasOwnProperty('onComposingStateChange')) {
				// Process "is composing" message - see RFC 3994
				var domParser = new DOMParser();
				var doc = domParser.parseFromString(body, contentType);
				var state = doc.getElementsByTagName("state")[0].firstChild.data;

				var sdkState = CrocSDK.Util.rfc3994StateToSdkState(state);
				if (sdkState === CrocSDK.C.states.sdkComposing.COMPOSING) {
					var refreshTimeout = 120;
					var refreshNode = doc.getElementsByTagName("refresh")[0];
					if (refreshNode) {
						refreshTimeout = parseInt(refreshNode.firstChild.data, 10);
						refreshTimeout = refreshTimeout * 1.1;
					}
					// Start timeout for remote active refresh
					dataSession.remoteActiveTimeoutId = setTimeout(function() {
						CrocSDK.Util.fireEvent(dataSession, 'onComposingStateChange', {
							state: CrocSDK.C.states.sdkComposing.IDLE
						});
					}, refreshTimeout * 1000);
				}

				if (sdkState !== prevSdkState) {
					CrocSDK.Util.fireEvent(dataSession, 'onComposingStateChange', {
						state: sdkState
					});
				}
			} else if (contentType === CrocSDK.C.MT.XHTML &&
					dataSession.hasOwnProperty('onXHTMLReceived') ||
					dataSession.dataApi.hasOwnProperty('onXHTMLReceived')) {
				CrocSDK.Util.fireEvent(dataSession, 'onXHTMLReceived', {
					address: dataSession.address,
					body: CrocSDK.Util.extractXHTMLBody(body)
				}, true);
			} else {
				// Fire the DataSession.onData event - the default implementation
				// of this just bubbles up to the top-level DataAPI event.
				CrocSDK.Util.fireEvent(dataSession, 'onData', {
					address: dataSession.address,
					contentType: contentType,
					data: body
				}, true);
			}

			// We're done with this TransferProgress object
			delete dataSession.recvTransferProgress[id];
		};
		eventObj.onMessageReceiveAborted = function(id, partialBody) {
			var tp = dataSession.recvTransferProgress[id];
			if (tp) {
				CrocSDK.Util.fireEvent(tp, 'onFailure', {
					partialData : partialBody
				});
			}

			// We're done with this TransferProgress object
			delete dataSession.recvTransferProgress[id];
		};
		eventObj.onMessageReceiveTimeout = function(id, partialBody) {
			var tp = dataSession.recvTransferProgress[id];
			if (tp) {
				CrocSDK.Util.fireEvent(tp, 'onFailure', {
					partialData : partialBody
				});
			}

			// We're done with this TransferProgress object
			delete dataSession.recvTransferProgress[id];
		};
	}

	function handleOutgoingSipSessionStarted(crocObject, dataSession, response,
			sendConfig, data, mimetype) {
		var capabilityApi = crocObject.capability;
		var msgId = dataSession.msrpSession.processSdpAnswer(response.body);

		if (msgId) {
			// Update data session properties
			dataSession.state = CrocSDK.C.states.dataSession.ESTABLISHED;
			dataSession.lastActivity = Date.now();
			var parsedContactHeader = response.parseHeader('contact', 0);
			dataSession.capabilities = capabilityApi.parseFeatureTags(
					parsedContactHeader.parameters);

			if (!sendConfig.fileTransfer) {
				// Send data now
				// Ignore existing msgId, as it was just for
				// the empty SEND message
				msgId = dataSession.msrpSession.send(data, mimetype);
			}

			// Create a transfer progress object if any event handlers are
			// provided
			if (sendConfig.onSuccess || sendConfig.onFailure || sendConfig.onProgress) {
				var filename = null, description = null;

				if (sendConfig.fileTransfer) {
					filename = sendConfig.fileTransfer.name;
					description = sendConfig.fileTransfer.description;
				}

				var chunkSender = dataSession.msrpSession.chunkSenders[msgId];
				var tp = new TransferProgress(dataSession, msgId, true,
						mimetype, chunkSender.size, filename, description);
				if (sendConfig.onSuccess) {
					tp.onSuccess = sendConfig.onSuccess;
				}
				if (sendConfig.onFailure) {
					tp.onFailure = sendConfig.onFailure;
				}
				if (sendConfig.onProgress) {
					tp.onProgress = sendConfig.onProgress;
				}
				dataSession.sendTransferProgress[msgId] = tp;
			}
		} else {
			// SDP processing failed
			dataSession.sipSession.terminate({
				status_code: 488
			});
			// SIP session is dead
			dataSession.sipSession = null;
			// First fire the send failure handler (with fudge for
			// exception debug)
			sendConfig.constructor = TransferProgress;
			CrocSDK.Util.fireEvent(sendConfig, 'onFailure', {
				partialData : null
			});
			// Clean up and notify application
			dataSession.close();
		}
	}

	/**
	 * TransferProgress object constructor. Though the constructor is private,
	 * the resulting object is exposed publicly.
	 * 
	 * @memberof CrocSDK.MsrpDataSession
	 * @constructor
	 * @inner
	 * @private
	 * @param dataSession
	 * @param msgId
	 * @param outbound
	 * @param contenType
	 * @param size
	 * @param filename
	 * @param description
	 */
	/**
	 * <p>
	 * {@link CrocSDK.MsrpDataSession~TransferProgress TransferProgress} objects
	 * allow control and monitoring of ongoing data transfers.
	 * </p>
	 * 
	 * <p>
	 * This enables web-apps to monitor (and display) the progress of data
	 * transfers (for example, file transfers) and abort individual transfers
	 * without terminating the data session.
	 * </p>
	 * 
	 * <p>
	 * Instances of this object are contained within the
	 * {@link CrocSDK.MsrpDataSession~TransferProgress~DataStartEvent DataStartEvent}
	 * object provided as an argument to the
	 * {@link CrocSDK.MsrpDataSession#event:onDataStart DataSession.onDataStart}
	 * event handler.
	 * </p>
	 * 
	 * <p>
	 * This example makes use of the 
	 * {@link CrocSDK.MsrpDataSession~TransferProgress TransferProgress} object
	 * to monitor incoming file transfers. The code to implement the progress 
	 * bar is not included.
	 *   <pre>
	 *   <code>
	 *     var crocObject = $.croc({
	 *       apiKey: "API_KEY_GOES_HERE",
	 *       onConnected: function () {
	 *         // Update the UI to show we are listening for incoming connections
	 *       },
	 *       
	 *       data: {
	 *         onDataSession: function(event) {
	 *           // Add event handler for file transfers on the new incoming session
	 *           event.session.onDataStart = function (event) {
	 *             // Create new progress bar for each file transfer
	 *             var bar = new MyAwesomeFileTransferProgressBar();
	 *             
	 *             // Enable the abort button on the UI
	 *             bar.onAbort = function () {
	 *               event.transferProgress.abort();
	 *             };
	 *             
	 *             // Add event handlers to the TransferProgress object to update the UI
	 *             event.transferProgress.onProgress = function (event) {
	 *               bar.updateProgress(event.percentComplete);
	 *             };
	 *             event.transferProgress.onSuccess = function (event) {
	 *               bar.addSaveLink(event.data);
	 *             };
	 *             event.transferProgress.onFailure = function (event) {
	 *               bar.transferFailed();
	 *             };
	 *           };
	 *           
	 *           // Accept the incoming session
	 *           event.session.accept();
	 *         }
	 *       }
	 *     });
	 *   </code>
	 *   </pre>
	 * </p> 
	 * 
	 * @memberof CrocSDK.MsrpDataSession
	 * @constructor
	 * @classdesc Represents a TransferProgress Object.
	 * @inner
	 * @type {CrocSDK.MsrpDataSession~TransferProgress}
	 */
	function TransferProgress(dataSession, msgId, outbound, contentType, size,
			filename, description) {
		// Internal properties (undocumented)
		this.msgId = msgId;
		this.outbound = outbound;

		// Public properties
		/**
		 * The DataSession instance used for this data transfer.
		 * 
		 * @type {CrocSDK.MsrpDataSession}
		 */
		this.session = dataSession;
		/**
		 * The MIME type of the data.
		 * 
		 * @type {String}
		 */
		this.contentType = contentType;
		/**
		 * The total size of the data (in bytes). May be <code>null</code> if
		 * not provided by the remote party.
		 * 
		 * @type {Number}
		 */
		this.size = size;
		/**
		 * The filename. May be <code>null</code> if not provided by the
		 * remote party (for example, if the data transfer is not a file).
		 * 
		 * @type {String}
		 */
		this.filename = filename;
		/**
		 * The description. May be <code>null</code> if not provided by the
		 * remote party (for example, if the data transfer is not a file).
		 * 
		 * @type {String}
		 */
		this.description = description;
	}

	/**
	 * Abort this data transfer.
	 * 
	 * @memberof CrocSDK.MsrpDataSession~TransferProgress
	 * @function CrocSDK.MsrpDataSession~TransferProgress#abort
	 */
	TransferProgress.prototype.abort = function() {
		if (this.outbound) {
			this.session.msrpSession.abortSend(this.msgId);
		} else {
			this.session.msrpSession.abortReceive(this.msgId);
		}
	};

	/**
	 * <p>
	 * Dispatched when the data transfer has completed successfully.
	 * </p>
	 * 
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * continue on without error.
	 * </p>
	 * 
	 * @memberof CrocSDK.MsrpDataSession~TransferProgress
	 * @event CrocSDK.MsrpDataSession~TransferProgress#onSuccess
	 * @param {CrocSDK.MsrpDataSession~TransferProgress~SuccessEvent} event
	 * The event object associated with this event.
	 */
	TransferProgress.prototype.onSuccess = function() {
		// Do nothing
	};
	/**
	 * <p>
	 * Dispatched when the data transfer has been aborted (either locally or
	 * remotely).
	 * </p>
	 * 
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * continue on without error.
	 * </p>
	 * 
	 * @memberof CrocSDK.MsrpDataSession~TransferProgress
	 * @event CrocSDK.MsrpDataSession~TransferProgress#onFailure
	 * @param {CrocSDK.MsrpDataSession~TransferProgress~FailureEvent} event
	 * The event object associated with this event.
	 */
	TransferProgress.prototype.onFailure = function() {
		// Do nothing
	};
	/**
	 * <p>
	 * Dispatched when a chunk of data has been received.
	 * </p>
	 * 
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * continue on without error.
	 * </p>
	 * 
	 * @memberof CrocSDK.MsrpDataSession~TransferProgress
	 * @event CrocSDK.MsrpDataSession~TransferProgress#onProgress
	 * @param {CrocSDK.MsrpDataSession~TransferProgress~ProgressEvent} event
	 * The event object associated with this event.
	 */
	TransferProgress.prototype.onProgress = function() {
		// Do nothing
	};

	/**
	 * MsrpDataSession object constructor. Though the constructor is private,
	 * the resulting object is exposed publicly.
	 * 
	 * @constructor
	 * @private
	 */
	/**
	 * <p>
	 * {@link CrocSDK.MsrpDataSession MsrpDataSession} objects allow control, 
	 * monitoring, and re-use of data-transfer sessions with other instances of
	 * Crocodile RTC JavaScript Library.
	 * </p>
	 * 
	 * <p>
	 * Instances of this object are provided as the return value of the
	 * {@link CrocSDK.DataAPI#send Data.send()} method and are also contained
	 * within the {@link CrocSDK.DataAPI~DataSessionEvent DataSessionEvent}
	 * object provided as an argument to the
	 * {@link CrocSDK.DataAPI#event:onDataSession Data.onDataSession} event handler.
	 * </p>
	 * 
	 * <p>
	 * The {@link CrocSDK.MsrpDataSession MsrpDataSession} object can be mostly
	 * ignored by simple applications that don't require explicit session-level
	 * control as the Crocodile RTC JavaScript Library will manage sessions 
	 * automatically. Web-apps that receive inbound data must use the 
	 * <code>accept()</code> method.
	 * </p>
	 * 
	 * <p>
	 * The simplest applications will only use the top-level send function and 
	 * onData handler; the only interaction with a session would be to 
	 * automatically accept it.
	 * </p>
	 * 
	 * <p>
	 * An example using Automatic session Management:
	 *   <pre>
	 *   <code>
	 *     var crocObject = $.croc({
	 *       apiKey: "API_KEY_GOES_HERE",
	 *       onConnected: function () {
	 *         this.data.send('bob@crocodilertc.net', 'Web application ready');
	 *       },
	 *       
	 *       data: {
	 *         onDataSession: function(event) {
	 *           // Accept every incoming session
	 *           event.session.accept();
	 *         },
	 *         onData: function(event) {
	 *           alert('Data received from ' + event.address + ':\n' + event.data);
	 *         }
	 *       }
	 *     });
	 *   </code>
	 *   </pre>
	 * </p>
	 * 
	 * <p>
	 * In this case the SDK handles the sessions automatically: re-using 
	 * sessions if they already exist to save the time involved in setting up 
	 * new sessions, but also closing them to save resources if they are unused 
	 * for a long time. If the application does not need to support incoming 
	 * sessions, then even the onSession handler can be dropped, and there are 
	 * no interactions with DataSession objects at all.
	 * </p>
	 * 
	 * @memberof CrocSDK
	 * @constructor
	 */
	function MsrpDataSession() {
	}

	/*
	 * Internal methods
	 */
	/**
	 * Setup of an MsrpDataSession constructor
	 * 
	 * @private
	 * @function CrocSDK.MsrpDataSession#init
	 * @param {CrocSDK.DataAPI} dataApi
	 * The parent DataAPI instance.
	 * @param {JsSIP.URI} uri
	 * The address of the user to establish a session with.
	 */
	MsrpDataSession.prototype.init = function(dataApi, uri) {
		var self = this;
		// Internal state
		this.dataApi = dataApi;
		this.uri = uri;
		this.sipSession = null;
		this.msrpSession = null;
		this.state = CrocSDK.C.states.dataSession.PENDING;
		this.lastActivity = Date.now();
		this.sendTransferProgress = {};
		this.recvTransferProgress = {};
		// Composing state timers
		this.localActiveRefreshIntervalId = null;
		this.localActiveTimeoutId = null;
		this.remoteActiveTimeoutId = null;

		// Frequently-used objects
		this.idleXml = CrocSDK.Util.createIsComposingXml(
				CrocSDK.C.states.rfcComposing.IDLE);
		this.isComposingSendConfig = {contentType: CrocSDK.C.MT.IS_COMPOSING};
		this.localActiveTimeout = function () {
			clearInterval(self.localActiveRefreshIntervalId);
			self.localActiveRefreshIntervalId = null;
			self.localActiveTimeoutId = null;
			self.send(self.idleXml, self.isComposingSendConfig);
		};

		// Public properties
		/**
		 * The address of the remote party.
		 * 
		 * @member CrocSDK.MsrpDataSession~address
		 * @instance
		 * @type {String}
		 */
		this.address = uri.toAor().replace(/^sip:/, '');
		/**
		 * The display name of the remote party.
		 * 
		 * @member CrocSDK.MsrpDataSession~displayName
		 * @instance
		 * @type {String}
		 */
		this.displayName = null;
		/**
		 * <p>
		 * Any custom headers provided during session initiation.
		 * </p>
		 * 
		 * <p>
		 * For inbound sessions these are provided by the remote party and for
		 * outbound sessions these are specified in the
		 * {@link CrocSDK.DataAPI~SendConfig SendConfig} object used as a
		 * parameter to the {@link CrocSDK.DataAPI#send Data.send()} method.
		 * </p>
		 * 
		 * <p>
		 * The header names are used as the key names in this object and the
		 * header contents are mapped to the key values.
		 * </p>
		 * 
		 * @member CrocSDK.MsrpDataSession~customHeaders
		 * @instance
		 * @type {CrocSDK~CustomHeaders}
		 */
		this.customHeaders = null;
		/**
		 * <p>
		 * The capabilities reported by the remote party. These are available
		 * immediately for inbound sessions and sessions to parties that are on
		 * the capabilities watch list (and for which a capabilities query
		 * response has been received). Capabilties for outbound sessions to
		 * addresses that are not on the capabilities watch list will not be
		 * available until the session has been accepted by the remote party.
		 * </p>
		 * 
		 * @member CrocSDK.MsrpDataSession~capabilities
		 * @instance
		 * @type {CrocSDK.Croc~Capabilities}
		 */
		this.capabilities = null;
		this.type = 'msrp';
	};

	/*
	 * Internal methods
	 */

	/**
	 * Checks whether this session should be considered idle, and thus closed
	 * by the periodic cleanup process.
	 * @private
	 * @param {int} idleThreshold - the idle threshold timestamp
	 * @returns {Boolean} 'true' if the session is currently idle
	 */
	MsrpDataSession.prototype._isIdle = function (idleThreshold) {
		return this.lastActivity < idleThreshold;
	};

	/*
	 * Public methods
	 */

	/**
	 * Send <code>data</code> using this session.
	 * <p>
	 * When transferring files, it is best practice to use a new session for each
	 * file. This allows the remote party to choose to accept or reject the
	 * transfer (based on the provided file details) before the transfer starts.
	 * 
	 * @function CrocSDK.MsrpDataSession#send
	 * @param {ArrayBuffer|Blob|File|String} data - The data to send.
	 * @param {CrocSDK.DataAPI~SendConfig} [config] Optional extra
	 * configuration that can be provided when sending data.  If this object is
	 * omitted, the defaults will be used.
	 * @throws {TypeError}
	 * @throws {CrocSDK.Exceptions#ValueError}
	 * @throws {CrocSDK.Exceptions#StateError}
	 */
	MsrpDataSession.prototype.send = function(data, config) {
		var mimetype = null, filename = null, description = null;

		if (this.state !== CrocSDK.C.states.dataSession.ESTABLISHED) {
			throw new CrocSDK.Exceptions.StateError(
					'Cannot call send() in current state: ' + this.state);
		}

		if (config) {
			CrocSDK.Util.checkSendConfig(config);
			mimetype = config.contentType;

			if (config.fileTransfer) {
				filename = config.fileTransfer.name;
				description = config.fileTransfer.description;
			}
		}

		var msgId = this.msrpSession.send(data, mimetype);
		this.lastActivity = Date.now();

		// Clear local composing timers/intervals
		if (this.localActiveRefreshIntervalId) {
			clearInterval(this.localActiveRefreshIntervalId);
			this.localActiveRefreshIntervalId = null;
		}
		if (this.localActiveTimeoutId) {
			clearTimeout(this.localActiveTimeoutId);
			this.localActiveTimeoutId = null;
		}

		// Create a transfer progress object if any event handlers are provided
		if (config.onSuccess || config.onFailure || config.onProgress) {
			var chunkSender = this.msrpSession.chunkSenders[msgId];
			var tp = new TransferProgress(this, msgId, true,
					chunkSender.contentType, chunkSender.size, filename,
					description);
			if (config.onSuccess) {
				tp.onSuccess = config.onSuccess;
			}
			if (config.onFailure) {
				tp.onFailure = config.onFailure;
			}
			if (config.onProgress) {
				tp.onProgress = config.onProgress;
			}
			this.sendTransferProgress[msgId] = tp;
		}
	};
	
	/**
	 * Send the provided XHTML <code>body</code> using this session.
	 * 
	 * @param {DocumentFragment|string} body - The body of the message.
	 * @param {CrocSDK.DataAPI~SendConfig} [config] - Optional extra
	 * configuration that can be provided when sending data.  If this object is
	 * omitted, the defaults will be used.
	 * @throws {TypeError}
	 * @throws {CrocSDK.Exceptions#ValueError}
	 * @throws {CrocSDK.Exceptions#StateError}
	 */
	MsrpDataSession.prototype.sendXHTML = function(body, config) {
		config = config || {};
		config.contentType = CrocSDK.C.MT.XHTML;

		var xhtml = CrocSDK.Util.createValidXHTMLDoc(body);
		this.send(xhtml, config);
	};

	/**
	 * Set the local composing state for this session.
	 * 
	 * @param {String} [state] - Should be set to <code>'composing'</code> or
	 * <code>'idle'</code>.  Defaults to <code>'composing'</code> if not
	 * specified.
	 * @throws {CrocSDK.Exceptions#StateError}
	 */
	MsrpDataSession.prototype.setComposingState = function(state) {
		var session = this;
		state = state || CrocSDK.C.states.sdkComposing.COMPOSING;

		if (this.localActiveTimeoutId) {
			// We're currently in the COMPOSING state
			// Clear the old idle timeout
			clearTimeout(this.localActiveTimeoutId);

			if (state === CrocSDK.C.states.sdkComposing.IDLE) {
				// We're changing state to IDLE - send an update
				this.send(this.idleXml, this.isComposingSendConfig);
			}
		}

		if (state === CrocSDK.C.states.sdkComposing.COMPOSING) {
			if (!this.localActiveRefreshIntervalId) {
				// We're currently in the IDLE state
				// We're changing state to COMPOSING - send an update
				var refreshInterval = this.dataApi.idleTimeout / 2;
				var compXml = CrocSDK.Util.createIsComposingXml(state, refreshInterval);

				this.send(compXml, this.isComposingSendConfig);

				// Set up the active refresh interval
				this.localActiveRefreshIntervalId = setInterval(function () {
					session.send(compXml, session.isComposingSendConfig);
				}, refreshInterval * 1000);
			}

			// Set the active->idle timeout
			this.localActiveTimeoutId = setTimeout(this.localActiveTimeout,
					CrocSDK.C.COMPOSING_TIMEOUT * 1000);
		}
	};

	/**
	 * <p>
	 * Accept the inbound data session. A session must be accepted before any
	 * data can be sent or received.
	 * </p>
	 * 
	 * <p>
	 * Sessions that are not accepted within the configured
	 * <code>Data.acceptTimeout</code> will be rejected by the Crocodile RTC
	 * JavaScript Library.
	 * </p>
	 * 
	 * <p>
	 * Exceptions: {@link CrocSDK.Exceptions#StateError StateError}
	 * </p>
	 * 
	 * @function CrocSDK.MsrpDataSession#accept
	 */
	MsrpDataSession.prototype.accept = function() {
		throw new CrocSDK.Exceptions.StateError('Cannot call accept() on outgoing sessions');
	};

	/**
	 * <p>
	 * Explicitly close this data session. If <code>accept()</code> has not
	 * been called the session will be rejected.
	 * </p>
	 * 
	 * <p>
	 * Data transfers in progress on the session will be aborted when this
	 * method is called.
	 * </p>
	 * 
	 * <p>
	 * Valid status are:
	 * <ul>
	 * <li><code>normal</code> - reject the session with a busy indication.</li>
	 * <li><code>blocked</code> - reject the session indicating the initiator
	 * of the session is on a block-list.</li>
	 * <li><code>offline</code> - reject the session indicating the instance
	 * of Crocodile RTC JavaScript Library is offline. The initiator of the
	 * session cannot distinguish between appearing offline and actually
	 * offline.</li>
	 * <li><code>notfound</code> - reject the session indicating the instance
	 * of Crocodile RTC JavaScript Library does not exist. The initiator of the
	 * session cannot distinguish between appearing to not exist and actually
	 * not existing.</li>
	 * </ul>
	 * </p>
	 * <p>
	 * If the <code>status</code> argument is not provided it will default to
	 * <code>normal</code>.
	 * </p>
	 * 
	 * <p>
	 * Exceptions: TypeError, {@link CrocSDK.Exceptions#ValueError ValueError}
	 * </p>
	 * 
	 * @function CrocSDK.MsrpDataSession#close
	 */
	MsrpDataSession.prototype.close = function(status) {
		if (this.state === CrocSDK.C.states.dataSession.CLOSED) {
			return;
		}

		var oldState = this.state;
		this.state = CrocSDK.C.states.dataSession.CLOSED;

		if (!status) {
			status = 'normal';
		}

		// Clean up any established sessions
		if (this.msrpSession) {
			try {
				this.msrpSession.close();
			} catch (e) {
				console.error('Error closing MSRP session:\n', e.stack);
			}
		}

		if (this.sipSession) {
			var terminateOptions = null;
			if (oldState === CrocSDK.C.states.dataSession.PENDING &&
					this.sipSession.direction === 'incoming') {
				// Rejecting the session
				var sipStatus = CrocSDK.Util.sdkStatusToSipStatus('invite',
						status);
				terminateOptions = {
					status_code : sipStatus
				};
			}

			try {
				this.sipSession.terminate(terminateOptions);
			} catch (e) {
				console.error('Error terminating SIP session:\n', e.stack);
			}
		}
		
		// Clean up any composing state timers/intervals
		if (this.localActiveRefreshIntervalId) {
			clearInterval(this.localActiveRefreshIntervalId);
			this.localActiveRefreshIntervalId = null;
		}
		if (this.localActiveTimeoutId) {
			clearTimeout(this.localActiveTimeoutId);
			this.localActiveTimeoutId = null;
		}
		if (this.remoteActiveTimeoutId) {
			clearTimeout(this.remoteActiveTimeoutId);
			this.remoteActiveTimeoutId = null;
		}


		// Notify application
		CrocSDK.Util.fireEvent(this, 'onClose', {
			status : status
		});
	};

	/**
	 * <p>
	 * Returns a String representing the session state. The state will be one of
	 * pending, established, or closed.
	 * </p>
	 * 
	 * <p>
	 * Exceptions: <i>none</i>
	 * </p>
	 * 
	 * @function CrocSDK.MsrpDataSession#getState
	 */
	MsrpDataSession.prototype.getState = function() {
		return this.state;
	};

	/*
	 * Public events
	 */

	/**
	 * Dispatched when data is received on this session.
	 * <p>
	 * This event is generated once per call to <code>send()</code> by the
	 * remote party.
	 * <p>
	 * If you need to get progress updates during large transfers, you must add
	 * an event handler for the <code>onDataStart</code> event to get access
	 * to the associated
	 * {@link CrocSDK.MsrpDataSession~TransferProgress TransferProgress} object
	 * instance.
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will
	 * attempt to fire the top-level
	 * {@link CrocSDK.DataAPI#event:onData Data.onData()} handler.
	 * 
	 * @event CrocSDK.MsrpDataSession#onData
	 * @param {CrocSDK.DataAPI~DataEvent} event - The event object assocated
	 * with this event.
	 */
	MsrpDataSession.prototype.onData = function(event) {
		// Default behaviour is to fire the top-level onData event
		this.dataApi.onData(event);
	};

	/**
	 * Dispatched when an XHTML body (rich text) is received on this session.
	 * <p>
	 * This event is generated once per call to <code>sendXHTML()</code> by the
	 * remote party.
	 * <p>
	 * If this event is not handled the received data will be discarded.
	 * 
	 * @event CrocSDK.MsrpDataSession#onXHTMLReceived
	 * @param {CrocSDK.DataAPI~XHTMLReceivedEvent} event - The event object
	 * associated with this event.
	 */
	MsrpDataSession.prototype.onXHTMLReceived = function(event) {
		// Default behaviour is to fire the top-level onXHTMLReceived event
		this.dataApi.onXHTMLReceived(event);
	};
	
	/**
	 * Dispatched whenever the composing state of the remote party changes.
	 * 
	 * @event CrocSDK.MsrpDataSession#onComposingStateChange
	 * @param {CrocSDK.MsrpDataSession~ComposingStateChangeEvent} event - The
	 * event object associated with this event.
	 */

	/**
	 * <p>
	 * Dispatched when Crocodile RTC JavaScript Library receives the first chunk
	 * of data for a transfer.
	 * </p>
	 * 
	 * <p>
	 * Add a handler for this event if you want to access the associated
	 * {@link CrocSDK.MsrpDataSession~TransferProgress TransferProgress} object
	 * instance, which can be used to get process updated during large
	 * transfers.
	 * </p>
	 * 
	 * <p>
	 * If this event is not handled the Crocodile RTC JavaScript Library will do
	 * nothing and the <code>onData()</code> event will fire when the transfer
	 * has completed.
	 * </p>
	 * 
	 * @event CrocSDK.MsrpDataSession#onDataStart
	 * @param {CrocSDK.MsrpDataSession~DataStartEvent} event - The event object
	 * assocated with this event.
	 */
	MsrpDataSession.prototype.onDataStart = function() {
		// Do nothing
	};

	/**
	 * @event CrocSDK.MsrpDataSession#onClose
	 * @param {CrocSDK.MediaAPI~MediaSession~CloseEvent} event - The event object
	 * assocated with this event. 
	 * */
	MsrpDataSession.prototype.onClose = function() {
		// Do nothing
	};

	CrocSDK.OutgoingMsrpSession = function(dataApi, uri, data, sendConfig) {
		var msrpCon = getNextMsrpConnection(dataApi);
		var eventObj = {};
		var mimetype = sendConfig.contentType || data.type;
		var dataSession = this;
		var crocObject = dataApi.crocObject;
		var capabilityApi = crocObject.capability;

		this.init(dataApi, uri);
		if (sendConfig.customHeaders instanceof CrocSDK.CustomHeaders) {
			this.customHeaders = sendConfig.customHeaders;
		} else {
			this.customHeaders = new CrocSDK.CustomHeaders(sendConfig.customHeaders);
		}
		// Start with cached capabilities if we have them
		this.capabilities = capabilityApi.getCapabilities(uri);

		if (!mimetype) {
			if (CrocSDK.Util.isType(data, 'string')) {
				mimetype = 'text/plain';
			} else {
				mimetype = 'application/octet-stream';
			}
		}

		// Configure behaviour when MSRP authenticates
		eventObj.onAuthenticated = function() {
			var sipEventHandlers = {
				started : function(event) {
					handleOutgoingSipSessionStarted(crocObject, dataSession,
							event.data.response, sendConfig, data, mimetype);
				},
				ended : function(event) {
					var edata = event.data;
					if (edata.originator !== 'local') {
						var status = CrocSDK.Util.jsSipCauseToSdkStatus(edata.cause);
						// SIP session is dead
						dataSession.sipSession = null;
						// Clean up and notify application
						dataSession.close(status);
					}
				},
				failed : function(event) {
					var status = CrocSDK.Util.jsSipCauseToSdkStatus(event.data.cause);
					// SIP session is dead
					dataSession.sipSession = null;
					// First fire the send failure handler (with fudge for
					// exception debug)
					sendConfig.constructor = TransferProgress;
					CrocSDK.Util.fireEvent(sendConfig, 'onFailure', {
						partialData : null
					});
					// Clean up and notify application
					dataSession.close(status);
					// Auth failures should trigger croc object to stop
					if (event.data.cause === JsSIP.C.causes.AUTHENTICATION_ERROR) {
						crocObject.stop();
					}
				}
			};

			var sipOptions = {
				eventHandlers : sipEventHandlers,
				extraHeaders : dataSession.customHeaders.toExtraHeaders(),
				featureTags : capabilityApi.createFeatureTags(crocObject.capabilities),
				sdp : dataSession.msrpSession.getSdpOffer()
			};

			dataSession.sipSession = new JsSIP.RTCSession(crocObject.sipUA);
			dataSession.sipSession.connect(uri, sipOptions);
		};

		addSharedMsrpEvents(dataSession, eventObj);

		// Start by creating an MSRP session and awaiting authentication:
		// only then can we create the SDP offer.
		if (sendConfig.fileTransfer) {
			var fileParams = new CrocMSRP.FileParams();

			fileParams.selector.name = sendConfig.fileTransfer.name;
			fileParams.selector.type = mimetype;
			fileParams.selector.size = sendConfig.fileTransfer.size;
			fileParams.description = sendConfig.fileTransfer.description;

			this.msrpSession = msrpCon.createFileTransferSession(eventObj,
					data, fileParams);
		} else {
			this.msrpSession = msrpCon.createSession(eventObj);
		}
	};

	CrocSDK.OutgoingMsrpSession.prototype = new MsrpDataSession();
	CrocSDK.OutgoingMsrpSession.prototype.contructor = CrocSDK.OutgoingMsrpSession;

	CrocSDK.IncomingMsrpSession = function(dataApi, sipSession, sipRequest) {
		var msrpCon = getNextMsrpConnection(dataApi);
		var eventObj = {};
		var dataSession = this;
		var capabilityApi = dataApi.crocObject.capability;

		this.init(dataApi, sipSession.remote_identity.uri);
		this.sipSession = sipSession;
		this.displayName = sipSession.remote_identity.display_name;
		this.customHeaders = new CrocSDK.CustomHeaders(sipRequest);
		// Process remote capabilities
		var parsedContactHeader = sipRequest.parseHeader('contact', 0);
		this.capabilities = capabilityApi.parseFeatureTags(parsedContactHeader.parameters);
		this.accepted = false;

		// Configure behaviour when MSRP authenticates
		eventObj.onAuthenticated = function() {
			var answer = dataSession.msrpSession.getSdpAnswer(sipRequest.body);

			if (answer) {
				if (dataSession.accepted) {
					// Session has already been accepted; send the SDP answer.
					dataSession.state = CrocSDK.C.states.dataSession.ESTABLISHED;
					dataSession.sipSession.answer({
						sdp : answer
					});
				} else {
					// Session not yet accepted; override the accept method
					// to send the SDP answer.
					dataSession.accept = function() {
						this.state = CrocSDK.C.states.dataSession.ESTABLISHED;
						this.sipSession.answer({
							sdp : answer
						});
						// Remove the override method
						delete this.accept;
					};
				}
			} else {
				// Clean up and notify application
				dataSession.close();
			}
		};

		addSharedMsrpEvents(dataSession, eventObj);

		// Start by creating an MSRP session and awaiting authentication:
		// only then can we create the SDP answer.
		this.msrpSession = msrpCon.createSession(eventObj);

		// Configure JsSIP session event handlers
		sipSession.on('ended', function(event) {
			var edata = event.data;
			if (edata.originator !== 'local') {
				var status = CrocSDK.Util.jsSipCauseToSdkStatus(edata.cause);
				// SIP session is dead
				dataSession.sipSession = null;
				// Clean up and notify application
				dataSession.close(status);
			}
		});

		sipSession.on('failed', function(event) {
			var status = CrocSDK.Util.jsSipCauseToSdkStatus(event.data.cause);
			// SIP session is dead
			dataSession.sipSession = null;
			// Clean up and notify application
			dataSession.close(status);
		});
	};

	CrocSDK.IncomingMsrpSession.prototype = new MsrpDataSession();
	CrocSDK.IncomingMsrpSession.prototype.contructor = CrocSDK.IncomingMsrpSession;

	CrocSDK.IncomingMsrpSession.prototype.accept = function() {
		if (this.state === CrocSDK.C.states.dataSession.PENDING) {
			this.accepted = true;
		} else {
			throw new CrocSDK.Exceptions.StateError('Session has already been accepted');
		}
	};
	
	/* Further Documentation */
	// Type Definitions
	/**
	 * @memberof CrocSDK.MsrpDataSession~TransferProgress
	 * @typedef CrocSDK.MsrpDataSession~TransferProgress~DataStartEvent
	 * @property {CrocSDK.MsrpDataSession~TransferProgress} transferprogress 
	 * The {@link CrocSDK.MsrpDataSession~TransferProgress TransferProgress} 
	 * object instance that may be used to monitor and control the data 
	 * transfer. 
	 */
	/**
	 * @memberof CrocSDK.MsrpDataSession~TransferProgress
	 * @typedef CrocSDK.MsrpDataSession~TransferProgress~FailureEvent
	 * @property {ArrayBuffer|Blob|String} partialData The data received up to 
	 * the abort/failure. Text data will be presented as String. Binary data 
	 * will be presented as ArrayBuffer or Blob, depending on the expected size
	 * of the data.
	 */
	/**
	 * @memberof CrocSDK.MsrpDataSession~TransferProgress
	 * @typedef CrocSDK.MsrpDataSession~TransferProgress~ProgressEvent
	 * @property {Number} bytesComplete The number of bytes transfered so far.
	 * @property {Number} percentComplete The percentage of the data transfered
	 * so far. Set to null if the total size of the data is not known. 
	 */
	/**
	 * @memberof CrocSDK.MsrpDataSession~TransferProgress
	 * @typedef CrocSDK.MsrpDataSession~TransferProgress~SuccessEvent
	 * @property {ArrayBuffer|Blob|String} data The received <code>data</code>.
	 * Text data will be presented as String. Binary data will be presented as 
	 * ArrayBuffer or Blob, depending on the size of the data.
	 */
}(CrocSDK));

(function(CrocSDK) {
	var lineEnd = '\r\n';
	// The NTP epoch is 1/1/1900
	var unixToNtpOffset = 2208988800;

	function ntpTimeToDate(ntpTime) {
		return new Date((parseInt(ntpTime, 10) - unixToNtpOffset) * 1000);
	}
	
	function dateToNtpTime(date) {
		return parseInt(date.getTime() / 1000, 10) + unixToNtpOffset;
	}
	
	/**
	 * Encodes a string as an SDP filename-string, as defined in RFC 5547.
	 * @private
	 * @param {String} str The string to encode.
	 * @returns {String} The encoded string.
	 */
//	function encodeSdpFileName(str) {
//		return str.replace(/%/g, '%25')
//			.replace(/\0/g, '%00')
//			.replace(/\n/g, '%0A')
//			.replace(/\r/g, '%0D')
//			.replace(/"/g, '%22');
//	}

	/**
	 * Decodes an SDP filename-string, as defined in RFC 5547.
	 * @private
	 * @param {String} str The string to decode.
	 * @returns {String} The decoded string.
	 */
	function decodeSdpFileName(str) {
		return str.replace(/%00/g, '\0')
			.replace(/%0A/gi, '\n')
			.replace(/%0D/gi, '\r')
			.replace(/%22/g, '"')
			.replace(/%25/g, '%');
	}

	/**
	 * @namespace Encapsulates all of the SDP classes.
	 * @private
	 */
	CrocSDK.Sdp = {};
	
	CrocSDK.Sdp.Session = function(sdp) {
		if (sdp) {
			// Parse the provided SDP
			if (!this.parse(sdp)) {
				return null;
			}
		} else {
			// Set some sensible defaults
			this.reset();
		}
	};
	CrocSDK.Sdp.Session.prototype.reset = function() {
		this.version = 0;
		this.origin = new CrocSDK.Sdp.Origin();
		this.sessionName = ' ';
		this.sessionInfo = null;
		this.uri = null;
		this.email = null;
		this.phone = null;
		this.connection = new CrocSDK.Sdp.Connection();
		this.bandwidth = [];
		this.timing = [new CrocSDK.Sdp.Timing()];
		this.timezone = null;
		this.key = null;
		this.resetAttributes();
		this.media = [];
	};
	CrocSDK.Sdp.Session.prototype.addAttribute = function(name, value) {
		if (!this.attributes[name]) {
			this.attributes[name] = [];
			this.attributeNameOrder.push(name);
		}
		this.attributes[name].push(value);
	};
	CrocSDK.Sdp.Session.prototype.removeAttribute = function(name) {
		if (this.attributes[name]) {
			delete this.attributes[name];
			this.attributeNameOrder.splice(
					this.attributeNameOrder.indexOf(name), 1);
		}
	};
	CrocSDK.Sdp.Session.prototype.replaceAttribute = function(oldName, newName, newValue) {
		if (this.attributes[oldName]) {
			delete this.attributes[oldName];
			this.addAttribute(newName, newValue);
			this.attributeNameOrder.splice(this.attributeNameOrder.lastIndexOf(newName), 1);
			this.attributeNameOrder.splice(
					this.attributeNameOrder.indexOf(oldName), 1, newName);
		}
	};
	CrocSDK.Sdp.Session.prototype.resetAttributes = function() {
		this.attributeNameOrder = [];
		this.attributes = {};
	};
	CrocSDK.Sdp.Session.prototype.parse = function(sdp) {
		var line, lines = sdp.split(lineEnd), value, colonIndex, aName;
		
		this.reset();
		
		if (lines[lines.length - 1] === '') {
			// SDP ends in CRLF; remove final array index
			lines.pop();
		}
		
		if (lines.length < 4) {
			console.log('Unexpected SDP length: ' + lines.length);
			return false;
		}
		
		line = lines.shift();
		if (line !== 'v=0') {
			console.log('Unexpected SDP version: ' + line);
			return false;
		}
		
		line = lines.shift();
		if (line.substr(0, 2) !== 'o=' ||
				!(this.origin = new CrocSDK.Sdp.Origin(line.substr(2)))) {
			console.log('Unexpected SDP origin: ' + line);
			return false;
		}
		
		line = lines.shift();
		if (line.substr(0, 2) === 's=') {
			this.sessionName = line.substr(2);
		} else {
			console.log('Unexpected SDP session name: ' + line);
			return false;
		}
		
		// Process any other optional pre-timing lines
		while (lines.length > 0 && lines[0].charAt(0) !== 't') {
			line = lines.shift();
			value = line.substr(2);
			
			switch (line.substr(0, 2)) {
			case 'i=':
				this.sessionInfo = value;
				break;
			case 'u=':
				this.uri = value;
				break;
			case 'e=':
				this.email = value;
				break;
			case 'p=':
				this.phone = value;
				break;
			case 'c=':
				value = new CrocSDK.Sdp.Connection(value);
				if (!value) {
					return false;
				}
				this.connection = value;
				break;
			case 'b=':
				this.bandwidth.push(value);
				break;
			default:
				console.log('Unexpected SDP line (pre-timing): ' + line);
				return false;
			}
		}
		
		if (lines.length === 0) {
			console.log('Unexpected end of SDP (pre-timing)');
			return false;
		}
		
		this.timing = [];
		while (lines.length > 0 && lines[0].charAt(0) === 't') {
			line = lines.shift().substr(2);
			// Append any following r-lines
			while (lines.length > 0 && lines[0].charAt(0) === 'r') {
				line += lineEnd + lines.shift();
			}
			
			value = new CrocSDK.Sdp.Timing(line);
			if (!value) {
				return false;
			}
			this.timing.push(value);
		}

		if (this.timing.length === 0) {
			console.log('No timing line found');
			return false;
		}
		
		// Process any optional pre-media lines
		while (lines.length > 0 && lines[0].charAt(0) !== 'm') {
			line = lines.shift();
			value = line.substr(2);
			
			switch (line.substr(0, 2)) {
			case 'z=':
				this.timezone = value;
				break;
			case 'k=':
				this.key = value;
				break;
			case 'a=':
				colonIndex = value.indexOf(':');
				if (colonIndex === -1) {
					aName = value;
					value = null;
				} else {
					aName = value.substr(0, colonIndex);
					value = value.substr(colonIndex + 1);
				}
				this.addAttribute(aName, value);
				break;
			default:
				console.log('Unexpected SDP line (pre-media): ' + line);
				return false;
			}
		}
		
		while (lines.length > 0 && lines[0].charAt(0) === 'm') {
			line = lines.shift().substr(2);
			// Append any following lines up to the next m-line
			while (lines.length > 0 && lines[0].charAt(0) !== 'm') {
				line += lineEnd + lines.shift();
			}

			value = new CrocSDK.Sdp.Media(line);
			if (!value) {
				return false;
			}
			this.media.push(value);
		}

		return true;
	};
	CrocSDK.Sdp.Session.prototype.toString = function() {
		var sdp = '', index, aName, aValues;
		
		sdp += 'v=' + this.version + lineEnd;
		sdp += 'o=' + this.origin + lineEnd;
		sdp += 's=' + this.sessionName + lineEnd;
		if (this.sessionInfo) {
			sdp += 'i=' + this.sessionInfo + lineEnd;
		}
		if (this.uri) {
			sdp += 'u=' + this.uri + lineEnd;
		}
		if (this.email) {
			sdp += 'e=' + this.email + lineEnd;
		}
		if (this.phone) {
			sdp += 'p=' + this.phone + lineEnd;
		}
		if (this.connection) {
			sdp += 'c=' + this.connection + lineEnd;
		}
		for (index in this.bandwidth) {
			sdp += 'b=' + this.bandwidth[index] + lineEnd;
		}
		for (index in this.timing) {
			sdp += 't=' + this.timing[index] + lineEnd;
		}
		if (this.timezone) {
			sdp += 'z=' + this.timezone + lineEnd;
		}
		if (this.key) {
			sdp += 'k=' + this.key + lineEnd;
		}
		for (var i = 0, len = this.attributeNameOrder.length; i < len; i++) {
			aName = this.attributeNameOrder[i];
			aValues = this.attributes[aName];

			for (index in aValues) {
				sdp += 'a=' + aName;
				if (aValues[index]) {
					sdp += ':' + aValues[index];
				}
				sdp += lineEnd;
			}
		}
		for (index in this.media) {
			sdp += 'm=' + this.media[index] + lineEnd;
		}
		
		return sdp;
	};
	/**
	 * Checks whether the local party is on hold. Assumes that the current
	 * session description has been received from the remote party.
	 * @private
	 * @returns {Boolean}
	 */
	CrocSDK.Sdp.Session.prototype.isHeld = function() {
		var i, len, mline;
		for (i = 0, len = this.media.length; i < len; i++) {
			mline = this.media[i];
			// Only check audio/video streams
			switch (mline.media) {
			case 'audio':
			case 'video':
				if (mline.isReceiving()) {
					// The remote party is receiving at least one stream
					return false;
				}
				break;
			}
		}
		// If we've got this far, the remote party does not want to receive
		// media for any of the relevant streams.
		return true;
	};

	CrocSDK.Sdp.Origin = function(origin) {
		if (origin) {
			// Parse the provided origin line
			if (!this.parse(origin)) {
				return null;
			}
		} else {
			// Set some sensible defaults
			this.reset();
		}
	};
	CrocSDK.Sdp.Origin.prototype.reset = function() {
		this.username = '-';
		this.id = dateToNtpTime(new Date());
		this.version = this.sessId;
		this.netType = 'IN';
		this.addrType = 'IP4';
		this.address = 'address.invalid';
	};
	CrocSDK.Sdp.Origin.prototype.parse = function(origin) {
		var split;
		
		split = origin.split(' ');
		if (split.length !== 6) {
			console.log('Unexpected origin line: ' + origin);
			return false;
		}

		this.username = split[0];
		this.id = split[1];
		this.version = split[2];
		this.netType = split[3];
		this.addrType = split[4];
		this.address = split[5];
		
		return true;
	};
	CrocSDK.Sdp.Origin.prototype.toString = function() {
		var o = '';
		
		o += this.username + ' ';
		o += this.id + ' ';
		o += this.version + ' ';
		o += this.netType + ' ';
		o += this.addrType + ' ';
		o += this.address;
		
		return o;
	};

	CrocSDK.Sdp.Connection = function(con) {
		if (con) {
			// Parse the provided connection line
			if (!this.parse(con)) {
				return null;
			}
		} else {
			// Set some sensible defaults
			this.reset();
		}
	};
	CrocSDK.Sdp.Connection.prototype.reset = function() {
		this.netType = 'IN';
		this.addrType = 'IP4';
		this.address = 'address.invalid';
	};
	CrocSDK.Sdp.Connection.prototype.parse = function(con) {
		var split;
		
		split = con.split(' ');
		if (split.length !== 3) {
			console.log('Unexpected connection line: ' + con);
			return false;
		}

		this.netType = split[0];
		this.addrType = split[1];
		this.address = split[2];
		
		return true;
	};
	CrocSDK.Sdp.Connection.prototype.toString = function() {
		var c = '';
		
		c += this.netType + ' ';
		c += this.addrType + ' ';
		c += this.address;
		
		return c;
	};

	CrocSDK.Sdp.Timing = function(timing) {
		if (timing) {
			// Parse the provided timing line
			if (!this.parse(timing)) {
				return null;
			}
		} else {
			// Set some sensible defaults
			this.reset();
		}
	};
	CrocSDK.Sdp.Timing.prototype.reset = function() {
		this.start = null;
		this.stop = null;
		this.repeat = [];
	};
	// Parse expects to be passed the full t-line, plus any following r-lines
	CrocSDK.Sdp.Timing.prototype.parse = function(timing) {
		var lines, tLine, tokens;
		
		lines = timing.split(lineEnd);
		tLine = lines.shift();
		
		tokens = tLine.split(' ');
		if (tokens.length !== 2) {
			console.log('Unexpected timing line: ' + tLine);
			return false;
		}

		if (tokens[0] === '0') {
			this.start = null;
		} else {
			this.start = ntpTimeToDate(tokens[0]);
		}
		
		if (tokens[1] === '0') {
			this.stop = null;
		} else {
			this.stop =  ntpTimeToDate(tokens[1]);
		}
		
		// Don't care about repeat lines at the moment
		this.repeat = lines;
		
		return true;
	};
	CrocSDK.Sdp.Timing.prototype.toString = function() {
		var t = '', index;
		
		if (this.start) {
			t +=  dateToNtpTime(this.start);
		} else {
			t += '0';
		}
		t += ' ';
		if (this.stop) {
			t +=  dateToNtpTime(this.stop);
		} else {
			t += '0';
		}
		
		for (index in this.repeat) {
			t += lineEnd + this.repeat[index];
		}
		
		return t;
	};

	CrocSDK.Sdp.Media = function(media) {
		if (media) {
			// Parse the provided connection line
			if (!this.parse(media)) {
				return null;
			}
		} else {
			// Set some sensible defaults
			this.reset();
		}
	};
	CrocSDK.Sdp.Media.prototype.reset = function() {
		this.media = 'message';
		this.port = 2855;
		this.proto = 'TCP/MSRP';
		this.format = '*';
		this.title = null;
		this.connection = null;
		this.bandwidth = [];
		this.key = null;
		this.resetAttributes();
	};
	CrocSDK.Sdp.Media.prototype.addAttribute = function(name, value) {
		if (!this.attributes[name]) {
			this.attributes[name] = [];
			this.attributeNameOrder.push(name);
		}
		this.attributes[name].push(value);
	};
	CrocSDK.Sdp.Media.prototype.removeAttribute = function(name) {
		if (this.attributes[name]) {
			delete this.attributes[name];
			this.attributeNameOrder.splice(
					this.attributeNameOrder.indexOf(name), 1);
		}
	};
	CrocSDK.Sdp.Media.prototype.resetAttributes = function() {
		this.attributeNameOrder = [];
		this.attributes = {};
	};
	CrocSDK.Sdp.Media.prototype.replaceAttribute = function(oldName, newName, newValue) {
		if (this.attributes[oldName]) {
			delete this.attributes[oldName];
			this.addAttribute(newName, newValue);
			this.attributeNameOrder.splice(this.attributeNameOrder.lastIndexOf(newName), 1);
			this.attributeNameOrder.splice(
					this.attributeNameOrder.indexOf(oldName), 1, newName);
		}
	};
	CrocSDK.Sdp.Media.prototype.parse = function(media) {
		var lines, mLine, tokens, index, aName;
		
		this.reset();
		
		lines = media.split(lineEnd);
		mLine = lines.shift();
		
		tokens = mLine.split(' ');
		if (tokens.length < 4) {
			console.log('Unexpected media line: ' + mLine);
			return false;
		}

		this.media = tokens.shift();
		this.port = parseInt(tokens.shift(), 10);
		this.proto = tokens.shift();
		this.format = tokens.join(' ');
		
		for (index in lines) {
			var value = lines[index].substr(2), colonIndex;
			
			switch (lines[index].substr(0, 2)) {
			case 'i=':
				this.title = value;
				break;
			case 'c=':
				this.connection = new CrocSDK.Sdp.Connection(value);
				if (!this.connection) {
					return false;
				}
				break;
			case 'b=':
				this.bandwidth.push(value);
				break;
			case 'k=':
				this.key = value;
				break;
			case 'a=':
				colonIndex = value.indexOf(':');
				if (colonIndex === -1) {
					aName = value;
					value = null;
				} else {
					aName = value.substr(0, colonIndex);
					value = value.substr(colonIndex + 1);
				}
				this.addAttribute(aName, value);
				break;
			default:
				console.log('Unexpected type (within media): ' + lines[index]);
				return false;
			}
		}
		
		return true;
	};
	CrocSDK.Sdp.Media.prototype.toString = function() {
		var m = '', index, aName, aValues;
		
		m += this.media + ' ';
		m += this.port + ' ';
		m += this.proto + ' ';
		m += this.format;
		
		if (this.title) {
			m += lineEnd + 'i=' + this.title;
		}
		if (this.connection) {
			m += lineEnd + 'c=' + this.connection;
		}
		for (index in this.bandwidth) {
			m += lineEnd + 'b=' + this.bandwidth[index];
		}
		if (this.key) {
			m += lineEnd + 'k=' + this.key;
		}
		for (var i = 0, len = this.attributeNameOrder.length; i < len; i++) {
			aName = this.attributeNameOrder[i];
			aValues = this.attributes[aName];

			for (index in aValues) {
				m += lineEnd + 'a=' + aName;
				if (aValues[index]) {
					m += ':' + aValues[index];
				}
			}
		}
		
		return m;
	};
	CrocSDK.Sdp.Media.prototype.parseFileAttributes = function () {
		var fileParams = {}, position = 0, selector = {},
			colonIndex, name, value, endIndex;

		if (!this.attributes['file-selector']) {
			return null;
		}

		// Separate the file-selector components
		var fileSelectorString = this.attributes['file-selector'][0];
		while (position < fileSelectorString.length) {
			if (fileSelectorString.charAt(position) === ' ') {
				position++;
				continue;
			}
			
			colonIndex = fileSelectorString.indexOf(':', position);
			if (colonIndex === -1) {
				break;
			}

			name = fileSelectorString.slice(position, colonIndex);
			position = colonIndex + 1;
			
			if (fileSelectorString.charAt(position) === '"') {
				// Grab everything within the quotes (possibly including spaces)
				position++;
				endIndex = fileSelectorString.indexOf('"', position);
				if (endIndex === -1) {
					break;
				}
				value = fileSelectorString.slice(position, endIndex);
				position = endIndex + 1;
			} else if (name === 'type') {
				var quoted = false;
				// Further parsing needed; find the next unquoted space
				endIndex = position;
				while (endIndex < fileSelectorString.length &&
						(quoted || fileSelectorString.charAt(endIndex) !== ' ')) {
					if (fileSelectorString.charAt(endIndex) === '"') {
						quoted = !quoted;
					}
					endIndex++;
				}
				value = fileSelectorString.slice(position, endIndex);
				position = endIndex + 1;
			} else {
				// Grab everything until the next space
				endIndex = fileSelectorString.indexOf(' ', position);
				if (endIndex === -1) {
					endIndex = fileSelectorString.length;
				}
				value = fileSelectorString.slice(position, endIndex);
				position = endIndex + 1;
			}
		
			switch (name) {
			case 'name':
				selector.name = decodeSdpFileName(value);
				break;
			case 'size':
				selector.size = parseInt(value, 10);
				break;
			case 'type':
				selector.type = value;
				break;
			case 'hash':
				if (!selector.hash) {
					selector.hash = {};
				}
				colonIndex = value.indexOf(':');
				selector.hash[value.substring(0, colonIndex)] =
					value.substring(colonIndex + 1);
				break;
			default:
				continue;
			}
		}
		fileParams.selector = selector;
		
		fileParams.id = this.attributes['file-transfer-id'][0];
		fileParams.disposition = this.attributes['file-disposition'][0] || 'render';
		if (this.title) {
			fileParams.description = this.title;
		}
		if (this.attributes['file-icon']) {
			fileParams.icon = this.attributes['file-icon'][0];
		}
		
		return fileParams;
	};
	/**
	 * Check whether the party that created this SDP expects to be sending
	 * media.
	 * @private
	 */
	CrocSDK.Sdp.Media.prototype.isSending = function () {
		if (this.attributes['recvonly'] || this.attributes['inactive']) {
			return false;
		}
		return true;
	};
	/**
	 * Check whether the party that created this SDP expects to be receiving
	 * media.
	 * @private
	 */
	CrocSDK.Sdp.Media.prototype.isReceiving = function () {
		if (this.attributes['sendonly'] || this.attributes['inactive']) {
			return false;
		}
		return true;
	};

}(CrocSDK));


(function (CrocSDK) {

	/**
	 * Psuedo data session used with out-of-dialog SIP MESSAGE requests.
	 * @private
	 * @param {CrocSDK.DataAPI} dataApi
	 * @param {String} address
	 */
	CrocSDK.SipDataSession = function (dataApi, address) {
		var self = this;
		// Internal state
		this.dataApi = dataApi;
		this.state = CrocSDK.C.states.dataSession.ESTABLISHED;
		this.lastActivity = Date.now();
		// Composing state timers
		this.localActiveRefreshIntervalId = null;
		this.localActiveTimeoutId = null;
		this.remoteActiveTimeoutId = null;

		// Frequently-used objects
		this.idleXml = CrocSDK.Util.createIsComposingXml(
				CrocSDK.C.states.rfcComposing.IDLE);
		this.isComposingSendConfig = {contentType: CrocSDK.C.MT.IS_COMPOSING};
		this.localActiveTimeout = function () {
			clearInterval(self.localActiveRefreshIntervalId);
			self.localActiveRefreshIntervalId = null;
			self.localActiveTimeoutId = null;
			self.send(self.idleXml, self.isComposingSendConfig);
		};

		// Public properties
		this.address = address;
		this.capabilities = null; //TODO
		this.customHeaders = null; //TODO
		this.displayName = null; //TODO
	};

	/**
	 * Processes an incoming message for this session.
	 * @private
	 * @param {JSJaCMessage} message
	 */
	CrocSDK.SipDataSession.prototype._receiveMessage = function (address, contentType, body) {
		var prevSdkState = CrocSDK.C.states.sdkComposing.IDLE;

		if (this.remoteActiveTimeoutId) {
			// We were expecting a message - clear the timeout
			clearTimeout(this.remoteActiveTimeoutId);
			this.remoteActiveTimeoutId = null;
			prevSdkState = CrocSDK.C.states.sdkComposing.COMPOSING;
		}

		if (contentType === CrocSDK.C.MT.IS_COMPOSING &&
				this.hasOwnProperty('onComposingStateChange')) {
			// Process "is composing" message - see RFC 3994
			var domParser = new DOMParser();
			var doc = domParser.parseFromString(body, contentType);
			var state = doc.getElementsByTagName("state")[0].firstChild.data;

			var sdkState = CrocSDK.Util.rfc3994StateToSdkState(state);
			if (sdkState === CrocSDK.C.states.sdkComposing.COMPOSING) {
				var refreshTimeout = 120;
				var refreshNode = doc.getElementsByTagName("refresh")[0];
				if (refreshNode) {
					refreshTimeout = parseInt(refreshNode.firstChild.data, 10);
					refreshTimeout = refreshTimeout * 1.1;
				}
				// Start timeout for remote active refresh
				var session = this;
				this.remoteActiveTimeoutId = setTimeout(function() {
					CrocSDK.Util.fireEvent(session, 'onComposingStateChange', {
						state: CrocSDK.C.states.sdkComposing.IDLE
					});
				}, refreshTimeout * 1000);
			}

			if (sdkState !== prevSdkState) {
				CrocSDK.Util.fireEvent(this, 'onComposingStateChange', {
					state: sdkState
				});
			}
		} else if (contentType === CrocSDK.C.MT.XHTML &&
				(this.hasOwnProperty('onXHTMLReceived') ||
						this.dataApi.hasOwnProperty('onXHTMLReceived'))) {
			CrocSDK.Util.fireEvent(this, 'onXHTMLReceived', {
				address: address,
				body: CrocSDK.Util.extractXHTMLBody(body)
			}, true);
		} else {
			CrocSDK.Util.fireEvent(this, 'onData', {
				address : address,
				contentType : contentType,
				data : body
			}, true);
		}

		this.lastActivity = Date.now();
	};

	/**
	 * Checks whether this session should be considered idle, and thus closed
	 * by the periodic cleanup process.
	 * @private
	 * @param {int} idleThreshold - the idle threshold timestamp
	 * @returns {Boolean} 'true' if the session is currently idle
	 */
	CrocSDK.SipDataSession.prototype._isIdle = function (idleThreshold) {
		return this.lastActivity < idleThreshold;
	};

	/*
	 * Public methods
	 */

	CrocSDK.SipDataSession.prototype.accept = function () {
		// Do nothing
	};
	
	CrocSDK.SipDataSession.prototype.send = function (data, config) {
		var dataApi = this.dataApi;
		var options = {
			eventHandlers : {}
		};

		if (config.customHeaders) {
			// Take properties of object and push into options.extraHeaders
			options.extraHeaders = [];
			for (var header in config.customHeaders) {
				if (header.slice(0, 2) !== 'X-') {
					console.warn("Ignoring invalid header: " + header);
				} else {
					options.extraHeaders.push(header + ": " + config.customHeaders[header]);
				}
			}
		}
		if (config.contentType) {
			options.contentType = config.contentType;
		}
		if (config.onSuccess) {
			options.eventHandlers.succeeded = config.onSuccess.bind(dataApi);
		}
		options.eventHandlers.failed = function(event) {
			if (config.onFailure) {
				config.onFailure.call(dataApi);
			}

			// Auth failures should trigger croc object to stop
			if (event.data.cause === JsSIP.C.causes.AUTHENTICATION_ERROR) {
				dataApi.crocObject.stop();
			}
		};

		dataApi.crocObject.sipUA.sendMessage(this.address, data, options);
		this.lastActivity = Date.now();

		// Clear local composing timers/intervals
		if (this.localActiveRefreshIntervalId) {
			clearInterval(this.localActiveRefreshIntervalId);
			this.localActiveRefreshIntervalId = null;
		}
		if (this.localActiveTimeoutId) {
			clearTimeout(this.localActiveTimeoutId);
			this.localActiveTimeoutId = null;
		}
	};
	
	CrocSDK.SipDataSession.prototype.sendXHTML = function (body, config) {
		config = config || {};
		config.contentType = CrocSDK.C.MT.XHTML;

		var xhtml = CrocSDK.Util.createValidXHTMLDoc(body);
		this.send(xhtml, config);
	};
	
	CrocSDK.SipDataSession.prototype.setComposingState = function (state) {
		var session = this;
		state = state || CrocSDK.C.states.sdkComposing.COMPOSING;

		if (this.localActiveTimeoutId) {
			// We're currently in the COMPOSING state
			// Clear the old idle timeout
			clearTimeout(this.localActiveTimeoutId);

			if (state === CrocSDK.C.states.sdkComposing.IDLE) {
				// We're changing state to IDLE - send an update
				this.send(this.idleXml, this.isComposingSendConfig);
			}
		}

		if (state === CrocSDK.C.states.sdkComposing.COMPOSING) {
			if (!this.localActiveRefreshIntervalId) {
				// We're currently in the IDLE state
				// We're changing state to COMPOSING - send an update
				var refreshInterval = this.dataApi.idleTimeout / 2;
				var compXml = CrocSDK.Util.createIsComposingXml(state, refreshInterval);

				this.send(compXml, this.isComposingSendConfig);

				// Set up the active refresh interval
				this.localActiveRefreshIntervalId = setInterval(function () {
					session.send(compXml, session.isComposingSendConfig);
				}, refreshInterval * 1000);
			}

			// Set the active->idle timeout
			this.localActiveTimeoutId = setTimeout(this.localActiveTimeout,
					CrocSDK.C.COMPOSING_TIMEOUT * 1000);
		}
	};

	CrocSDK.SipDataSession.prototype.close = function (status) {
		if (this.state === CrocSDK.C.states.dataSession.CLOSED) {
			return;
		}
		this.state = CrocSDK.C.states.dataSession.CLOSED;

		if (!status) {
			status = 'normal';
		}

		// Clean up any composing state timers/intervals
		if (this.localActiveRefreshIntervalId) {
			clearInterval(this.localActiveRefreshIntervalId);
			this.localActiveRefreshIntervalId = null;
			// Send an IDLE message
			this.send(this.idleXml, this.isComposingSendConfig);
		}
		if (this.localActiveTimeoutId) {
			clearTimeout(this.localActiveTimeoutId);
			this.localActiveTimeoutId = null;
		}
		if (this.remoteActiveTimeoutId) {
			clearTimeout(this.remoteActiveTimeoutId);
			this.remoteActiveTimeoutId = null;
		}

		// Notify application
		CrocSDK.Util.fireEvent(this, 'onClose', {status: status});
	};

	CrocSDK.SipDataSession.prototype.getState = function () {
		return this.state;
	};
	
	/*
	 * Public events
	 */
	CrocSDK.SipDataSession.prototype.onData = function (event) {
		// Default behaviour is to fire the top-level onData event
		this.dataApi.onData(event);
	};
	
	CrocSDK.SipDataSession.prototype.onXHTMLReceived = function (event) {
		// Default behaviour is to fire the top-level onXHTMLReceived event
		this.dataApi.onXHTMLReceived(event);
	};
	
}(CrocSDK));

(function (CrocSDK) {
	var allowedMediaTypes = [ 'audio', 'video' ];

	/**
	 * @typedef CrocSDK.MediaAPI~StreamConfig
	 * @property {CrocSDK.MediaAPI~StreamDirections} audio
	 * The audio stream configuration. Set to <code>null</code> if there is no
	 * audio stream in the session.
	 * @property {CrocSDK.MediaAPI~StreamDirections} video
	 * The video stream configuration. Set to <code>null</code> if there is no
	 * video stream in the session.
	 * @example <caption>Audio-only session</caption>
	 * {
	 *   audio: {send: true, receive: true},
	 *   video: null
	 * }
	 * @example <caption>Audio session with screen sharing (Chrome only)</caption>
	 * {
	 *   audio: {send: true, receive: true},
	 *   video: {
	 *     send: {mandatory: {chromeMediaSource: 'screen'}},
	 *     receive: false
	 *   }
	 * }
	 */

	/**
	 * @typedef CrocSDK.MediaAPI~StreamDirections
	 * @property {Boolean|MediaTrackConstraints} send
	 * Set to <code>true</code> if the stream is outbound-only or
	 * bi-directional.
	 * <p>
	 * When configuring media streams, advanced applications may provide
	 * a {@link http://www.w3.org/TR/mediacapture-streams/#idl-def-MediaStreamConstraints MediaTrackConstraints}
	 * object (as defined by the W3C) to fine-tune the desired properties of the
	 * media track.
	 * @property {Boolean} receive
	 * Set to <code>true</code> if the stream is inbound-only or bi-directional.
	 */

	CrocSDK.StreamConfig = function (config) {
		if (config instanceof CrocSDK.Sdp.Session) {
			this.fromSdp(config);
		} else if (config) {
			var addedStream = false;

			if (typeof config !== 'object') {
				throw new TypeError('Unexpected streamConfig type: ' + typeof config);
			}

			for (var i = 0, len = allowedMediaTypes.length; i < len; i++) {
				var type = allowedMediaTypes[i];
				if (config[type]) {
					this[type] = config[type];
					addedStream = true;
				} else {
					this[type] = null;
				}
			}

			if (!addedStream) {
				throw new CrocSDK.Exceptions.ValueError('No allowed streams found');
			}
		} else {
			// Default to a bi-directional audio session
			this.audio = {send: true, receive: true};
			this.video = null;
		}
	};

	CrocSDK.StreamConfig.prototype.fromSdp = function (sdp) {
		var i, len;
		for (i = 0, len = allowedMediaTypes.length; i < len; i++) {
			var type = allowedMediaTypes[i];
			this[type] = null;
		}

		for (i = 0, len = sdp.media.length; i < len; i++) {
			var mLine = sdp.media[i];
			if (allowedMediaTypes.indexOf(mLine.media) !== -1 &&
					mLine.port !== 0) {
				// Remember that our send/receive settings are the inverse
				// of what we receive in the remote party's SDP.
				this[mLine.media] = {
					send: mLine.isReceiving(),
					receive: mLine.isSending()
				};
			}
		}
	};

	CrocSDK.StreamConfig.prototype.isSending = function () {
		for (var i = 0, len = allowedMediaTypes.length; i < len; i++) {
			var type = allowedMediaTypes[i];
			if (this[type] && this[type].send) {
				return true;
			}
		}
		return false;
	};

	CrocSDK.StreamConfig.prototype.getSendingStreams = function () {
		var streams = [];
		for (var i = 0, len = allowedMediaTypes.length; i < len; i++) {
			var type = allowedMediaTypes[i];
			if (this[type] && this[type].send) {
				streams.push(type);
			}
		}
		return streams;
	};

	/**
	 * Updates the stream config to be on-hold (not receiving any streams) and
	 * returns the streams that were being received.
	 * @returns {Array.<String>} The streams previously being received.
	 */
	CrocSDK.StreamConfig.prototype.hold = function () {
		var streams = [];
		for (var i = 0, len = allowedMediaTypes.length; i < len; i++) {
			var type = allowedMediaTypes[i];
			if (this[type] && this[type].receive) {
				streams.push(type);
				this[type].receive = false;
			}
		}
		return streams;
	};

	/**
	 * Takes the stream config off-hold by resuming the provided streams.
	 * @param {Array.<String>} streams - The streams previously being received.
	 */
	CrocSDK.StreamConfig.prototype.resume = function (streams) {
		for (var i = 0, len = allowedMediaTypes.length; i < len; i++) {
			var type = allowedMediaTypes[i];
			if (this[type] && streams.indexOf(type) !== -1) {
				this[type].receive = true;
			}
		}
	};

	/**
	 * Test for equality between this StreamConfig object and the provided one.
	 * They are considered equal if the same streams are present, and the stream
	 * directions match.
	 * @param {CrocSDK.StreamConfig} streamConfig - The StreamConfig object to
	 * compare with the parent object.
	 * @returns {Boolean} <code>true</code> if the objects are equivalent,
	 * <code>false</code> otherwise.
	 */
	CrocSDK.StreamConfig.prototype.equals = function (streamConfig) {
		for (var i = 0, len = allowedMediaTypes.length; i < len; i++) {
			var type = allowedMediaTypes[i];
			if (typeof this[type] !== typeof streamConfig[type]) {
				return false;
			}
			if (this[type] && streamConfig[type]) {
				if (this[type].send !== streamConfig[type].send) {
					return false;
				}
				if (this[type].receive !== streamConfig[type].receive) {
					return false;
				}
			} else if (this[type]) {
				return false;
			} else if (streamConfig[type]) {
				return false;
			}
		}
		return true;
	};

	/**
	 * Test for equality between the sending streams of this StreamConfig object
	 * and the provided one.
	 * They are considered equal if the same sending streams are present, and the
	 * stream directions match.
	 * @param {CrocSDK.StreamConfig} streamConfig - The StreamConfig object to
	 * compare with the parent object.
	 * @returns {Boolean} <code>true</code> if the sending streams are the same,
	 * <code>false</code> otherwise.
	 */
	CrocSDK.StreamConfig.prototype.sendingStreamsEqual = function (streamConfig) {
		for (var i = 0, len = allowedMediaTypes.length; i < len; i++) {
			var type = allowedMediaTypes[i];
			if (typeof this[type] !== typeof streamConfig[type]) {
				return false;
			}
			if (this[type] && streamConfig[type]) {
				if (this[type].send !== streamConfig[type].send) {
					return false;
				}
			} else if (this[type]) {
				return false;
			} else if (streamConfig[type]) {
				return false;
			}
		}
		return true;
	};

	/**
	 * Test for 'safety' (in terms of privacy) of a stream configuration change.
	 * A change is considered safe if it does not request additional media
	 * streams to be sent by the local party (the remote party may send
	 * additional streams if they wish).
	 * @param {CrocSDK.StreamConfig} newStreamConfig - The StreamConfig object
	 * representing the new configuration.
	 * @returns {Boolean} <code>true</code> if the changes are safe,
	 * <code>false</code> otherwise.
	 */
	CrocSDK.StreamConfig.prototype.isSafeChange = function (newStreamConfig) {
		for (var i = 0, len = allowedMediaTypes.length; i < len; i++) {
			var type = allowedMediaTypes[i];
			if (newStreamConfig[type] && newStreamConfig[type].send) {
				if (!this[type] || !this[type].send) {
					return false;
				}
			}
		}
		return true;
	};

}(CrocSDK));

(function (CrocSDK) {
	/**
	 * @private
	 * @namespace
	 * @alias CrocSDK.Util
	 */
	var Util = {};
	
	/**
	 * Map of basic types to the equivalent wrapper object constructor.
	 * 
	 * @private
	 */
	var objectType = {
			string: String,
			boolean: Boolean,
			number: Number,
			'function': Function
	};
	
	/**
	 * Tests whether the target variable is the expected type, or is an instance
	 * of the equivalent wrapper object.
	 * 
	 * @param target The target variable to test.
	 * @param type Any Javascript type returned by the <code>typeof</code>
	 * operator, optionally appended with <code>[]</code> to indicate an array
	 * of that type.
	 * @returns {boolean}
	 */
	Util.isType = function (target, type) {
		if (type.lastIndexOf('[]') === -1) {
			// Raw type
			if (typeof target === type) {
				return true;
			}
		
			if (typeof target === 'object' &&
					target instanceof objectType[type]) {
				return true;
			}
		} else {
			// Array of type
			if (target instanceof Array) {
				var rawtype = type.slice(0, -2);

				// Check that each index of the array is the appropriate type
				for (var i = 0, len = target.length; i < len; i++) {
					if (!CrocSDK.Util.isType(target[i], rawtype)) {
						return false;
					}
				}
				
				return true;
			}
		}
		
		return false;
	};
	
	var sendConfigTypes = {
			type: 'string',
			customHeaders: 'object',
			contentType: 'string',
			fileTransfer: 'object',
			onSuccess: 'function',
			onFailure: 'function',
			onProgress: 'function'
	};
	
	Util.checkSendConfig = function (config) {
		// Loop through each of the provided config properties
		for (var prop in config) {
			var allowedType = sendConfigTypes[prop];

			// Check it's a defined property
			if (!allowedType) {
				throw new CrocSDK.Exceptions.ValueError(
						"Unexpected config property: " + prop);
			}
			
			// Check the property is one of the accepted types
			var propValue = config[prop];
			if (!CrocSDK.Util.isType(propValue, allowedType)) {
				throw new TypeError(prop + " is not set to a valid type");
			}
		}
	};

	Util.websocketCauseToSdkStatus = function (cause) {
		switch (cause) {
		case 1000:
			return 'normal';
		default:
			return 'error';
		}
	};

	Util.jsSipCauseToSdkStatus = function (cause) {
		switch (cause) {
		case JsSIP.C.causes.BUSY:
			return 'normal';
		case JsSIP.C.causes.CONNECTION_ERROR:
			return 'error';
		case JsSIP.C.causes.REQUEST_TIMEOUT:
			return 'offline';
		case JsSIP.C.causes.REJECTED:
			return 'blocked';
		case JsSIP.C.causes.NOT_FOUND:
			return 'notfound';
		case JsSIP.C.causes.UNAVAILABLE:
			return 'offline';
		default:
			return 'normal';
		}
	};

	var sipStatusToSdkStatus = {
		200: 'normal', // OK
		403: 'blocked', // Forbidden
		404: 'notfound', // Not Found
		408: 'offline', // Request Timeout
		480: 'offline' // Temporarily Unavailable
	};
	
	Util.sipStatusToSdkStatus = function (sipStatus) {
		return sipStatusToSdkStatus[sipStatus];
	};

	var sdkStatusToSipStatus = {
			options: {
				normal: 200,
				blocked: 403,
				notfound: 404,
				offline: 480
			},
			invite: {
				normal: 486,
				blocked: 403,
				notfound: 404,
				offline: 480
			}
	};

	Util.sdkStatusToSipStatus = function (sipMethod, sdkStatus) {
		return sdkStatusToSipStatus[sipMethod][sdkStatus];
	};

	Util.fireEvent = function (parent, event, data, runDefault) {
		if (runDefault || parent.hasOwnProperty(event)) {
			try {
				parent[event](data);
			} catch (e) {
				console.warn(parent.constructor.name + '.' + event +
						' handler threw exception:\n', e.stack);
			}
		}
	};
	
	Util.randomAlphanumericString = function (len) {
		var str = Math.random().toString(36).substr(2);

		while (str.length < len) {
			str += Math.random().toString(36).substr(2);
		}

		return str.substr(0, len);
	};

	var XHTML_HEADER = '<html xmlns="http://www.w3.org/1999/xhtml"><body>';
	var XHTML_FOOTER = '</body></html>';

	/**
	 * Converts an XHTML body fragment into a full, valid XHTML document.
	 * 
	 * @private
	 * @param {DocumentFragment|String} body - The XHTML body fragment.
	 * @returns {String} A valid XHTML document incorporating the provided body.
	 */
	Util.createValidXHTMLDoc = function (body) {
		if (body instanceof window.DocumentFragment) {
			// Use XMLSerializer to convert into a string
			var s = new XMLSerializer();
			body = s.serializeToString(body);
		}

		if (!CrocSDK.Util.isType(body, 'string')) {
			throw new TypeError('Unexpected body:', body);
		}

		return XHTML_HEADER + body + XHTML_FOOTER;
	};

	/**
	 * Extracts the body from an XHTML document.  The body contents are returned
	 * as a DocumentFragment.
	 * 
	 * @private
	 * @param {String} xhtml - The XHTML document.
	 * @returns {DocumentFragment} The extracted contents of the document body.
	 */
	Util.extractXHTMLBody = function (xhtml) {
		var parser = new DOMParser();
		var doc = parser.parseFromString(xhtml, 'application/xhtml+xml');
		var df = doc.createDocumentFragment();
		var bodyChild = doc.getElementsByTagName('body')[0].firstChild;
		while (bodyChild) {
			var nextSibling = bodyChild.nextSibling;
			df.appendChild(bodyChild);
			bodyChild = nextSibling;
		}

		return df;
	};

	var rfc3994StateToSdkState = {
		'active': 'composing',
		'idle': 'idle'
	};
	
	Util.rfc3994StateToSdkState = function (rfc3994State) {
		return rfc3994StateToSdkState[rfc3994State];
	};

	Util.createIsComposingXml = function (sdkState, refresh) {
		var xml = '<isComposing xmlns="urn:ietf:params:xml:ns:im-iscomposing">';
		var state;
		if (sdkState === 'composing') {
			state = 'active';
		} else {
			state = 'idle';
		}
		xml = xml.concat('<state>', state, '</state>');
		if (refresh) {
			xml = xml.concat('<refresh>', refresh, '</refresh>');
		}
		return xml + '</isComposing>';
	};

	/**
	 * Shallow copies all of the properties from the source object into the
	 * target object.  If a matching property is already present in the
	 * target object, it is overwritten.
	 * @param {Object} target
	 * @param {Object} source
	 */
	Util.shallowCopy = function(target, source) {
		for (var prop in source) {
			if (source.hasOwnProperty(prop)) {
				target[prop] = source[prop];
			}
		}
	};

	/**
	 * Normalises the provided address to a JsSIP URI.
	 * @param {String} address
	 * @returns {JsSIP.URI}
	 * @throws {CrocSDK.Exceptions.ValueError}
	 */
	Util.normaliseAddress = function(address) {
		try {
			return JsSIP.Utils.normalizeURI(address, 'crocodilertc.net');
		} catch (e) {
			throw new CrocSDK.Exceptions.ValueError('Invalid address: ' + address);
		}
	};

	Util.isAuthFailure = function(status_code) {
		var codes = JsSIP.C.SIP_ERROR_CAUSES.AUTHENTICATION_ERROR;
		return codes.indexOf(status_code) >= 0;
	};

	CrocSDK.Util = Util;
}(CrocSDK));

(function (CrocSDK) {

	CrocSDK.XmppDataSession = function (dataApi, address, instanceAddress) {
		var self = this;
		// Internal state
		this.dataApi = dataApi;
		this.state = CrocSDK.C.states.dataSession.ESTABLISHED;
		this.lastActivity = Date.now();
		// Remote client features
		this.awaitingFirstChatState = true;
		this.supportsChatState = true;
		this.supportsReceipts = true;
		// Chat state timer
		this.localComposingTimeoutId = null;
		this.localChatState = CrocSDK.C.states.xmppChatState.ACTIVE;
		this.remoteChatState = CrocSDK.C.states.xmppChatState.ACTIVE;
		// Receipt notifications
		this.outstandingMsgMap = {};
		this.outstandingMsgs = [];

		// Frequently-used objects
		this.localComposingTimeout = function () {
			self._sendChatState(CrocSDK.C.states.xmppChatState.ACTIVE);
			self.localComposingTimeoutId = null;
		};

		// Public properties
		this.address = address;
		this.instanceAddress = instanceAddress || null;
		this.displayName = null;
		this.customHeaders = null;
		this.capabilities = null;
		this.type = 'xmpp';
	};

	/*
	 * Internal methods
	 */

	/**
	 * Processes an incoming message for this session.
	 * @private
	 * @param {JSJaCMessage} message
	 */
	CrocSDK.XmppDataSession.prototype._receiveMessage = function (message) {
		var body = message.getBody();
		var xhtmlBodyNode = message.getChild('body', CrocSDK.C.NS.XHTML);
		var chatstate = message.getChild('*', NS_CHAT_STATES);
		var receivedNode = message.getChild('received', CrocSDK.C.NS.XMPP_RECEIPTS);

		this.lastActivity = Date.now();

		if (this.awaitingFirstChatState && (body || chatstate)) {
			if (!chatstate || !this.hasOwnProperty('onComposingStateChange')) {
				// Either local or remote client does not support chat states
				this.supportsChatState = false;
			}
			this.awaitingFirstChatState = false;
		}

		// Determine which application event to fire
		if (xhtmlBodyNode &&
				(this.hasOwnProperty('onXHTMLReceived') ||
						this.dataApi.hasOwnProperty('onXHTMLReceived'))) {
			// Copy the xhtml body into a document fragment
			var df = message.getDoc().createDocumentFragment();
			var bodyChild = xhtmlBodyNode.firstChild;
			while (bodyChild) {
				var nextSibling = bodyChild.nextSibling;
				df.appendChild(bodyChild);
				bodyChild = nextSibling;
			}

			// "Lock in" on full JID (see RFC 6121 section 5.1)
			this.instanceAddress = message.getFrom();

			CrocSDK.Util.fireEvent(this, 'onXHTMLReceived', {
				address: this.address,
				instanceAddress: this.instanceAddress,
				uniqueAddress: this.instanceAddress,	// Deprecated
				body: df
			}, true);
		} else if (body) {
			// "Lock in" on full JID (see RFC 6121 section 5.1)
			this.instanceAddress = message.getFrom();

			// Just use the plain text body
			CrocSDK.Util.fireEvent(this, 'onData', {
				address: this.address,
				instanceAddress: this.instanceAddress,
				uniqueAddress: this.instanceAddress,	// Deprecated
				contentType: 'text/plain',
				data: body
			}, true);
		} else if (this.supportsChatState && chatstate) {
			// Chat state must have changed (XEP-0085 5.2)
			chatstate = chatstate.tagName;
			if (chatstate === CrocSDK.C.states.xmppChatState.GONE) {
				// Treat this as a session close event
				this.state = CrocSDK.C.states.dataSession.CLOSED;
				CrocSDK.Util.fireEvent(this, 'onClose', {status: 'normal'});
			} else if (chatstate === CrocSDK.C.states.xmppChatState.COMPOSING) {
				CrocSDK.Util.fireEvent(this, 'onComposingStateChange', {
					state: CrocSDK.C.states.sdkComposing.COMPOSING
				});
			} else {
				CrocSDK.Util.fireEvent(this, 'onComposingStateChange', {
					state: CrocSDK.C.states.sdkComposing.IDLE
				});
			}
		} else if (receivedNode) {
			// Process delivery receipt ack
			var id = receivedNode.getAttribute('id');
			var config = this.outstandingMsgMap[id];
			if (config) {
				CrocSDK.Util.fireEvent(config, 'onSuccess', {});
				delete this.outstandingMsgMap[id];
			}
		}

		// Check for delivery receipt request
		if (message.getChild('request', CrocSDK.C.NS.XMPP_RECEIPTS)) {
			var receipt = new JSJaCMessage();
			receipt.appendNode(receipt.buildNode('received', {'id': message.getID()},
					null, CrocSDK.C.NS.XMPP_RECEIPTS));
			receipt.setTo(message.getFrom());
			this.dataApi.crocObject.xmppCon.send(receipt);
		}
	};

	/**
	 * Processes an incoming message error for this session.
	 * @private
	 * @param {JSJaCMessage} message
	 */
	CrocSDK.XmppDataSession.prototype._receiveMessageError = function (message) {
		var id = message.getID();
		var config = this.outstandingMsgMap[id];
		if (config) {
			CrocSDK.Util.fireEvent(config, 'onFailure', {});
			delete this.outstandingMsgMap[id];
		}
	};

	/**
	 * Sends a standalone chat state update for this session.
	 * @private
	 * @param {String} xmppChatState
	 */
	CrocSDK.XmppDataSession.prototype._sendChatState = function (xmppChatState) {
		var xmppMsg = new JSJaCMessage();
		xmppMsg.setTo(this.instanceAddress || this.address);
		xmppMsg.appendNode(xmppMsg.buildNode(xmppChatState, null, null, NS_CHAT_STATES));
		this.dataApi.crocObject.xmppCon.send(xmppMsg);
		this.localChatState = xmppChatState;
	};

	CrocSDK.XmppDataSession.prototype._createReceiptId = function (config) {
		var id = CrocSDK.Util.randomAlphanumericString(8);
		this.outstandingMsgMap[id] = config;
		this.outstandingMsgs.push({
			sent: Date.now(),
			id: id
		});

		// Clean up old outstanding messages
		var msg = this.outstandingMsgs[0];
		var expireTimestamp = Date.now() - 10000;
		while (msg && msg.sent < expireTimestamp) {
			this.outstandingMsgs.shift();
			delete this.outstandingMsgMap[msg.id];
			msg = this.outstandingMsgs[0];
		}

		return id;
	};

	/**
	 * Checks whether this session should be considered idle, and thus closed
	 * by the periodic cleanup process.
	 * @private
	 * @param {int} idleThreshold - the idle threshold timestamp
	 * @returns {Boolean} 'true' if the session is currently idle
	 */
	CrocSDK.XmppDataSession.prototype._isIdle = function (idleThreshold) {
		// XMPP does not refresh the 'composing' state, so a prolonged message
		// composition could cause the session to idle-out inappropriately.
		// To prevent this, check the local and remote composing state as well.
		return this.localChatState !== CrocSDK.C.states.xmppChatState.COMPOSING &&
			this.remoteChatState !== CrocSDK.C.states.xmppChatState.COMPOSING &&
			this.lastActivity < idleThreshold;
	};

	/*
	 * Public methods
	 */

	CrocSDK.XmppDataSession.prototype.send = function (data, config) {
		if (config && (config.customHeaders || config.contentType ||
				config.fileTransfer)) {
			throw new CrocSDK.Exceptions.ValueError(
					'customHeaders/contentType/fileTransfer not supported for' +
					'XMPP data sessions');
		}

		if (!CrocSDK.Util.isType(data, 'string')) {
			throw new TypeError('XMPP data sessions only support string data');
		}

		if (this.state !== CrocSDK.C.states.dataSession.ESTABLISHED) {
			throw new CrocSDK.Exceptions.StateError(
					'Cannot call send() in current state: ' + this.state);
		}

		var xmppMsg = new JSJaCMessage();
		xmppMsg.setTo(this.instanceAddress || this.address);
		xmppMsg.setBody(data);

		if (this.supportsChatState) {
			xmppMsg.appendNode(xmppMsg.buildNode("active", null, null, NS_CHAT_STATES));
		}

		if (config.onSuccess || config.onFailure) {
			// Add an ID so errors/receipts can be associated with this message
			xmppMsg.setID(this._createReceiptId(config));
			if (this.supportsReceipts) {
				xmppMsg.appendNode(xmppMsg.buildNode("request", null, null,
						CrocSDK.C.NS.XMPP_RECEIPTS));
			}
		}

		if (!this.dataApi.crocObject.xmppCon.send(xmppMsg)) {
			CrocSDK.Util.fireEvent(config, 'onFailure', {});	
			delete this.outstandingMsgMap[xmppMsg.getID()];
		}
		this.lastActivity = Date.now();
		if (this.localComposingTimeoutId) {
			clearTimeout(this.localComposingTimeoutId);
			this.localComposingTimeoutId = null;
		}
	};

	CrocSDK.XmppDataSession.prototype.sendXHTML = function (body, config) {
		if (config && (config.customHeaders ||
				(config.contentType && config.contentType !== 'application/xhtml+xml') ||
				config.fileTransfer)) {
			throw new CrocSDK.Exceptions.ValueError(
					'customHeaders/contentType/fileTransfer not supported for' +
					'XMPP data sessions');
		}

		if (this.state !== CrocSDK.C.states.dataSession.ESTABLISHED) {
			throw new CrocSDK.Exceptions.StateError(
					'Cannot call send() in current state: ' + this.state);
		}

		var xmppMsg = new JSJaCMessage();
		xmppMsg.setTo(this.instanceAddress || this.address);

		var bodyNode;
		if (CrocSDK.Util.isType(body, 'string')) {
			var parser = new DOMParser();
			var doc = parser.parseFromString('<body xmlns=\'' +
					CrocSDK.C.NS.XHTML + '\'>' + body + '</body>', 'text/xml');
			bodyNode = doc.documentElement;
		} else {
			bodyNode = xmppMsg.buildNode('body', null, [body], CrocSDK.C.NS.XHTML);
		}

		// TODO: Attempt to format plain text better - the following just strips
		// out all of the XML tags, which works but isn't ideal.
		xmppMsg.setBody(this.dataApi.crocObject.jQuery(bodyNode).text());
		var htmlNode = xmppMsg.buildNode('html', null, [bodyNode],
				CrocSDK.C.NS.XMPP_XHTML_IM);
		xmppMsg.appendNode(htmlNode);

		if (this.supportsChatState) {
			xmppMsg.appendNode(xmppMsg.buildNode("active", null, null, NS_CHAT_STATES));
		}

		if (config.onSuccess || config.onFailure) {
			// Add an ID so errors/receipts can be associated with this message
			xmppMsg.setID(this._createReceiptId(config));
			if (this.supportsReceipts) {
				xmppMsg.appendNode(xmppMsg.buildNode("request", null, null,
						CrocSDK.C.NS.XMPP_RECEIPTS));
			}
		}

		if (!this.dataApi.crocObject.xmppCon.send(xmppMsg)){
			CrocSDK.Util.fireEvent(config, 'onFailure', {});
			delete this.outstandingMsgMap[xmppMsg.getID()];
		}
		this.lastActivity = Date.now();
		if (this.localComposingTimeoutId) {
			clearTimeout(this.localComposingTimeoutId);
			this.localComposingTimeoutId = null;
		}
	};

	CrocSDK.XmppDataSession.prototype.accept = function () {
		// Do nothing
	};

	CrocSDK.XmppDataSession.prototype.close = function (status) {
		if (this.state === CrocSDK.C.states.dataSession.CLOSED) {
			return;
		}

		if (this.supportsChatState) {
			// Send a 'gone' notification
			this._sendChatState(CrocSDK.C.states.xmppChatState.GONE);
		}

		this.state = CrocSDK.C.states.dataSession.CLOSED;

		if (this.localComposingTimeoutId) {
			clearTimeout(this.localComposingTimeoutId);
			this.localComposingTimeoutId = null;
		}

		if (!status) {
			status = 'normal';
		}

		// Notify application
		CrocSDK.Util.fireEvent(this, 'onClose', {status: status});
	};

	CrocSDK.XmppDataSession.prototype.getState = function () {
		return this.state;
	};

	CrocSDK.XmppDataSession.prototype.setComposingState = function (state) {
		if (!this.supportsChatState) {
			return;
		}

		var prevState = CrocSDK.C.states.sdkComposing.IDLE;
		state = state || CrocSDK.C.states.sdkComposing.COMPOSING;

		if (this.localComposingTimeoutId) {
			// We're currently in the COMPOSING state
			prevState = CrocSDK.C.states.sdkComposing.COMPOSING;
			// Clear the old idle timeout
			clearTimeout(this.localComposingTimeoutId);
			this.localComposingTimeoutId = null;

			if (state === CrocSDK.C.states.sdkComposing.IDLE) {
				// We're changing state to IDLE - send an update
				this._sendChatState(CrocSDK.C.states.xmppChatState.ACTIVE);
			}
		}

		if (state === CrocSDK.C.states.sdkComposing.COMPOSING) {
			if (prevState !== CrocSDK.C.states.sdkComposing.COMPOSING) {
				// We're currently in the IDLE state
				// We're changing state to COMPOSING - send an update
				this._sendChatState(CrocSDK.C.states.xmppChatState.COMPOSING);
			}

			// Set the active->idle timeout
			this.localComposingTimeoutId = setTimeout(this.localComposingTimeout,
					CrocSDK.C.COMPOSING_TIMEOUT * 1000);
		}
	};

	/*
	 * Public events
	 */
	CrocSDK.XmppDataSession.prototype.onData = function (event) {
		// Default behaviour is to fire the top-level onData event
		this.dataApi.onData(event);
	};

	CrocSDK.XmppDataSession.prototype.onXHTMLReceived = function (event) {
		// Default behaviour is to fire the top-level onXHTMLReceived event
		this.dataApi.onXHTMLReceived(event);
	};

}(CrocSDK));

(function(CrocSDK) {

	var allowedAvailability = ['away', 'dnd'];

	/**
	 * The user or contact's current availability.  Can take one of the
	 * following string values:
	 * <ul>
	 * <li><code>available</code></li>
	 * <li><code>away</code></li>
	 * <li><code>dnd</code> (do not disturb)</li>
	 * <li><code>unavailable</code> (offline)</li>
	 * </ul>
	 * @typedef {string} CrocSDK.XmppPresenceAPI~availability
	 */

	/**
	 * Callback used when the requested operation is successful.
	 * @private
	 * @callback CrocSDK.XmppPresenceAPI~onSuccess
	 */

	/**
	 * Opens the WebSocket connection.
	 *
	 * @private
	 * @param {CrocSDK.Croc} croc The parent Croc object.
	 */
	function connect(croc) {
		var addrSplit = croc.address.split('@');

		croc.xmppCon.connect({
			username: croc.authorizationUser || addrSplit[0],
			domain: addrSplit[1],
			password: croc.password,
			resource: croc.xmppResource,
			allow_plain: true
		});
	}
	
	/**
	 * Process the get roster result.
	 *
	 * @private
	 * @param {JSJaCIQ} reply
	 * @param {CrocSDK.XmppPresenceAPI} presenceApi
	 */
	function processRosterGetResult(reply, presenceApi) {
		var contacts = [];
		var contactMap = {};

		if (reply.isError()) {
			if (reply.getChild('item-not-found', NS_STANZAS) !== null) {
				console.log('Roster does not exist yet');

				presenceApi.contactList = [];
				presenceApi.contactMap = contactMap;

				// Fire event with an empty contact list
				CrocSDK.Util.fireEvent(presenceApi, 'onContactsReceived', {
					contacts: contacts
				});
			} else {
				console.warn('Unexpected roster result:', reply.xml());
			}
			return;
		}
		
		var queryChildren = reply.getQuery().childNodes;

		for (var i = 0, len = queryChildren.length; i < len; i++) {
			var contact = parseRosterItem(presenceApi, queryChildren.item(i));

			if (!contact) {
				console.error('Error parsing contact roster item', queryChildren.item(i));
				return;
			}

			contacts.push(contact);
			contactMap[contact.address] = contact;
		}

		// If we have an existing contact list, transfer any presence info
		var oldContactList = presenceApi.contactList;
		for (i = 0, len = oldContactList.length; i < len; i++) {
			var oldContact = oldContactList[i];
			var newContact = contactMap[oldContact.address];
			if (newContact) {
				newContact.availability = oldContact.availability;
				newContact.status = oldContact.status;
				newContact.extraNodes = oldContact.extraNodes;
			}
		}

		presenceApi.contactList = contacts;
		presenceApi.contactMap = contactMap;

		// Copy the array, so any application modifications do not affect our copy
		CrocSDK.Util.fireEvent(presenceApi, 'onContactsReceived', {
			contacts: [].concat(contacts)
		});
	}

	/**
	 * Parses an 'item' node, returning it as a Contact object instance.
	 *
	 * @private
	 * @param {CrocSDK.XmppPresenceAPI} presenceApi
	 * @param {Node} itemNode The 'item' node to parse.
	 * @returns {CrocSDK.XmppPresenceAPI~Contact} The resulting Contact
	 * instance, or <code>null</code> if there was a parsing error.
	 */
	function parseRosterItem(presenceApi, itemNode) {
		var contact = new Contact(presenceApi, itemNode.getAttribute('jid'));

		if (!contact.address) {
			return null;
		}
		if (itemNode.getAttribute('approved') === 'true') {
			contact.watchingApproved = true;
		}
		if (itemNode.getAttribute('ask') === 'subscribe') {
			contact.watchPending = true;
		}

		var name = itemNode.getAttribute('name');
		if (name) {
			contact.name = name;
		}
		
		switch (itemNode.getAttribute('subscription')) {
		case '':
		case 'none':
			break;
		case 'both':
			contact.watching = true;
			contact.watchingMe = true;
			break;
		case 'from':
			contact.watchingMe = true;
			break;
		case 'to':
			contact.watching = true;
			break;
		case 'remove':
			contact.removed = true;
			break;
		default:
			return null;
		}

		var itemChild = itemNode.firstChild;
		while (itemChild) {
			if (itemChild.nodeName === 'group') {
				// concatenate all values from childNodes
				var childNodes = itemChild.childNodes;
				var groupName = '';
				for (var i = 0, len = childNodes.length; i < len; i++) {
					if (childNodes.item(i).nodeValue) {
						groupName += childNodes.item(i).nodeValue;
					}
				}
				contact.groups.push(groupName);
			}
			itemChild = itemChild.nextSibling;
		}

		return contact;
	}

	/**
	 * Sends a roster set IQ.
	 *
	 * @private
	 * @param {CrocSDK.XmppPresenceAPI~Contact} contact
	 * @param {CrocSDK.XmppPresenceAPI~onSuccess} onSuccess
	 * @returns {boolean} <code>true</code> if the request was sent
	 * successfully, <code>false</code> otherwise.
	 */
	function sendRosterSet(contact, onSuccess) {
		var presenceApi = contact.presenceApi;
		var con = presenceApi.crocObject.xmppCon;

		var itemAttribs = {jid: contact.address};
		if (contact.name) {
			itemAttribs.name = contact.name;
		}

		var iq = new JSJaCIQ();
		var itemNode = iq.buildNode('item', itemAttribs);

		for (var i = 0, len = contact.groups.length; i < len; i++) {
			itemNode.appendChild(iq.buildNode('group', contact.groups[i]));
		}

		iq.setType('set');
		iq.setQuery(NS_ROSTER).appendChild(itemNode);

		return con.send(iq, processRosterSetResult, onSuccess);
	}

	/**
	 * Process the set roster result.
	 *
	 * @private
	 * @param {JSJaCIQ} reply
	 * @param {CrocSDK.XmppPresenceAPI~onSuccess} onSuccess
	 */
	function processRosterSetResult(reply, onSuccess) {
		if (reply.isError()) {
			console.warn('Roster set failed', reply.xml());
		} else {
			// We will receive roster push messages with the new contact
			// info separately.
			if (onSuccess) {
				onSuccess();
			}
		}
	}

	/**
	 * Creates a presence message based on the provided parameters.
	 * 
	 * @private
	 * @param {CrocSDK.Croc} croc - The parent Croc object.
	 * @param {CrocSDK.XmppPresenceAPI~PresenceInfo} [info]
	 * The presence information to set.  If this is omitted, the user's
	 * availability will be reset to 'available', and the user's current status
	 * (if any) will be cleared.
	 * @return {JSJaCPresence}
	 */
	function createPresence(croc, info) {
		var presence = new JSJaCPresence();

		if (info) {
			if (info.availability &&
					allowedAvailability.indexOf(info.availability) !== -1) {
				presence.setShow(info.availability);
			}
	
			if (info.status) {
				presence.setStatus(info.status);
			}
	
			var extraNodes = info.extraNodes;
			if (extraNodes) {
				if (!extraNodes instanceof Node) {
					throw new TypeError('Unexpected type for extraNodes');
				}
				presence.appendNode(extraNodes);
			}
		}

		// Add 'reachability' address as per draft-ivov-xmpp-cusax-05/XEP-0152
		if (!presence.getChild('reach', CrocSDK.C.NS.XMPP_REACH)) {
			var addr = presence.buildNode('addr', {
				'uri': 'sip:' + croc.address
			});
			presence.appendNode('reach', {}, [addr], CrocSDK.C.NS.XMPP_REACH);
		}

		return presence;
	}

	/**
	 * @constructor
	 * @classdesc Represents a contact on the presence roster.
	 * @memberof CrocSDK.XmppPresenceAPI
	 * @inner
	 * 
	 * @param {CrocSDK.XmppPresenceAPI} presenceApi Reference to the parent
	 * presence API instance.
	 * @param {string} address The address of the contact.
	 */
	function Contact(presenceApi, address) {
		/**
		 * Reference to the parent presence API instance.
		 * @type {CrocSDK.XmppPresenceAPI}
		 * @private
		 */
		this.presenceApi = presenceApi;
		/**
		 * Flag indicating whether the contact has been removed.
		 * @type {boolean}
		 * @private
		 */
		this.removed = false;
		/**
		 * The contact's address.
		 * @type {string}
		 */
		this.address = address;
		/**
		 * Whether the user is watching the contact.  We will receive
		 * notification of changes to the presence information of contacts the
		 * user is watching.
		 * @type {boolean}
		 */
		this.watching = false;
		/**
		 * Whether a watch request has been sent to this contact (and not yet
		 * approved/accepted).
		 * @type {boolean}
		 */
		this.watchPending = false;
		/**
		 * Whether the contact is watching the user.  Contacts that are watching
		 * the user will receive notification of changes to the user's presence
		 * information.
		 * @type {boolean}
		 */
		this.watchingMe = false;
		/**
		 * Whether the contact is pre-approved to watch to the user (but not yet
		 * watching).
		 * <p>
		 * Note that support for pre-approval is optional for XMPP servers. If
		 * it is not supported, the pre-approval will be ignored, and the
		 * {@link CrocSDK.XmppPresenceAPI#event:onWatchRequest} event will
		 * be fired as usual if the contact sends a watch request.
		 * @type {boolean}
		 */
		this.watchingApproved = false;
		/**
		 * The contact name/handle.  This will be <code>null</code> if the name
		 * has not been set.
		 * @type {string}
		 */
		this.name = null;
		/**
		 * The group names associated with this contact, represented as an array
		 * of strings.
		 * @type {Array<string>}
		 */
		this.groups = [];
		/**
		 * The current availability of the contact.
		 * <p>
		 * This is part of the presence information, and thus will be
		 * <code>null</code> if the contact's presence has not yet been received
		 * (i.e. if the onNotify event has not yet fired for this contact).
		 * @type {CrocSDK.XmppPresenceAPI~availability}
		 */
		this.availability = null;
		/**
		 * The current status set by the contact.  The status is optional; this
		 * property will be <code>null</code> if the status is not included in
		 * the presence information.
		 * <p>
		 * This is part of the presence information, and thus will be
		 * <code>null</code> if the contact's presence has not yet been received
		 * (i.e. if the onNotify event has not yet fired for this contact).
		 * @type {string}
		 */
		this.status = null;
		/**
		 * Any extra, unparsed XML data included in the presence update.  This
		 * property will be <code>null</code> if there was no extra data in the
		 * presence information.
		 * <p>
		 * This is part of the presence information, and thus will be
		 * <code>null</code> if the contact's presence has not yet been received
		 * (i.e. if the onNotify event has not yet fired for this contact).
		 * @type {Node}
		 * @private
		 */
		this.extraNodes = null;
	}

	/**
	 * Send a watch request to this contact.  If approved, the user will
	 * receive a notification when the contact changes their presence
	 * information.
	 * 
	 * @method CrocSDK.XmppPresenceAPI~Contact#watch
	 * @returns {boolean} <code>true</code> if the request was sent
	 * successfully, <code>false</code> otherwise.
	 */
	Contact.prototype.watch = function () {
		var presence = new JSJaCPresence();
		presence.setTo(this.address);
		presence.setType('subscribe');
		return this.presenceApi.crocObject.xmppCon.send(presence);
	};

	/**
	 * Send an unwatch request to this contact, stopping future presence
	 * updates.
	 * @method CrocSDK.XmppPresenceAPI~Contact#unwatch
	 * @returns {boolean} <code>true</code> if the request was sent
	 * successfully, <code>false</code> otherwise.
	 */
	Contact.prototype.unwatch = function () {
		var presence = new JSJaCPresence();
		presence.setTo(this.address);
		presence.setType('unsubscribe');
		return this.presenceApi.crocObject.xmppCon.send(presence);
	};

	/**
	 * Gives permission (or pre-approval) for the contact to watch the user
	 * (i.e. receive notification of changes to the user's presence
	 * information).
	 * <p>
	 * Note that support for pre-approval is optional for XMPP servers. If
	 * it is not supported, the pre-approval will be ignored, and the
	 * {@link CrocSDK.XmppPresenceAPI#event:onWatchRequest} event will
	 * be fired as usual if the contact sends a watch request.
	 * @method CrocSDK.XmppPresenceAPI~Contact#allowWatch
	 * @returns {boolean} <code>true</code> if the request was sent
	 * successfully, <code>false</code> otherwise.
	 */
	Contact.prototype.allowWatch = function () {
		var presence = new JSJaCPresence();
		presence.setTo(this.address);
		presence.setType('subscribed');
		return this.presenceApi.crocObject.xmppCon.send(presence);
	};

	/**
	 * Revokes permission (or pre-approval) for the contact to watch the user
	 * (i.e. receive notification of changes to the user's presence
	 * information).
	 * @method CrocSDK.XmppPresenceAPI~Contact#denyWatch
	 * @returns {boolean} <code>true</code> if the request was sent
	 * successfully, <code>false</code> otherwise.
	 */
	Contact.prototype.denyWatch = function () {
		var presence = new JSJaCPresence();
		presence.setTo(this.address);
		presence.setType('unsubscribed');
		return this.presenceApi.crocObject.xmppCon.send(presence);
	};

	/**
	 * Update the contact roster with the provided information.
	 * <p>
	 * Any UI updates showing the changes should be made when the onUpdate
	 * event fires, not when this method is called. This ensures that changes
	 * are only made once the server saves them, and that changes from other
	 * client instances are reflected in this instance.
	 * 
	 * @method CrocSDK.XmppPresenceAPI~Contact#update
	 * @param {object} params - The contact details to update.
	 * @param {string} [params.name] - The contact name/handle to use.  If this
	 * is omitted the existing name (if any) will be left unmodified.
	 * @param {Array<string>} [params.groups] - An array of group names to associate
	 * with this contact.  If this is omitted the existing groups (if any) will
	 * be left unmodified.
	 * @returns {boolean} <code>true</code> if the request was sent
	 * successfully, <code>false</code> otherwise.
	 * @fires CrocSDK.XmppPresenceAPI~Contact#event:onUpdate
	 */
	Contact.prototype.update = function (params) {
		var updatedContact = new Contact(this.presenceApi, this.address);
		var properties = ['name', 'groups'];
		var property;
		
		for (var i = 0, len = properties.length; i < len; i++) {
			property = properties[i];
			if (params.hasOwnProperty(property)) {
				updatedContact[property] = params[property];
			} else {
				updatedContact[property] = this[property];
			}
		}

		sendRosterSet(updatedContact);
	};

	/**
	 * Request that the contact be removed from the roster.  This implicitly
	 * removes any watches between the user and the contact as well.
	 * @method CrocSDK.XmppPresenceAPI~Contact#remove
	 * @returns {boolean} <code>true</code> if the request was sent
	 * successfully, <code>false</code> otherwise.
	 */
	Contact.prototype.remove = function () {
		var con = this.presenceApi.crocObject.xmppCon;
		var iq = new JSJaCIQ();
		var itemNode = iq.buildNode('item', {
			jid: this.address,
			subscription: 'remove'
		});

		iq.setType('set');
		iq.setQuery(NS_ROSTER).appendChild(itemNode);

		return con.send(iq, processRosterSetResult);
	};

	/**
	 * Updates the current contact information based on the provided contact.
	 * @private
	 * @method CrocSDK.XmppPresenceAPI~Contact#_update
	 * @param {} newContact - The new contact information.
	 */
	Contact.prototype._update = function (newContact) {
		var properties = [
			'watching',
			'watchPending',
			'watchingMe',
			'watchingApproved',
			'name',
			'groups'
		];
		var property;

		for (var i = 0, len = properties.length; i < len; i++) {
			property = properties[i];
			this[property] = newContact[property];
		}

		CrocSDK.Util.fireEvent(this, 'onUpdate');
	};

	/**
	 * Event fired when an update is received for this contact.
	 * 
	 * @event CrocSDK.XmppPresenceAPI~Contact#onUpdate
	 */

	/**
	 * Event fired when a notification of new presence information is received
	 * for this contact.
	 * 
	 * @event CrocSDK.XmppPresenceAPI~Contact#onNotify
	 */

	/**
	 * Event fired when this contact is removed from the roster (possibly by
	 * another client instance).
	 * 
	 * @event CrocSDK.XmppPresenceAPI~Contact#onRemove
	 */

	/**
	 * @constructor
	 * @classdesc Represents the data from an incoming watch request.
	 * @memberof CrocSDK.XmppPresenceAPI
	 * @inner
	 * @param {CrocSDK.XmppPresenceAPI} presenceApi
	 * @param {JSJaCPresence} request
	 * @param {string} address
	 * @param {string} status
	 */
	function WatchRequestEvent(presenceApi, address, status) {
		/**
		 * Reference to the parent presence API instance.
		 * @type {CrocSDK.XmppPresenceAPI}
		 * @private
		 */
		this.presenceApi = presenceApi;
		/**
		 * The address of the user who sent the watch request.
		 * @type {string}
		 */
		this.address = address;
		/**
		 * The status included in the watch request, or null if one was not
		 * included.
		 * @type {string}
		 */
		this.status = status || null;
	}
	/**
	 * Accept the watch request.  The requester will be added to the contact
	 * roster if they were not already there, and will receive the user's
	 * current and future presence information.
	 * @method CrocSDK.XmppPresenceAPI~WatchRequestEvent#accept
	 */
	WatchRequestEvent.prototype.accept = function () {
		var approval = new JSJaCPresence();
		approval.setTo(this.address);
		approval.setType('subscribed');
		this.presenceApi.crocObject.xmppCon.send(approval);
	};
	/**
	 * Reject the watch request.  The requester will not receive the user's
	 * current or future presence information.
	 * @method CrocSDK.XmppPresenceAPI~WatchRequestEvent#reject
	 */
	WatchRequestEvent.prototype.reject = function () {
		var denial = new JSJaCPresence();
		denial.setTo(this.address);
		denial.setType('unsubscribed');
		this.presenceApi.crocObject.xmppCon.send(denial);
	};

	/**
	 * Xmpp Presence/Roster API.
	 * <p>
	 * This should not be instantiated directly - each Croc 
	 * object already has an instance of this API accessible via the 
	 * <code>presence</code> property.
	 * </p>
	 * 
	 * @constructor
	 * @memberof CrocSDK
	 * @param {CrocSDK.Croc} crocObject - The parent Croc object.
	 * @param {CrocSDK~Config} config - The Croc object configuration.
	 */
	CrocSDK.XmppPresenceAPI = function (crocObject, config) {
		this.crocObject = crocObject;
		config.jQuery.extend(this, config.presence);
		
		this.running = false;
		this.reconnectTimerId = null;
		this.contactList = [];
		this.contactMap = {};
		this.currentPresence = new JSJaCPresence();
	};
	
	/**
	 * @private
	 */
	CrocSDK.XmppPresenceAPI.prototype.init = function() {
		var presenceApi = this;
		var croc = this.crocObject;
		var con = croc.xmppCon;

		if (!con) {
			return;
		}

		this.currentPresence = createPresence(croc);

		// Set up JSJaC event handlers
		con.registerHandler('onconnect', function () {
			// Retrieve the roster to flag us as an interested party (receive
			// presence updates for roster contacts).
			presenceApi.getContacts();
			// Send initial presence message to flag us as available
			// (receive messages, subscription requests).
			con.send(presenceApi.currentPresence.clone());
			CrocSDK.Util.fireEvent(presenceApi, 'onConnected', {});
		});

		con.registerHandler('ondisconnect', function () {
			if (presenceApi.running) {
				// Check if we've already started the reconnect timer
				if (!presenceApi.reconnectTimerId) {
					// Attempt to reconnect after a delay 
					presenceApi.reconnectTimerId = setTimeout(function () {
						if (presenceApi.running) {
							connect(croc);
						}
						presenceApi.reconnectTimerId = null;
					}, 10000);
					
					CrocSDK.Util.fireEvent(presenceApi, 'onDisconnected', {});
				}
			} else {
				// Graceful disconnect; notify the app
				CrocSDK.Util.fireEvent(presenceApi, 'onDisconnected', {});
			}
		});

		con.registerHandler('onerror', function (error) {
			console.warn('XMPP error:', error);

			if (con.connected()) {
				con.disconnect();
			}

			// Check if we've already started the reconnect timer
			if (presenceApi.running && !presenceApi.reconnectTimerId) {
				// Attempt to reconnect after a delay 
				presenceApi.reconnectTimerId = setTimeout(function () {
					if (presenceApi.running) {
						connect(croc);
					}
					presenceApi.reconnectTimerId = null;
				}, 10000);
				
				CrocSDK.Util.fireEvent(presenceApi, 'onDisconnected', {});
			}
		});
		
		// Register handlers for supported IQ requests
		con.registerIQGet('query', NS_DISCO_INFO, this._processServiceDiscovery.bind(this));
		con.registerIQSet('query', NS_ROSTER, this._processRosterPush.bind(this));

		// Register catch-all handler for unsupported IQ requests
		con.registerHandler('iq', function (iq) {
			console.log('Received unhandled IQ:', iq.xml());
			con.send(iq.errorReply(ERR_FEATURE_NOT_IMPLEMENTED));
		});

		// Process subscription requests
		con.registerHandler('presence', '*', '*', 'subscribe', this._processSubscribe.bind(this));

		// Ignore notifications of subscription changes; we'll get a roster
		// update separately
		var returnTrue = function () {return true;};
		con.registerHandler('presence', '*', '*', 'unsubscribe', returnTrue);
		con.registerHandler('presence', '*', '*', 'subscribed', returnTrue);
		con.registerHandler('presence', '*', '*', 'unsubscribed', returnTrue);

		// Process presence updates
		con.registerHandler('presence', this._processPresence.bind(this));
	};

	/**
	 * Processes incoming XMPP service discovery requests.
	 * 
	 * @private
	 * @memberof CrocSDK.XmppPresenceAPI
	 * @param {JSJaCIQ} request
	 * @returns <code>true</code> to prevent the event bubbling
	 */
	CrocSDK.XmppPresenceAPI.prototype._processServiceDiscovery = function (request) {
		var con = this.crocObject.xmppCon;
		var response = new JSJaCIQ();
		response.setIQ(request.getFrom(), 'result', request.getID());
		
		var featureNodeReceipts = response.buildNode('feature',
				{'var': CrocSDK.C.NS.XMPP_RECEIPTS});
		var featureNodeChat = response.buildNode('feature',
				{'var': NS_CHAT_STATES});
		var featureNodeXHTML = response.buildNode('feature',
				{'var': CrocSDK.C.NS.XMPP_XHTML_IM});
		
		var queryNode = response.buildNode('query', {xmlns: NS_DISCO_INFO},
				[featureNodeReceipts, featureNodeChat, featureNodeXHTML]);
		response.appendNode(queryNode);
		
		con.send(response);
		return true;
	};

	/**
	 * Processes a roster push message as per section 2.1.6. of RFC 6121.
	 * 
	 * @private
	 * @memberof CrocSDK.XmppPresenceAPI
	 * @param {JSJaCIQ} request
	 * @returns <code>true</code> to prevent the event bubbling
	 */
	CrocSDK.XmppPresenceAPI.prototype._processRosterPush = function (request) {
		var queryChildren = request.getQuery().childNodes;
		var con = this.crocObject.xmppCon;

		// Rule 1
		if (queryChildren.length !== 1) {
			console.warn('Received invalid roster push (rule 1):', request.xml());
			con.send(request.errorReply(ERR_BAD_REQUEST));
			return true;
		}

		// Rule 2
		if (request.getFrom() && request.getFrom() !== this.crocObject.address) {
			console.warn('Received invalid roster push (rule 2):', request.xml());
			con.send(request.errorReply(ERR_BAD_REQUEST));
			return true;
		}

		// Now we can process the push
		var contact = parseRosterItem(this, queryChildren.item(0));
		if (!contact) {
			console.error('Error parsing contact roster item',
					queryChildren.item(0));
			con.send(request.errorReply(ERR_BAD_REQUEST));
			return true;
		}

		// Check whether this is an update or a new contact
		var oldContact = this.contactMap[contact.address];
		if (oldContact) {
			if (contact.removed) {
				console.log('Removing contact', contact.address);
				this.contactList.splice(this.contactList.indexOf(oldContact), 1);
				delete this.contactMap[contact.address];
				CrocSDK.Util.fireEvent(oldContact, 'onRemove', {});
			} else {
				console.log('Updating contact', contact.address);
				oldContact._update(contact);
			}
		} else if (!contact.removed) {
			console.log('Adding contact', contact.address);
			this.contactList.push(contact);
			this.contactMap[contact.address] = contact;
			CrocSDK.Util.fireEvent(this, 'onNewContact', {
				contact: contact
			});
		} else {
			console.log('Received roster removal push for unknown contact!');
		}

		// Send success response
		var reply = new JSJaCIQ();
		reply.setIQ(request.getFrom(), 'result', request.getID());
		con.send(reply);
		return true;
	};

	/**
	 * Processes an inbound subscribe (watch) request.
	 * 
	 * @private
	 * @memberof CrocSDK.XmppPresenceAPI
	 * @param {JSJaCPresence} request
	 * @returns <code>true</code> to prevent the event bubbling
	 */
	CrocSDK.XmppPresenceAPI.prototype._processSubscribe = function (request) {
		// This MAY contain a 'status' child, as described at the end of section
		// 4.7.2.2. of RFC 6121.
		var status = request.getChildVal('status');
		var watchRequest = new WatchRequestEvent(this, request.getFrom(), status);
		CrocSDK.Util.fireEvent(this, 'onWatchRequest', watchRequest);

		return true;
	};

	/**
	 * Processes an inbound presence update.
	 * 
	 * @private
	 * @memberof CrocSDK.XmppPresenceAPI
	 * @param {JSJaCPresence} request
	 * @returns <code>true</code> to prevent the event bubbling
	 */
	CrocSDK.XmppPresenceAPI.prototype._processPresence = function (request) {
		var from = request.getFromJID();
		var bareFrom = from.getBareJID();
		var status = request.getChildVal('status') || null;
		var availability = 'available';
		var extraNodes = null;

		// Decode the parts of the message that we understand
		var type = request.getType();
		if (!type) {
			// No type = available by default
			var show = request.getChildVal('show');
			// We don't want 'xa' or 'chat' which are fairly XMPP-specific;
			// map these to 'away' and 'available' respectively.
			switch (show) {
			case 'away':
			case 'dnd':
				availability = show;
				break;
			case 'xa':
				availability = 'away';
				break;
			}
		} else if (type === 'unavailable') {
			availability = 'unavailable';

			// Close any data sessions for this address (effectively also
			// "unlocks" the session, see RFC 6121 section 5.1)
			var dataSession = this.crocObject.data.xmppDataSessions[bareFrom];
			if (dataSession && dataSession.instanceAddress === request.getFrom()) {
				dataSession.close();
			}
		} else {
			console.warn('Unexpected presence message', request.xml());
			return true;
		}

		// Copy any extra XML nodes into a separate document fragment
		var presChild = request.getNode().firstChild;
		while (presChild) {
			switch (presChild.nodeName) {
			case 'show':
			case 'status':
				// Skip these - we decoded them already
				break;
			default:
				// Found something we haven't decoded
				if (!extraNodes) {
					extraNodes = request.getDoc().createDocumentFragment();
				}
				extraNodes.appendChild(presChild);
				break;
			}
			presChild = presChild.nextSibling;
		}

		// Is this presence for a contact, ourself, or something else?
		var contact = this.contactMap[bareFrom];
		if (contact) {
			// Update the contact presence and fire it's notify event
			contact.availability = availability;
			contact.status = status;
			contact.extraNodes = extraNodes;
			CrocSDK.Util.fireEvent(contact, 'onNotify', {});
		} else if (bareFrom === this.crocObject.address) {
			// It's us - fire onSelfNotify
			CrocSDK.Util.fireEvent(this, 'onSelfNotify', {
				instanceAddress: from.toString(),
				uniqueAddress: from.toString(),		// Deprecated
				availability: availability,
				status: status,
				extraNodes: extraNodes
			});

			if (from.getResource() === this.crocObject.xmppResource) {
				if (availability === 'unavailable' && this.disconnectTimerId) {
					clearTimeout(this.disconnectTimerId);
					this.crocObject.xmppCon.disconnect();
				}
			}
		} else {
			// Some other user, must be directed presence
			CrocSDK.Util.fireEvent(this, 'onDirectNotify', {
				address: bareFrom,
				instanceAddress: from.toString(),
				uniqueAddress: from.toString(),		// Deprecated
				availability: availability,
				status: status,
				extraNodes: extraNodes
			});
		}

		return true;
	};

	/*
	 * Public methods
	 */

	/**
	 * Starts the presence service client.
	 * <p>
	 * Connects to the presence service, requests the contact roster, and sends
	 * an initial 'available' presence message.
	 * 
	 * @memberof CrocSDK.XmppPresenceAPI
	 */
	CrocSDK.XmppPresenceAPI.prototype.start = function() {
		var croc = this.crocObject;

		if (this.running) {
			return;
		}

		if (croc.xmppCon) {
			this.running = true;
			connect(croc);
		}
	};

	/**
	 * Stops the presence service client.
	 */
	CrocSDK.XmppPresenceAPI.prototype.stop = function() {
		if (!this.running) {
			return;
		}
		this.running = false;

		var con = this.crocObject.xmppCon;
		if (con.connected()) {
			// Attempt graceful disconnect
			// Close down all XMPP data sessions
			var address = null;
			var xmppDataSessions = this.crocObject.data.xmppDataSessions;
			for (address in xmppDataSessions) {
				xmppDataSessions[address].close();
			}
			// Send unavailable presence update
			var presence = new JSJaCPresence();
			con.send(presence.setType('unavailable'));
			this.disconnectTimerId = setTimeout(function () {
				con.disconnect();
			}, 3000);
		} else {
			// Abort any current connection attempt ungracefully
			con.disconnect();
		}
	};

	/**
	 * Gets a fresh copy of the contact roster, firing 
	 * {@link CrocSDK.XmppPresenceAPI#event:onContactsReceived onContactsReceived}
	 * when complete.
	 * <p>
	 * This call should be rarely used, as it will be called automatically when
	 * connecting to the presence service.  It is provided in case the
	 * application's copy of the contact list has been lost or corrupted.
	 */
	CrocSDK.XmppPresenceAPI.prototype.getContacts = function() {
		if (!this.running) {
			throw new CrocSDK.Exceptions.StateError('Presence not started');
		}

		var iq = new JSJaCIQ();
		iq.setType('get');
		iq.setQuery(NS_ROSTER);
		this.crocObject.xmppCon.send(iq, processRosterGetResult, this);
	};
	
	/**
	 * Adds a new contact to the user's roster.
	 * 
	 * @param {string} address The address of the new contact.
	 * @param {Object} [params] Optional extra information that can be provided
	 * when adding a contact. If this  object is omitted, the defaults will be
	 * used.
	 * @param {boolean} [params.watch=true] Set to <code>true</code> to request
	 * to watch the new contact, or <code>false</code> to add the contact to the
	 * roster without watching.
	 * @param {boolean} [params.allowWatch=true] Set to <code>true</code> to
	 * pre-approve a watch request from the new contact, or <code>false</code>
	 * to receive notification of a watch request from the contact.
	 * <p>
	 * Note that support for pre-approval is optional for XMPP servers. If
	 * it is not supported, the pre-approval will be ignored, and the
	 * {@link CrocSDK.XmppPresenceAPI#event:onWatchRequest onWatchRequest} event
	 * will be fired as usual if the contact sends a watch request.
	 * @param {string} [params.name] The contact name/handle.  If not provided,
	 * the name will not be set for the contact.
	 * @param {Array<string>} [params.groups=[]] An array of group names to
	 * associate with the contact.  If not provided, the contact will not be
	 * associated with any groups (equivalent to an empty array).
	 * @see CrocSDK.XmppPresenceAPI~Contact
	 */
	CrocSDK.XmppPresenceAPI.prototype.addContact = function(address, params) {
		if (!this.running) {
			throw new CrocSDK.Exceptions.StateError('Presence not started');
		}

		var contact = new Contact(this, address);
		var postAddActions = null;
		params = params || {};
		var watch = params.watch !== false;
		var allowWatch = params.allowWatch !== false;

		if (params.name) {
			if (!CrocSDK.Util.isType(params.name, 'string')) {
				throw new TypeError('Unexpected type for name');
			}
			contact.name = params.name;
		}
		if (params.groups) {
			if (!CrocSDK.Util.isType(params.groups, 'string[]')) {
				throw new TypeError('Unexpected type for groups');
			}
			contact.groups = params.groups;
		}
		if (watch || allowWatch) {
			postAddActions = function () {
				if (watch) {
					contact.watch();
				}
				if (allowWatch) {
					contact.allowWatch();
				}
			};
		}

		sendRosterSet(contact, postAddActions);
	};

	/**
	 * Publishes new presence information for the current user.  The presence
	 * service handles distribution of the information to the authorised
	 * watchers of this user.
	 * 
	 * @param {CrocSDK.XmppPresenceAPI~PresenceInfo} [info]
	 * The presence information to publish.  If this is omitted, the user's
	 * availability will be reset to 'available', and the user's current status
	 * (if any) will be cleared.
	 */
	CrocSDK.XmppPresenceAPI.prototype.publishPresence = function(info) {
		if (!this.running) {
			throw new CrocSDK.Exceptions.StateError('Presence not started');
		}

		this.currentPresence = createPresence(this.crocObject, info);
		this.crocObject.xmppCon.send(this.currentPresence);
	};

	/**
	 * Sends the user's presence information to the specified address.
	 * <p>
	 * This is known as directed presence, and is not usually needed - in normal
	 * usage the presence service is responsible for broadcasting the user's
	 * presence information to watching contacts.  However, it can be useful
	 * to temporarily provide presence information when exchanging messages with
	 * a user not on your contact list.
	 * <p>
	 * Note that sending a directed presence does not change your normal
	 * presence information (as seen by watching contacts).
	 * 
	 * @param {string} address
	 * @param {CrocSDK.XmppPresenceAPI~PresenceInfo} [params]
	 * The presence information to send.  If this is omitted, the user's current
	 * published presence will be sent.
	 */
	CrocSDK.XmppPresenceAPI.prototype.sendPresence = function(address, info) {
		if (!this.running) {
			throw new CrocSDK.Exceptions.StateError('Presence not started');
		}

		var presence;
		if (info) {
			presence = createPresence(this.crocObject, info);
		} else {
			presence = this.currentPresence.clone();
		}
		this.crocObject.xmppCon.send(presence.setTo(address));
	};

	/*
	 * Public events
	 */

	/**
	 * Event fired when the SDK successfully connects to the presence service.
	 * 
	 * @event CrocSDK.XmppPresenceAPI#onConnected
	 */

	/**
	 * Event fired when the SDK is disconnected from the presence service.  The
	 * SDK will attempt to reconnect unless the
	 * {@link CrocSDK.XmppPresenceAPI#stop stop()} method is (or has already
	 * been) called.
	 * 
	 * @event CrocSDK.XmppPresenceAPI#onDisconnected
	 */

	/**
	 * Event fired when the full roster/contact list is received from the
	 * presence service.  This is expected soon after connecting to the service,
	 * and after any explicit calls to
	 * {@link CrocSDK.XmppPresenceAPI#getContacts getContacts()}.
	 * 
	 * @event CrocSDK.XmppPresenceAPI#onContactsReceived
	 * @type {Object}
	 * @property {Array<CrocSDK.XmppPresenceAPI~Contact>} contacts
	 * The received roster contacts.
	 */

	/**
	 * Event fired when a watch request is received.  A watch request indicates
	 * that another user has added this user to their contact list, and wishes
	 * to receive presence updates. 
	 * <p>
	 * If the watch request is approved, a new contact will be created
	 * automatically if the address is not already on the contact roster.
	 * 
	 * @event CrocSDK.XmppPresenceAPI#onWatchRequest
	 * @type {CrocSDK.XmppPresenceAPI~WatchRequestEvent}
	 */

	/**
	 * Event fired when a new contact has been added to the roster.
	 * <p>
	 * Note that the new contact could have been added by this client, or some
	 * other client logged in as the same user.  Thus the addition of a new
	 * contact to the UI should be tied to this event, rather than performed at
	 * the time {@link CrocSDK.XmppPresenceAPI#addContact addContact()} is
	 * called.
	 * 
	 * @event CrocSDK.XmppPresenceAPI#onNewContact
	 * @type {Object}
	 * @property {CrocSDK.XmppPresenceAPI~Contact} contact The new contact.
	 * @see CrocSDK.XmppPresenceAPI#addContact
	 */

	/**
	 * Event fired when notification of changes to the user's own presence has
	 * been received.
	 * <p>
	 * Note that the presence information may have been updated by another
	 * client logged in as the same user.
	 * 
	 * @event CrocSDK.XmppPresenceAPI#onSelfNotify
	 * @type {Object}
	 * @property {string} instanceAddress The full, unique address of the
	 * client instance that sent the presence update.
	 * @property {CrocSDK.XmppPresenceAPI~availability} availability
	 * The current availability of the client instance.
	 * @property {string} status The current status string set by the
	 * client instance.  This will be null if the client instance did not set
	 * the status.
	 */
	/*
	 * Undocumented extra property:
	 * @property {Node} extraNodes Any additional, unparsed XML nodes
	 * included in the presence update.
	 */

	/**
	 * Event fired when presence information is received from a user who is not
	 * on the the contact list/roster.  This may occur if messages are being
	 * exchanged with the user, and their client sends us a directed presence
	 * message.
	 * 
	 * @event CrocSDK.XmppPresenceAPI#onDirectNotify
	 * @type {Object}
	 * @property {string} instanceAddress The full, unique address of the
	 * client instance that sent the presence update.
	 * @property {string} address The address of the client instance that sent
	 * the presence update.
	 * @property {CrocSDK.XmppPresenceAPI~availability} availability
	 * The current availability of the client instance.
	 * @property {string} status The current status string set by the
	 * client instance.  This will be null if the client instance did not set
	 * the status.
	 */
	/*
	 * Undocumented extra property:
	 * @property {Node} extraNodes Any additional, unparsed XML nodes
	 * included in the presence update.
	 */

	/**
	 * @typedef {Object} CrocSDK.XmppPresenceAPI~PresenceInfo
	 * @property {CrocSDK.XmppPresenceAPI~availability} [availability=available]
	 * The user's availability.  Note that the user availability cannot be set
	 * to <code>unavailable</code> - this is only used when the user signs out.
	 * @property {string} [status] A short description of the user's status.
	 * If omitted, the current status (if any) will be cleared.
	 */
	/*
	 * Undocumented extra property:
	 * @property {Node} [extraNodes] Additional XML data to include
	 * in the presence update.  To include more than one node, wrap them in a
	 * DocumentFragment object.
	 */
}(CrocSDK));

(function($) {

	// Static method.
	/**
	 * <p>
	 * Initialises the Crocodile RTC JavaScript Library and returns a
	 * {@link CrocSDK.Croc Croc} Object instance. The <code>config</code>
	 * parameter should be an object containing any properties/event handlers
	 * you want to configure; any that are not provided will be set to their
	 * default value.
	 * </p>
	 * 
	 * <p>
	 * The <code>apiKey</code> property <b>MUST</b> be defined and the
	 * <code>sipProxySet</code>, <code>msrpRelaySet</code>, and
	 * <code>authorizationUser</code> properties <b>MUST NOT</b> be defined
	 * when the Crocodile RTC JavaScript Library is used with the Crocodile RTC
	 * Network.
	 * </p>
	 * 
	 * <p>
	 * The <code>apiKey</code> property <b>MUST NOT</b> be defined and the
	 * <code>sipProxySet</code> property <b>MUST</b> be defined when the
	 * Crocodile RTC JavaScript Library is used with other networks. The
	 * <code>msrpRelaySet</code> and <code>authorizationUser</code>
	 * properties <b>MAY</b> be defined when other networks are used.
	 * </p>
	 * 
	 * <p>
	 * Once initialised the Crocodile RTC JavaScript Library will automatically
	 * connect to the real-time communication network.
	 * </p>
	 * 
	 * <p>
	 * Exceptions: TypeError, {@link CrocSDK.Exceptions#ValueError ValueError}
	 * </p>
	 * 
	 * @memberof CrocSDK
	 * @function
	 * @param {CrocSDK~Config} config
	 *            <p>
	 *            The <code>config</code> parameter should be an object
	 *            containing any properties/event handlers you want to
	 *            configure; any that are not provided will be set to their
	 *            default value.
	 *            </p>
	 * @returns CrocSDK.Croc
	 */
	$.croc = function(config) {
		if (!config) {
			throw new CrocSDK.Exceptions.ValueError(
					"Configuration object missing");
		}

		config.jQuery = $;

		return new CrocSDK.Croc(config);
	};

	/**
	 * @typedef {Object} CrocSDK~Config
	 * @property {String} apiKey
	 * The API key to use when connecting to the Crocodile RTC Network.
	 * <p>
	 * API keys for the Crocodile RTC Network are allocated using the developer
	 * portal and an organisation/developer may have several API keys. API key
	 * security can be configured to ensure that the JavaScript has been
	 * retrieved from the site associated with the API key.
	 * @property {CrocSDK.Croc~Capabilities} [capabilities=detected]
	 * An object describing the capabilities the web app supports.
	 * <p>
	 * If a {@link CrocSDK.Croc~capabilities Capabilities} object is specified,
	 * its properties will be merged with (and override) the Crocodile RTC
	 * JavaScript Library default/detected capabilities. This way, you do not
	 * need to specify values for every possible capability, only the ones you
	 * wish to override. For example, if you have a webcam, but do not wish to
	 * support video, the following capabilities object should be used:
	 * <p>
	 * <b>Example Custom capabilities</b> <br/>
	 * <code>{ "sip.video": false }</code>
	 * @property {String} [address]
	 * The address associated with the current user.
	 * <p>
	 * This takes the same format as an email address, i.e. user@domain.com.
	 * This is needed if the application may receive inbound requests
	 * (the <code>register</code> property is <code>true</code>), or if user
	 * authentication is required.
	 * <p>
	 * The <code>password</code> property must also be specified if this
	 * property is set.
	 * @property {String} [password]
	 * This property is the password used for authenticating with the network.
	 * When using the Crocodile RTC Network, user authentication may not be
	 * needed, depending on the API key settings.
	 * <p>
	 * The <code>address</code> property must also be specified if this
	 * property is set.
	 * @property {String} [authorizationUser]
	 * This property sets the username used for authentication purposes. If it
	 * is not specified the <code>address</code> property is used. It is not
	 * used when connecting to the Crocodile RTC Network.
	 * @property {String} [displayName]
	 * Descriptive name for the current user which may be displayed to other
	 * users - must not include " characters.
	 * @property {Boolean} [register=detected]
	 * If set to <code>true</code> and the <code>address</code> property is set
	 * the Crocodile RTC JavaScript Library will register on the network,
	 * enabling inbound connections.
	 * <p>
	 * Defaults to <code>true</code> when the <code>address</code> property
	 * is set and <code>false</code> when it is not.
	 * @property {String|Array<string>} [sipProxySet=Crocodile RTC Network]
	 * The set of SIP proxies to use. If more than one is specified, SIP
	 * outbound (RFC 5626) will be used to connect to at least two of the
	 * proxies.
	 * <p>
	 * <i><b>MUST NOT</b> be explicitly set when the Crocodile RTC JavaScript
	 * Library is used with the Crocodile RTC Network.</i>
	 * @property {String|Array<string>} [msrpRelaySet=Crocodile RTC Network]
	 * The set of MSRP relays to use. If more than one is specified, new MSRP
	 * connections will be load-shared across the set.
	 * <p>
	 * <i><b>MUST NOT</b> be explicitly set when the Crocodile RTC JavaScript
	 * Library is used with the Crocodile RTC Network.</i>
	 * @property {Number} [expiresTime=600]
	 * Time (in seconds) that is used for network registration expiry. The
	 * Crocodile RTC JavaScript Library automatically refreshes the registration
	 * as long as it remains connected.
	 * @property {Boolean} [requireMatchingVersion=false]
	 * When connecting to another instance of the Crocodile RTC JavaScript
	 * Library, this property decides whether matching SDK versions are
	 * required. This is the most extreme, but safest way to avoid compatibility
	 * issues between instances.
	 * <p>
	 * If set to <code>true</code> and the versions do not match:
	 * <ul>
	 * <li>Inbound sessions will be rejected automatically, without notifying
	 * the application.</li>
	 * <li>Outbound sessions will be refused (with a
	 * {@link CrocSDK.Exceptions#VersionError VersionError} exception) if the
	 * remote party is being watched, and we have already cached the
	 * capabilities.</li>
	 * <li>Outbound sessions will be closed automatically if the session is
	 * established before we discover the version (assuming the remote party has
	 * &#34;requireMatchingVersion=<code>false</code>&#34;, and has not
	 * rejected the session).</li>
	 * @property {Number} [acceptTimeout=300]
	 * Time (in seconds) after which pending inbound sessions will be rejected.
	 * @property {Array<String>} [features]
	 * The CrocSDK library features to enable for the current application.
	 * <p>
	 * The available features are as follows:
	 * <ul>
	 * <li><code>video</code>: Request access to a webcam at startup (to
	 * determine whether one is available).
	 * <li><code>audio</code>: Request access to a microphone at startup (to
	 * determine whether one is available).
	 * <li><code>presence</code>: Start the presence API automatically.
	 * <li><code>pagedata</code>: Advertise the ability to receive page-mode
	 * messages.
	 * <li><code>transfer</code>: Advertise the ability to receive transfer
	 * requests.
	 * </ul>
	 * If not provided, the default behaviour is to enable the <code>video</code>,
	 * <code>audio</code> and <code>pagedata</code> features.
	 * @property {Function} [onConnected]
	 * Handler for the {@link CrocSDK.Croc#event:onConnected onConnected} event.
	 * @property {Function} [onDisconnected]
	 * Handler for the {@link CrocSDK.Croc#event:onDisconnected onDisconnected} event.
	 * @property {Function} [onRegistered]
	 * Handler for the {@link CrocSDK.Croc#event:onRegistered onRegistered} event.
	 * @property {Function} [onUnregistered]
	 * Handler for the {@link CrocSDK.Croc#event:onUnregistered onUnregistered} event.
	 * @property {Function} [onRegistrationFailed]
	 * Handler for the
	 * {@link CrocSDK.Croc#event:onRegistrationFailed onRegistrationFailed} event.
	 * @property {CrocSDK~CapabilityConfig} [capability] Capability API configuration.
	 * @property {CrocSDK~DataConfig} [data] Data API configuration.
	 * @property {CrocSDK~MediaConfig} [media] Media API configuration.
	 * @property {CrocSDK~PresenceConfig} [presence] Presence API configuration.
	 */

	/**
	 * @typedef {Object} CrocSDK~CapabilityConfig
	 * @property {Number} [refreshPeriod=15]
	 * Time interval (in seconds) between sending capabilities queries to
	 * addresses on the watch list.
	 * @property {Function} [onWatchRequest]
	 * Handler for the
	 * {@link CrocSDK.CapabilityAPI#event:onWatchRequest onWatchRequest} event.
	 * @property {Function} [onWatchChange]
	 * Handler for the
	 * {@link CrocSDK.CapabilityAPI#event:onWatchChange onWatchChange} event.
	 */

	/**
	 * @typedef {Object} CrocSDK~DataConfig
	 * @property {Number} [idleTimeout=300]
	 * Time (in seconds) after which idle sessions will be closed.
	 * @property {Function} [onData]
	 * Handler for the {@link CrocSDK.DataAPI#event:onData onData} event.
	 * @property {Function} [onDataSession]
	 * Handler for the {@link CrocSDK.DataAPI#event:onDataSession onDataSession}
	 * event.
	 * @property {Function} [onXHTMLReceived]
	 * Handler for the
	 * {@link CrocSDK.DataAPI#event:onXHTMLReceived onXHTMLReceived} event.
	 */

	/**
	 * @typedef {Object} CrocSDK~MediaConfig
	 * @property {Function} [onMediaSession]
	 * Handler for the
	 * {@link CrocSDK.MediaAPI#event:onMediaSession onMediaSession} event.
	 */

	/**
	 * @typedef {Object} CrocSDK~PresenceConfig
	 * @property {Function} [onConnected]
	 * Handler for the
	 * {@link CrocSDK.XmppPresenceAPI#event:onConnected onConnected} event.
	 * @property {Function} [onContactsReceived]
	 * Handler for the
	 * {@link CrocSDK.XmppPresenceAPI#event:onContactsReceived onContactsReceived} event.
	 * @property {Function} [onDirectNotify]
	 * Handler for the
	 * {@link CrocSDK.XmppPresenceAPI#event:onDirectNotify onDirectNotify} event.
	 * @property {Function} [onDisconnected]
	 * Handler for the
	 * {@link CrocSDK.XmppPresenceAPI#event:onDisconnected onDisconnected} event.
	 * @property {Function} [onNewContact]
	 * Handler for the
	 * {@link CrocSDK.XmppPresenceAPI#event:onNewContact onNewContact} event.
	 * @property {Function} [onSelfNotify]
	 * Handler for the
	 * {@link CrocSDK.XmppPresenceAPI#event:onSelfNotify onSelfNotify} event.
	 * @property {Function} [onWatchRequest]
	 * Handler for the
	 * {@link CrocSDK.XmppPresenceAPI#event:onWatchRequest onWatchRequest} event.
	 */

}(jQuery));
